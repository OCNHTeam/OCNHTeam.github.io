<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xjn&#39;s Blog</title>
  
  <subtitle>I AM A HFSSP</subtitle>
  <link href="https://blog.xjn819.com/feed.xml" rel="self"/>
  
  <link href="https://blog.xjn819.com/"/>
  <updated>2021-07-10T20:10:14.231Z</updated>
  <id>https://blog.xjn819.com/</id>
  
  <author>
    <name>Seon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>家用万兆FreeNAS组建</title>
    <link href="https://blog.xjn819.com/post/Home-freenas-build.html"/>
    <id>https://blog.xjn819.com/post/Home-freenas-build.html</id>
    <published>2021-04-03T14:27:50.000Z</published>
    <updated>2021-07-10T20:10:14.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我是一个很忠实的NAS用户，并且使用了FreeNas很多年，一直很稳定好用，也很想推荐给大家使用，就打算写这篇文章了，也没别的什么目的。</p><h1 id="为什么选择FreeNas"><a href="#为什么选择FreeNas" class="headerlink" title="为什么选择FreeNas"></a>为什么选择FreeNas</h1><ul><li>硬盘池的可拓展性</li><li>数据的安全性</li><li>ZFS格式</li><li>独特的缓存机制</li></ul></br><h1 id="什么样的用户适合FreeNas"><a href="#什么样的用户适合FreeNas" class="headerlink" title="什么样的用户适合FreeNas?"></a>什么样的用户适合FreeNas?</h1><p>首先刚开始玩的小白并不适合用FreeNas，上手比较难，但当然一开始就选择FreeNas，花费多一点的学习成本，肯定也是一个不错的选择。FreeNas有很多缺点，比如上手比较难（相比群晖什么的），入门条件也比较高，但你一但会用了，是一件很棒的事情。我罗列了一下条件：</p><ul><li><p>你并不打算用FreeNas来做一个All in One(AIO)的服务器。FreeNas更适合单独使用作为存储使用，它的虚拟化真的不怎么样，我有另外一台PVE来专门做别的服务。</p></li><li><p>你打算使用10GB万兆网络来使用FreeNas。其实FreeNas在万兆网络环境情况下才能体现优势，不然好像跟群晖之类的也没啥区别，设置还更难。</p></li><li><p>你的7200转的硬盘数量必须大于或者等于10个。因为考虑万兆环境，我们并不喜欢通过加缓存提高读命中率的方式来达到万兆，直接10个盘来让读取速度达到恒定万兆读取。（当然你可以加读缓存，但缓存永远是有限的，你还要考虑命中率等问题，没意思）</p></li><li><p>你的内存起码128GB，别慌，这其实不是很贵，比如我也会推荐DDR3的内存给X79用。</p></li></ul></br><h1 id="我该购买什么样的机器来运行FreeNas"><a href="#我该购买什么样的机器来运行FreeNas" class="headerlink" title="我该购买什么样的机器来运行FreeNas"></a>我该购买什么样的机器来运行FreeNas</h1><p>在FreeNas的官网有很多标准配置，我自己也是按照官网以及前辈的推荐来购买的，这样可以避免走很多弯路。<br>清单一是我自己的配置，价格也还好比较适中。</p></br><h2 id="清单一-（除机械硬盘外总计8991元）"><a href="#清单一-（除机械硬盘外总计8991元）" class="headerlink" title="清单一 （除机械硬盘外总计8991元）"></a>清单一 （除机械硬盘外总计8991元）</h2><ul><li><p>主板: 超微X10SRA-F  二手主板自带IPMI，这是我买服务器主板的首要条件，不然大机箱管理起来特别麻烦。 闲鱼买来950元</p></li><li><p>内存：海力士HMA82GR7CJR8N-VK 16G X8  一共128G内存，其实我觉得还是有点不够，淘宝二手价格还行。 380元X8=3040元</p></li><li><p>CPU：E5-2680V3 我买的线程数有点多了，非常够用，可以考虑买便宜一点的。665元</p></li></ul><ul><li><p>机箱：超微846 24盘位机箱。这款机箱淘宝有很多很多，并且自带背板，注意要问清楚自带的背板是SAS几的，最好买背板是SAS2或者SAS3的！如果机箱自带的是SAS1的话，你必须买回来把背板拆了，再买一个SAS2+的背板。1100元</p></li><li><p>散热器：猫头鹰（NOCTUA）NH-D15S 买这个完全是为了静音。这个高度是刚好给这个4U机箱用的，你可以按照此款高度购买别的静音款风扇。 600元</p></li><li><p>电源：PWS-920P-SQ 机箱自带的电源非常吵，不喜欢的话买这个，SQ结尾的是静音系列，这个机箱其实可以插两个电源，一个做冗余接在UPS，我买的是80块一个的成色非常差的（成色新的估计也只是抛光了一下），80元。</p></li><li><p>机箱背板：BPN-SAS2-846EL1 如果能买到超微846机箱自带SAS2+的最好不过了，如果不行，请购买这款。当然你要SAS3的就购买BPN-SAS3-846EL1(这款海外EBAY上很多，淘宝上就见到过一两次) 960元</p></li><li><p>机箱配件：机箱风扇，机箱开机键跳针 共200元</p><ul><li><p>背板后的风扇：ARCTIC F8 8cm X3 <a href="https://www.youtube.com/watch?v=oJB2MYf_QAk">更换教程请看2分28秒</a> </p></li><li><p>机箱最后的出风口风扇：ARCTIC F8 8cm X2</p></li><li><p>跳线：超微 CBL084L 机箱上连接开关电源键，指示灯的接口非常特殊，846机箱有很多版本，有的给X9用的，有的是X10用的。你可以自己制作公母杜邦线（PDD3块钱一大包），也可以购买我推荐的成品（淘宝有一家，EBAY无数家卖）。</p></li></ul></li></ul><ul><li><p>SAS卡：LSI SAS 9217-8i 这款卡是给SAS2用的，有两个模式，自己刷成it模式，可以找淘宝店主直接帮你刷好。如果你买的是SAS3的背板，你需要购买LSI SAS 9300-8i，同样需要刷好it模式（以防万一，我会写一下刷IT模式的教程）。 闲鱼100元</p></li><li><p>SAS线：MINI-SAS线SFF-8087 X2，SAS2的线，80CM的。如果是买的SAS3背板请购买相应的线，两根46元</p></li><li><p>万兆网卡：Intel 82599 万兆光口网卡 这张卡其实是我用黑苹果多余出来的。你可以买光口寨卡，82599或者mellanox的，都支持。但如果你购买万兆电口的话，尽可能购买原厂卡！（之前买的万兆寨卡一热就掉速） 闲鱼包含光模块250元（寨光卡）</p></li></ul><ul><li><p>机械硬盘：自己看着办（西数的固件降速策略似乎不太兼容FREEBSD）。</p></li><li><p>固态硬盘：intel s3510 1T 购买固态硬盘不是为了让他成为缓存什么的，因为ZFS的特殊性，尽可能设置PT软件（e.g. transmission）先把文件下载到固态，再自动转移到机械硬盘的池里，这主要是因为ZFS的特殊性而考虑。为什么买S3510呢？便宜吧，最主要是MLC，如果你用TLC做这个事，很快就会坏了的。1000元</p></li></ul></br><h2 id="清单二-（除机械硬盘外总计6780元）"><a href="#清单二-（除机械硬盘外总计6780元）" class="headerlink" title="清单二 （除机械硬盘外总计6780元）"></a>清单二 （除机械硬盘外总计6780元）</h2><ul><li><p>主板: 超微X9SRL-F  因为X9这一代的CPU单路支持IPMI的特别难找，这是我搜到的，可以试试搜搜别的单路更便宜的。800元</p></li><li><p>内存：M386B4G70DM0-YK04 32G X4 因为是DDR3的内存所以超级便宜，可以考虑多买一点，一共128G总计1480元 </p></li><li><p>CPU：E5-2650v2。根据自己情况可以选别的，165元</p></li><li><p>机箱：同清单一，1100元</p></li><li><p>电源，同清单一， 80元</p></li><li><p>散热器：利民thermalright ITX-R REV.A 清单一的太贵了，从高度来说可以，但不知道挡不档内存，500元</p></li><li><p>机箱背板：同清单一 960元</p></li><li><p>机箱配件：同清单一 共200元</p></li><li><p>SAS卡：同清单一 闲鱼100元</p></li><li><p>万兆网卡：同清单一 闲鱼包含光模块250元</p></li><li><p>机械硬盘：同清单一</p></li><li><p>固态硬盘：同清单一，1000元</p></li></ul><p>当然，以上两个清单你不考虑噪音可以便宜一些。</p></br><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装包括硬件和系统，首先是把SAS卡LSI SAS 9217-8i刷成it模式，再讲FreeNas的安装。<br></br></p><h2 id="LSI-SAS-9217-8i-刷成it模式"><a href="#LSI-SAS-9217-8i-刷成it模式" class="headerlink" title="LSI SAS 9217-8i 刷成it模式"></a>LSI SAS 9217-8i 刷成it模式</h2><p>在家用FreeNas环境我没有推荐用阵列模式，一来是这个是家用而已，二来ZFS已经足够健壮了，把卡刷成直通的it模式就行了。</p><ul><li><p>下载如下软件</p><ul><li> <a href="https://docs.broadcom.com/docs/12350820">UEFI Flashing Utility</a> </li><li> <a href="https://docs.broadcom.com/docs/12348628">UEFI ROM Image</a> </li><li> <a href="https://docs.broadcom.com/docs/12350493">SAS2308 Firmware 9217ir改9207it固件</a> </li></ul></li><li><p>准备一个U盘</p><ul><li>4G的U盘都够用了，不需要太大，但不要超过32G。</li><li>把U盘格式化成Fat32格式，注意不要带任何ESP分区。</li></ul></li><li><p>把文件放入U盘</p><ul><li>解压Installer_P20_for_UEFI.zip，复制Installer_P20_for_UEFI\sas2flash_efi_ebc_rel\sas2flash.efi 至U盘根目录。</li><li>解压UEFI_BSD_P20.zip，复制UEFI_BSD_P20\uefi_bsd_rel\Signed\x64sas2.rom 至U盘根目录。</li><li>解压9207_8i_Package_P20_IR_IT_FW_BIOS_for_MSDOS_Windows.zip。复制Firmware\HBA_9207_8i_IT\9207-8.bin 至U盘根目录。当然如果你是9300-8i的SAS卡，到官网下载一下it固件，一样的。</li><li>在同上一个目录复制sasbios_rel\mptsas2.rom 至U盘根目录。</li></ul></li></ul><ul><li>制作UEFI Shell启动项<ul><li>如果是超微主板，一般在开启选择启动画面是可以直接使用自带的UEFI Shell，那你就可以跳过此步骤。</li><li>在U盘根目录创建一个名叫efi文件夹，进入此文件夹，再创建一个叫boot的文件夹，即efi/boot/。同此也创建一组boot/efi/的文件夹。因为老一点的主板路径对UEFI的识别路径不同，以防万一，做两个。</li><li>下载 <a href="https://github.com/tianocore/edk/raw/master/Other/Maintained/Application/UefiShell/bin/x64/Shell_Full.efi">Shell_full.efi</a> </li><li>准备两份shell_full.efi，分别重命名为ShellX64.efi和BootX64.efi。</li><li>把ShellX64.efi和BootX64.efi放入efi/boot/下，同样的，把这两个文件放到boot/efi/<blockquote><p><font color="#660000">一般情况下，shell文件放在efi/boot/BootX64.efi即可，只是有些主板对UEFI的读取有点奇怪，记得要关了BIOS中的secure boot这个选项</font><br /></p></blockquote></li></ul></li></ul><ul><li><p>进入UEFI Shell</p><ul><li><p>开机按启动选择键，以U盘作为启动，进入UEFI shell，应该是一个类似如下的界面：<br><img src="https://i.loli.net/2021/04/03/5bFZNyDv2M4p83I.png" alt="e41a0684dd51574fd1cc6fed6c3d08fd55226f34.png"></p></li><li><p>如果你无法进入，提示错误，考虑一下升级主板bios以及确认主板是否支持UEFI启动，以及关闭主板的secure boot。</p></li><li><p>在界面上你会看到检测出来的硬盘，确认哪个是你的U盘，进入那个U盘则输入<code>fs0:</code></p></li><li><p>接着输入<code>dir</code>，看看目录下的文件是否是U盘里之前放的，不是的话退出去，再找别的路径进来。</p></li></ul></li></ul><ul><li>刷入固件<ul><li>进入U盘根目录后，输入sas2flash.efi -listall，确保你的卡被识别出来（图片我随便找的，跟你的卡数值可能不同）。<img src="https://i.loli.net/2021/04/03/uZEYmk21iphe8N3.jpg" alt="5a719c1baa02ba545539f89c3c77696dba3a1e60.jpg"></li><li>如果找不到这张卡，请确认这张卡是完好的，在bios设置界面中也能看到。</li><li>输入<code>sas2flash.efi -list</code>，记录下16位SAS Address (图片也是网上找的，可能不同，红色框内的所有东西都记下来！！！！！！！).<br><img src="https://i.loli.net/2021/04/03/DYcZOzgfPHJQS3h.png" alt="afae920ac73b9b7a6fa5b201efa5cf09dc4ddc00.png"></li><li>输入<code>sas2flash.efi -o -e 7</code>来删除当前固件。</li><li>输入<code>sas2flash.efi -o -f xxxxx.bin -b x64sas2.rom -b mptsas2.rom</code> 写入新的固件。xxxxx.bin应该是你之前放入的固件名字，比如9207-8.bin。</li><li>输入<code>sas2flash.efi -o -sasaddhi XXXXXXX</code> 写入SAS地址，其中XXXXXXX为刚才记录的SAS地址的前7位，一般是500开头。</li><li>接着按提示输入剩下的sas地址的数字，不需要输入<code>-</code>。</li><li>搞定，输入一下<code>sas2flash.efi -list</code>看看新的固件有没有刷进去。</li><li>重启输入<code>reset</code>就可以用了。</li></ul></li></ul></br><h1 id="FreeNas相关设置"><a href="#FreeNas相关设置" class="headerlink" title="FreeNas相关设置"></a>FreeNas相关设置</h1><p>怎么安装，怎么设置硬盘池，开共享目录那些就不说了，网上一大堆视频教程。如果是相关优化的话，因为每个人的机器需求不同，可以参考<a href="https://wiki.freebsd.org/ZFSTuningGuide">ZFS Tuning Guide</a>。</p><p>相信新手碰到最头痛的肯定就是权限问题了，这里可以展开说一下。</p><h2 id="FreeNas权限设置"><a href="#FreeNas权限设置" class="headerlink" title="FreeNas权限设置"></a>FreeNas权限设置</h2><p>其实这里有很多很多方法，我说一下我自己的吧，可能不是最好的办法，但是是我最习惯的办法。<br>一般新用户会去account里新建一个自己的用户，这个新的用户用来访问SMB,NFS等。比如我设置的用户叫做xjn，我打算用这个用户来使用所有的文件共享，我们就对所有的pool下面的datasheet的权限都给xjn，所有者和所有组都是（记得要apply permissions recursively)。提一嘴，如果是NFS共享，记得把Mapall User设置成xjn。</p><p>另一方面，我们可能会装一些jail来使用一些功能，比如安装transmission来下载，但是默认情况下，jail里transmission下载的所有文件都是归root用户所有，导致我们用自己的账户打不开这个文件。这里我们需要对transmission的权限给xjn这个用户，这样下载下来的文件都能打开了。</p><p>因为我不是特别喜欢freenas里面plugins一个插件一个jail的逻辑，我觉得你想要啥就全装在同一个jail里就够了。所以以下内容包括了设置权限，以及怎么手动装一个transmission（我打个比方而已）。</p><ul><li>获得你的gid uid<br>在shell下输入:<pre><code class="bash">root@truenas[~] id xjnuid=1000(xjn) gid=1000(xjn) groups=1000(xjn),0(wheel),545(builtin_users)</code></pre><blockquote><p>对，我给xjn这个用户多给了一个wheel的组，以防万一，你们可以参考一下。</p></blockquote></li></ul><p>得到我的这个xjn账户的uid和gid都是1000，记下来。</p><ul><li><p>创建一个jail</p><pre><code class="bash">iocage create -n &quot;myjail&quot; -r 12.2-RELEASE vnet=&quot;on&quot; ip4_addr=&quot;vnet0|10.10.10.4/24&quot; defaultrouter=&quot;10.10.10.3&quot; boot=&quot;on&quot;</code></pre><p>我们创建一个叫做myjail的jail，使用的是<code>12.2-RELEASE</code>这个版本，把这个jail的ip地址设置成了<code>10.10.10.4</code>，并且本地的路由器地址是<code>10.10.10.3</code>。请根据自己情况改一下。</p></li><li><p>在Jail中安装软件，我们假设装一个transmission。</p><pre><code class="bash">iocage console myjail   #进入刚才创建的myjail的shell里env ASSUME_ALWAYS_YES=YES pkg bootstrappkg updatepkg upgrade -y          #更新一下软件和源pkg install -y nano wget transmission    #安装一下这三个常用软件</code></pre></li></ul><ul><li>修改安装好的transmission的权限，保持与主系统一致。</li></ul><p>第一步里，记录下来我的常用用户为xjn (uid=1000)，那么我们在这个jail里创建一个一模一样的用户：</p><pre><code class="bash">pw useradd -n xjn -w none -u 1000 -c &quot;xjn&quot;#创建好之后，输入：id xjn#看一下jail里这个xjn的ID是否跟主系统中的一致</code></pre><blockquote><p>如果你的主系统NAS有多个用户要用，你可以把所用的用户归类到同一个组里去。<br>我们把transmission的权限交给jail里xjn这个用户：</p></blockquote><pre><code class="bash">cd /usr/local/etcchown -R xjn:xjn transmissionsysrc transmission_enable=YESsysrc transmission_user=xjnsysrc transmission_group=xjn</code></pre><ul><li>在jail中创建一个与主系统池相连的目录，用来给transmission下载</li></ul><p>仍然在刚才的jail的shell环境下，创建一个目录，比如是/mnt/pt</p><pre><code class="bash">mkdir /mnt/pt</code></pre><p>退出jail，回到主系统shell中，输入：</p><pre><code class="bash">exit</code></pre><p>把硬盘池的一个目录共享给jail用，比如主目录的地址为/mnt/home/pt,刚才我们在jail中设置的目录是/mnt/pt， 输入：</p><pre><code class="bash">iocage fstab -a myjail &quot;/mnt/home/pt&quot; &quot;/mnt/pt&quot; nullfs rw 0 0</code></pre><p>回到myjail中：</p><pre><code class="bash">iocage console myjail</code></pre><p>让transmission生成配置文件：</p><pre><code class="bash">service transmission startservice transmission stop</code></pre><p>修改配置文件：</p><pre><code class="bash">nano /usr/local/etc/transmission/home/settings.json</code></pre><p>修改如下两项：</p><pre><code class="xml">&quot;rpc-whitelist-enabled&quot;: false,&quot;umask&quot;: 7,</code></pre><p>修改完后<kbd>⌃</kbd>+<kbd>X</kbd>保存</p><p>在jail里绑定下载路径，输入：</p><pre><code class="bash">cd /usr/local/etcsysrc transmission_download_dir=&quot;/mnt/pt&quot;service transmission startexit</code></pre><p>至此，完成。</p><blockquote><p><font color="#660000">强烈建议使用transmission的incomplete-dir那个选项，把下载的东西先放到一个MLC的硬盘中，全下载完后，再自动移到主机械硬盘池。</font><br /></p></blockquote><br><h3 id="FreeNas-Tuning"><a href="#FreeNas-Tuning" class="headerlink" title="FreeNas Tuning"></a>FreeNas Tuning</h3><p>刚才有说到官网的freenas tuning设置，因为每个人的习惯不同似乎没有一个比较统一的说法，这是我的微调：</p><ul><li>vfs.zfs.dirty_data_max  </li></ul><p>这个值是脏数据，默认是4GB，但是我一般拷贝单个文件到NAS上，很多都是超过8G的，这样在持续写入一段时间后会掉速到机械硬盘池的真正写入速度，我就把这个值调整到了8589932492（8gb）来优化了体验，按照你的需求和物理限制更改。</p><ul><li>vfs.zfs.arc_max </li></ul><p>这个是真的“写缓存”，其实我用默认的调整还是不错的，没有啥固定标准我就不说了</p><h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><ul><li>是否需要自己加Slog以及L2arc？</li></ul><p>你的网速是10gb，以及10个7200转的硬盘的话，不需要。SLOG是保证你数据绝对能写入，并不是帮你增加速度的，比较适用与金融场景，家用还是配好UPS吧。L2ARC的话是你内存不够用的情况下才用的，但是我们10个7200转的硬盘已经达到读取速度900+MB/S了，其实不需要读缓存了。设置多层存储或者说缓存的目的我觉得不是为了加速度（当然有这个效果），而是确保数据安全而用的。</p><ul><li>硬盘性能</li></ul><p>买来先测一下硬盘的stroke和速度，</p><pre><code class="bash">diskinfo -ctv /dev/daX#X为你的硬盘编号，在管理页面的storage/disks下按照序列号对照过去</code></pre><p>这是我刚用手机测的一块ST EXOS X16 12T的硬盘，刚好达到230MB的速度，stroke也很棒。西数固件似乎在FREEBSD下有兼容问题。</p><p><img src="https://i.loli.net/2021/04/14/GrqjvK2TtW93gnC.png" alt="IMG_2776.PNG"></p><ul><li>内存是否必须ECC？<br>当然最好是ECC了，FreeNas先写入内存再写入硬盘，如果没有ECC的奇偶校验，<code>可能，也许</code>会有写入后文件出错的问题。另一方面，我看到国内很多文章宣称Slog是写缓存，我觉得与我们理解的写缓存差别还是很大的，总而言之，<font color="#660000">Slog无法让你获得比将硬盘池的sync关闭后更快的速度。</font>老老实实加ECC内存吧，ddr3内存来一斤。</li></ul><blockquote><p>如果你真的很需要多层存储，可以去研究一下这个玩意：<a href="https://bcache.evilpiepirate.org/">Bcache</a></p></blockquote><ul><li>ZFS是什么？<br>好问题，有一篇图文并茂的文章，可以看看：<a href="https://arstechnica.com/information-technology/2020/05/zfs-101-understanding-zfs-storage-and-performance/3/">Understanding ZFS storage and performance</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;我是一个很忠实的NAS用户，并且使用了FreeNas很多年，一直很稳定好用，也很想推荐给大家使用，就打算写这篇文章了，也没别的什么目的。&lt;/</summary>
      
    
    
    
    <category term="Hardware" scheme="https://blog.xjn819.com/categories/Hardware/"/>
    
    
    <category term="NAS" scheme="https://blog.xjn819.com/tags/NAS/"/>
    
    <category term="Hardware" scheme="https://blog.xjn819.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>内核崩溃报告解读</title>
    <link href="https://blog.xjn819.com/post/kernel-panic-report-analysis.html"/>
    <id>https://blog.xjn819.com/post/kernel-panic-report-analysis.html</id>
    <published>2020-11-01T14:27:50.000Z</published>
    <updated>2020-11-19T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>首先我们确认自己的内核版本<pre><code class="bash">uname -aDarwin xjns-iMac-Pro.local 19.6.0 Darwin Kernel Version 19.6.0: Mon Aug 31 22:12:52 PDT 2020; root:xnu-6153.141.2~1/RELEASE_X86_64 x86_64</code></pre></li><li>确认自己的电脑已经开启了<code>kASLR</code>功能</li></ul><hr><h1 id="错误报告（Kernel-panic-report）"><a href="#错误报告（Kernel-panic-report）" class="headerlink" title="错误报告（Kernel panic report）"></a>错误报告（Kernel panic report）</h1><p> 一般存放在<code>/Library/Logs/DiagnosticReports/</code> 目录下，报告以<code>.panic</code>结尾。比如<code>Kernel_2020-10-15-185538_Patricks-MacBook-Pro.panic</code>。</p><p>随便网上找了一份错误报告：</p><pre><code class="bash">*** Panic Report ***panic(cpu 6 caller 0xffffff8008b6f2e9): Kernel trap at 0xffffff7f8c7ba8b1, type 14=page fault, registers:CR0: 0x000000008001003b, CR2: 0xffffff80639b8000, CR3: 0x0000000022202000, CR4: 0x00000000003627e0RAX: 0x0000000000000564, RBX: 0x0000000000000564, RCX: 0x0000000000000020, RDX: 0x000000000000002aRSP: 0xffffff92354ebc80, RBP: 0xffffff92354ebce0, RSI: 0x00000000000fbeab, RDI: 0xffffff92487b9154R8:  0x0000000000000000, R9:  0x0000000000000010, R10: 0x0000000000000010, R11: 0x0000000000000000R12: 0xffffff80639b6a70, R13: 0xffffff92354ebdc0, R14: 0xffffff92354ebdd4, R15: 0x0000000000000000RFL: 0x0000000000010297, RIP: 0xffffff7f8c7ba8b1, CS:  0x0000000000000008, SS:  0x0000000000000010Fault CR2: 0xffffff80639b8000, Error code: 0x0000000000000000, Fault CPU: 0x6, PL: 0, VF: 1Backtrace (CPU 6), Frame : Return Address0xffffff92354eb730 : 0xffffff8008a505f6 0xffffff92354eb780 : 0xffffff8008b7d604 0xffffff92354eb7c0 : 0xffffff8008b6f0f9 0xffffff92354eb840 : 0xffffff8008a02120 0xffffff92354eb860 : 0xffffff8008a5002c 0xffffff92354eb990 : 0xffffff8008a4fdac 0xffffff92354eb9f0 : 0xffffff8008b6f2e9 0xffffff92354ebb70 : 0xffffff8008a02120 0xffffff92354ebb90 : 0xffffff7f8c7ba8b1 0xffffff92354ebce0 : 0xffffff7f8c7ba40f 0xffffff92354ebd60 : 0xffffff7f8c7b85e8 0xffffff92354ebda0 : 0xffffff7f8c7b9db2 0xffffff92354ebe00 : 0xffffff7f8b2b3873 0xffffff92354ebe50 : 0xffffff7f8b2bd473 0xffffff92354ebe90 : 0xffffff7f8b2bcc7d 0xffffff92354ebed0 : 0xffffff8009091395 0xffffff92354ebf30 : 0xffffff800908fba2 0xffffff92354ebf70 : 0xffffff800908f1dc 0xffffff92354ebfa0 : 0xffffff8008a014f7       Kernel Extensions in backtrace:         com.apple.iokit.IOAcceleratorFamily2(376.6)[5F8F39B4-41AB-3263-9867-D0FAF9BBD2AE]@0xffffff7f8b2b0000-&gt;0xffffff7f8b345fff            dependency: com.apple.driver.AppleMobileFileIntegrity(1.0.5)[58669FC2-CC90-3594-AD69-DB89B923FD20]@0xffffff7f899ff000            dependency: com.apple.iokit.IOSurface(209.2.2)[AE58720D-7079-388F-AD95-FD2366F98F8D]@0xffffff7f8b294000            dependency: com.apple.iokit.IOPCIFamily(2.9)[C08F7FC1-78A4-3A1B-BFE2-C07080CF2048]@0xffffff7f89294000            dependency: com.apple.iokit.IOGraphicsFamily(517.22)[2AEA02BF-2A38-3674-A187-E5F610FD65B7]@0xffffff7f89a39000         com.apple.kext.AMDRadeonX4150(1.6)[DF336AB9-8300-3ED2-AAD3-7D2C8F4B8DEB]@0xffffff7f8c7b4000-&gt;0xffffff7f8cf20fff            dependency: com.apple.iokit.IOSurface(209.2.2)[AE58720D-7079-388F-AD95-FD2366F98F8D]@0xffffff7f8b294000            dependency: com.apple.iokit.IOPCIFamily(2.9)[C08F7FC1-78A4-3A1B-BFE2-C07080CF2048]@0xffffff7f89294000            dependency: com.apple.iokit.IOGraphicsFamily(517.22)[2AEA02BF-2A38-3674-A187-E5F610FD65B7]@0xffffff7f89a39000            dependency: com.apple.iokit.IOAcceleratorFamily2(376.6)[5F8F39B4-41AB-3263-9867-D0FAF9BBD2AE]@0xffffff7f8b2b0000BSD process name corresponding to current thread: kernel_taskMac OS version:17C88Kernel version:Darwin Kernel Version 17.3.0: Thu Sep 9 18:09:22 PST 2020; root:xnu-4570.31.3~1/RELEASE_X86_64Kernel slide:     0x0000000008600000Kernel text base: 0xffffff8008800000__HIB  text base: 0xffffff8008700000System model name: MacBookPro14,3EOF</code></pre><p>错误报告有很多无用内容，我们直接看错误发生在哪里：</p><pre><code class="bash"> panic(cpu 6 caller 0xffffff8008b6f2e9): Kernel trap at 0xffffff7f8c7ba8b1, type 14=page fault</code></pre><p>这段告诉我们系统奔溃是因为<code>type 14=page fault</code>。这种错误往往指出这段内容无法写入或读取一段内存页。</p><p>接着，我们需要找到发生错误命令的注册的<code>地址</code>。在这之前，我们先记录一下它的<code>RIP</code>，也就是命令在哪一段死了，从报告中搜索<code>RIP</code>，我们搜到的是<code>0xffffff7f8c7ba8b1</code>。</p><p>据此，根据内存注入的地址，我们得到引起错误的<code>地址</code>是<code>0xffffff80639b8000</code>。</p><pre><code class="bash">Fault CR2: 0xffffff80639b8000, Error code: 0x0000000000000000, Fault CPU: 0x6 ...</code></pre><p>这份错误报告同样回溯了这样的错误是通过何种功能方法注入导致的错误指令。</p><pre><code class="bash">  Backtrace (CPU 6), Frame : Return Address  0xffffff92354eb730 : 0xffffff8008a505f6   0xffffff92354eb780 : 0xffffff8008b7d604   0xffffff92354eb7c0 : 0xffffff8008b6f0f9   0xffffff92354eb840 : 0xffffff8008a02120   0xffffff92354eb860 : 0xffffff8008a5002c   0xffffff92354eb990 : 0xffffff8008a4fdac   0xffffff92354eb9f0 : 0xffffff8008b6f2e9   0xffffff92354ebb70 : 0xffffff8008a02120   0xffffff92354ebb90 : 0xffffff7f8c7ba8b1   0xffffff92354ebce0 : 0xffffff7f8c7ba40f   0xffffff92354ebd60 : 0xffffff7f8c7b85e8   0xffffff92354ebda0 : 0xffffff7f8c7b9db2   0xffffff92354ebe00 : 0xffffff7f8b2b3873   0xffffff92354ebe50 : 0xffffff7f8b2bd473   0xffffff92354ebe90 : 0xffffff7f8b2bcc7d   0xffffff92354ebed0 : 0xffffff8009091395   0xffffff92354ebf30 : 0xffffff800908fba2   0xffffff92354ebf70 : 0xffffff800908f1dc   0xffffff92354ebfa0 : 0xffffff8008a014f7</code></pre><p>我们需要找到这些内存地址归属于哪一个kexts才能真正去寻找这个错误的来源：</p><pre><code class="bash">kext: com.apple.iokit.IOAcceleratorFamily2loaded at: 0xffffff7f8b2b0000kext: com.apple.kext.AMDRadeonX4150loaded at: 0xffffff7f8c7b4000</code></pre><p>这份报告中可能缺少一些对我们非常重要的信息，但是<code>Kernel slide</code>值<code>0x0000000008600000</code>告诉了我们内核镜像如何通过<code>kASLR</code>转换到了内存中。</p><p>总的来说，通过此份报告，我们得到了：</p><ul><li>内核在注入<code>0xffffff80639b8000</code>发生了错误。</li><li>错误被禁止（RIP）的地址是<code>0xffffff7f8c7ba8b1</code>。</li><li><code>com.apple.iokit.IOAcceleratorFamily2</code> 和 <code>com.apple.kext.AMDRadeonX4150</code>这两个kexts是引起错误的主要原因。</li><li>内核通过<code>kASLR</code>转换进内存的地址是<code>0x0000000008600000</code>。</li><li>内存地址的最后一段是<code>0xffffff8008a014f7</code></li></ul><hr><h1 id="分析错误报告"><a href="#分析错误报告" class="headerlink" title="分析错误报告"></a>分析错误报告</h1><p>得到了主要的几个数据后，我们把<code>/System/Library/Kernels/kernel</code>拖入<a href="https://www.hopperapp.com/">Hopper disassembler</a>软件里， 因为<code>kASLR</code>把内核注入到了内存中，我们需要<code>Hopper Disassembler</code>来重新定位镜像。按<code>Modify</code>然后点击<code>Change File Base Address</code>。输入之前得到的<code>slide地址+0x100000</code>,也就是<code>0x0000000008600000+0x100000=0xffffff8008700000</code>。</p><p><img src="https://i.loli.net/2020/11/01/4eIkl1Bh6ivn98S.png" alt="Screen Shot 2020-11-01 at 10.12.23 PM.png"><br>等待内核镜像被重新定位后，我们点击<code>G</code>输入内存的最后一段地址<code>0xffffff8008a014f7</code></p><p><img src="https://i.loli.net/2020/11/01/X9FuhIAGMoZWOxa.png" alt="Screen Shot 2020-11-01 at 10.18.45 PM.png"></p><p>拆开镜像后我们看到这条指令是直接被加载在一条<code>call</code>指令之前。<br><img src="https://i.loli.net/2020/11/01/pZivqjxuQSOrP2D.png" alt="callCont.png"></p><p>一般来说，我们的CPU收到了<code>call</code>指令后，它会马上保存这个地址，这样允许我们知道如何去return这个<code>call</code>以及什么时候这个<code>call</code>完成。当内核正在准备错误报告时，它通过回溯这个被保存的地址来找到错误关键。因此，当我们遇到一个回溯的地址比如<code>0xffffff8008a014f7</code>时，它会立即保存并执行回溯。 所以根据这张图，在<code>0xffffff8008a014f5</code>地址上的<code>call rcx</code>是产生错误的位置。</p><p>我们根据这个地址，按照内存的排列顺序往上回溯，我们可以列出如下信息：</p><ul><li><p>kernel.call_continuation() </p><ul><li>0xffffff8008a014f5 call rcx</li></ul></li><li><p>kernel.IOWorkLoop::threadMain()</p><ul><li>0xffffff800908f1d6 call qword [rax+0x1a8]</li></ul></li><li><p>kernel.IOWorkLoop::runEventSources()</p><ul><li>0xffffff800908fb9c call qword [rax+0x120]</li></ul></li><li><p>kernel.IOInterruptEventSource::checkForWork()</p><ul><li>0xffffff8009091392 call r11</li></ul></li></ul><ul><li><p>com.apple.iokit.IOAcceleratorFamily2.IOAccelEventMachine2::hardwareErrorEvent()</p><ul><li>0xffffff7f8b2bcc78 call IOAccelEventMachine2::restart_channel()</li></ul></li><li><p>com.apple.iokit.IOAcceleratorFamily2.IOAccelEventMachine2::restart_channel()</p><ul><li>0xffffff7f8b2bd46d call qword [rax+0x160]</li></ul></li><li><p>com.apple.iokit.IOAcceleratorFamily2.IOAccelFIFOChannel2::restart()</p><ul><li>0xffffff7f8b2b386d call qword [rax+0x208]</li></ul></li></ul><ul><li><p>com.apple.kext.AMDRadeonX4150.AMDRadeonX4150_AMDAccelChannel::getHardwareDiagnosisReport()</p><ul><li>0xffffff7f8c7b9dac call qword [rax+0xb00]</li></ul></li><li><p>com.apple.kext.AMDRadeonX4150.AMDRadeonX4150_AMDGraphicsAccelerator::writeDiagnosisReport()</p><ul><li>0xffffff7f8c7b85e2 call qword [rax+0x258]</li></ul></li><li><p>com.apple.kext.AMDRadeonX4150.AMDRadeonX4150_AMDAccelChannel::writeDiagnosisReport()</p><ul><li>0xffffff7f8c7ba40a call AMDRadeonX4150_AMDAccelChannel::writePendingCommandInfo</li></ul></li><li><p>com.apple.kext.AMDRadeonX4150.AMDRadeonX4150_AMDAccelChannel::writePendingCommandInfoDiagnosisReport()</p><ul><li>0xffffff7f8c7ba8b1 <code>mov r8d, dword [r12+rax*4]</code></li></ul></li></ul><ul><li>kernel.hndl_alltraps()<ul><li>0xffffff8008a0211b call _kernel_trap</li></ul></li></ul><p>我们列出表格后，就可以更轻松看到这个错误是如何发生的。准确地说，这个错误是<code>com.apple.iokit.IOAcceleratorFamily2</code> kext 在处理硬件时产生的。<br><code>com.apple.iokit.IOAcceleratorFamily2</code>产生了<code>restart_channel</code>，转而把信息递交到了<code>com.apple.kext.AMDRadeonX4150</code>。一般来说，这个kext是AMD 560显卡的驱动。</p><p>除了这个<code>restart_channel</code>之外，硬件的分析信息也同时生成了。<code>com.apple.kext.AMDRadeonX4150</code>执行了 <code>AMDRadeonX4150_AMDAccelChannel::writeDiagnosisReport</code>，这种方法我们叫做<code>writePendingCommandInfoDiagnosisReport</code>。</p><p> 我们看到第11个位置，它不是一个<code>call</code>指令，而是一个<code>move</code>指令：</p><pre><code class="bash">0xffffff7f8c7ba8b1 mov r8d, dword [r12+rax*4]</code></pre><p>另外，我们在载入<code>com.apple.kext.AMDRadeonX4150</code> kext,同样发现了这个地址<code>0xffffff7f8c7ba8b1</code>，与错误报告中的RIP地址一致。另外，下一段地址执行了一个<code>call back</code>去处理一个trap(<code>call_kernel_trap</code>)，也就是这个报告里面的<code>page fault</code>。这意味着这个<code>move</code>指令是导致错误的真正元凶。</p><p><img src="https://i.loli.net/2020/11/01/7iXtwuvsdCRYKoQ.png" alt="fault.png"></p><p>现在我们找到了导致错误的真正地址和指令，我们可以更详细地看这个指令。我们看到它在R12这个base上面增加了一个<code>RAX*4</code>。通过计算我们得到增加到的是<code>R8d</code>。因为我们原始的错误报告中记录了这个错误指令的注册值，我们可以重新计算这个地址：</p><pre><code class="bash">  registers:  CR0: 0x000000008001003b, CR2: 0xffffff80639b8000, ...  RAX: 0x0000000000000564, RBX: 0x0000000000000564, ...  RSP: 0xffffff92354ebc80, RBP: 0xffffff92354ebce0, ...  R8:  0x0000000000000000, R9:  0x0000000000000010, ...  R12: 0xffffff80639b6a70, R13: 0xffffff92354ebdc0, ...  RFL: 0x0000000000010297, RIP: 0xffffff7f8c7ba8b1, ...</code></pre><pre><code class="bash">mov r8d, dword [r12+rax*4]R12: 0xffffff80639b6a70RAX: 0x0000000000000564R12 + RAX*4 = 0xffffff80639b6a70 + (0x564 * 4) = 0xffffff80639b8000</code></pre><p>计算出来的<code>0xffffff80639b8000</code>地址，便是我们原始报告中的：</p><pre><code class="bash">Fault CR2: 0xffffff80639b8000, Error code: 0x0000000000000000, Fault CPU: 0x6 ...</code></pre><p>从这里看出来，<code>0xffffff80639b8000</code>注册在了没有寻址过的页面中，因此，在<code>com.apple.kext.AMDRadeonX4150</code>中执行<code>mov</code>命令是不可行的，最终导致系统奔溃。<br>但是，我们不能100%确定为什么这个指令会在不被寻址的页面中执行。我们因此会有如下的疑问：</p><ul><li><p>R12这个地址是被其他东西占用了或者本身就是无效的吗？</p></li><li><p>这个增加的RAX值本身就是无效的还是太大了所以超出了范围？</p></li><li><p>还是这本身就是个硬件问题？</p></li></ul><p>显卡驱动是非常复杂的，并且你可能需要通过很多逆向工程才能获得一些基础的认识。但是我们可以假设应该有方法去绕过这个错误，比如说确认一下这个<code>RAX</code>值是否在<code>R12</code>范围内？</p><p>根据这种情况，我们何不考虑把R12这个值移动到可读的范围内呢？<br>我们尝试用一个<code>r8</code>来替换，发现<code>snprintf</code>功能引导出来了。</p><pre><code class="bash">  ffffff7f8c7ba8af   mov        eax, eax  ffffff7f8c7ba8b1   mov        r8d, dword [r12+rax*4] ;faulting instruction  ffffff7f8c7ba8b5   xor        eax, eax  ffffff7f8c7ba8b7   lea        rdx, qword [aC08x]     ; &quot;%c%08x&quot;  ffffff7f8c7ba8be   call       0xffffff7f198091e8     ;  snprintf</code></pre><p>关于这个会话，macOS确认了<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">ystem V AMD64 ABI</a>。这意味着<code>R8</code>是第五条arg去引入<code>snprintf</code>。</p><pre><code class="bash">int snprintf(char *str, size_t size, const char *format, ...);</code></pre><p>这样的话，<code>snprintf</code>被加入到了<code>%c%08x</code>，第五个指令就会被寻址到<code>%08x</code>。这样，<code>R8</code>就能被注册进寻址过的页面中去了。<br>因为这个代码被加入到了<code>writeDiagnosisReport</code>，我们可以猜测带有<code>R8</code>的<code>snprintf</code>被写到了user mode之外，因此用这样的方法可以暂时解决。</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Objective-See., (2018). An Unpatched Kernel Bug., avaliable at <a href="https://objective-see.com/index.html">https://objective-see.com/index.html</a>. last accessed at 1st Nov.2020.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;首先我们确认自己的内核版本&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;uname -a
Darwin xjns-iMac-P</summary>
      
    
    
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/categories/Hackintosh/"/>
    
    
    <category term="OpenCore" scheme="https://blog.xjn819.com/tags/OpenCore/"/>
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/tags/Hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCore 引导黑苹果</title>
    <link href="https://blog.xjn819.com/post/opencore-guide.html"/>
    <id>https://blog.xjn819.com/post/opencore-guide.html</id>
    <published>2020-10-29T14:42:50.000Z</published>
    <updated>2021-06-23T19:17:53.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Opencore引导的相关设置，无聊更新，慢更。</p><hr><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li><p><a href="https://khronokernel-2.gitbook.io/opencore-vanilla-desktop-guide/">Opencore Vanilla Desktop Guide</a></p></li><li><p><a href="https://github.com/khronokernel/Getting-Started-With-OpenCore">Getting Started With OpenCore</a></p></li></ul><ul><li><a href="https://blog.daliansky.net/OpenCore-BootLoader.html">精解OpenCore</a></li></ul><hr><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><ul><li><p>Xcode （从 App Store 或  <a href="https://developer.apple.com/">Apple Developer</a> 下载)</p></li><li><p><a href="https://github.com/corpnewt/ProperTree">ProperTree</a> 最新推荐的 config 编辑器</p></li><li><p><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenCore</a>（官方稳定版本）</p></li><li><p><a href="http://headsoft.com.au/download/mac/Hackintool.zip">Hackintool</a></p></li><li><p><a href="http://blog.xjn819.com/wp-content/uploads/2019/10/MaciASL.zip">MaciASL</a></p></li><li><p><a href="https://github.com/daliansky/OC-little">宪武大大oc部件</a></p></li><li><p><a href="https://github.com/acidanthera/gfxutil/releases">gfxutil</a></p></li></ul><hr><h2 id="更新日记"><a href="#更新日记" class="headerlink" title="更新日记"></a>更新日记</h2><details>  <summary><font color=red>点击查询帖子最近更新</font></summary><h3 id="2021-06-13"><a href="#2021-06-13" class="headerlink" title="2021-06-13"></a>2021-06-13</h3><ul><li>补充修改Config/Misc/Boot/PickerMode</li><li>补充修改Config/Misc/Boot/PickerVariant</li><li><a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li></ul><h3 id="2021-06-12"><a href="#2021-06-12" class="headerlink" title="2021-06-12"></a>2021-06-12</h3><ul><li>增加Config/Kernel/Quirks/ProvideCurrentCpuInfo</li><li>增加Config/Misc/Security/AllowToggleSip</li><li>增加Config/Misc/Tools/Flavour</li><li>增加Config/Misc/Tools/RealPath</li><li>增加Config/Misc/Tools/TextMode</li><li>增加Config/NVRAM/Add/ForceDisplayRotationInEFI</li><li>增加Config/PlatformInfo/Generic/AdviseFeatures</li><li>删除Config/PlatformInfo/Generic/AdviseWindows</li><li>修改Config/UEFI/Output/GopPassThrough</li><li>增加Config/UEFI/ProtocolOverrides/AppleEg2Info</li><li><a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li></ul><h3 id="2021-06-07"><a href="#2021-06-07" class="headerlink" title="2021-06-07"></a>2021-06-07</h3><ul><li>因问题比较严重，更新Kernel/quirks/SetApfsTrimTimeout的说明。</li></ul><h3 id="2021-05-06"><a href="#2021-05-06" class="headerlink" title="2021-05-06"></a>2021-05-06</h3><p>适配OpenCore 0.6.9</p><ul><li>修改Config/UEFI/AppleInput/CustomDelays</li><li>修改Config/UEFI/AppleInput/KeyInitialDelay</li><li>修改Config/UEFI/AppleInput/KeySubsequentDelay</li><li>增加Config/UEFI/Quirks/EnableVectorAcceleration</li><li>增加Config/UEFI/Quirks/ForgeUefiSupport</li><li>增加Config/UEFI/Quirks/ReloadOptionRoms</li></ul><h3 id="2021-04-15"><a href="#2021-04-15" class="headerlink" title="2021-04-15"></a>2021-04-15</h3><p>适配OpenCore 0.6.8</p><ul><li><a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li><li>增加boot/quirks/ForceBooterSignature</li><li>增加UEFI/AppleInput</li><li>删除UEFI/ProtocolOverrides/AppleEvent</li></ul><h3 id="2021-03-17"><a href="#2021-03-17" class="headerlink" title="2021-03-17"></a>2021-03-17</h3><p>适配OpenCore 0.6.7</p><ul><li><a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li><li>增加UEFI/Audio/ResetTrafficClass</li><li>增加UEFI/Output/GopPassThrough</li><li>增加UEFI/Quirks/ActivateHpetSupport</li></ul><h3 id="2021-02-06"><a href="#2021-02-06" class="headerlink" title="2021-02-06"></a>2021-02-06</h3><p>适配OpenCore 0.6.6</p><ul><li><a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li><li>增加Kernel/quirks/SetApfsTrimTimeout</li><li>增加Misc/boot/LauncherOption</li><li>增加Misc/boot/LauncherPath</li><li>删除Misc/Security/BootProtect</li><li>增加Config/PlatformInfo/Generic/UseRawUuidEncoding</li><li>增加UEFI/Quirks/DisableSecurityPolicy</li><li>删除DeduplicateBootOrder</li></ul><h3 id="2021-01-18"><a href="#2021-01-18" class="headerlink" title="2021-01-18"></a>2021-01-18</h3><ul><li>增加Misc/Boot/PickerVariant <a href="https://github.com/acidanthera/OcBinaryData">请同步更新OcBinaryData!</a></li><li>增加UEFI/Audio/SetupDelay</li><li>删除UEFI/Quirk/DeduplicateBootOrder</li><li>增加Config/PlatformInfo/Generic/MaxBIOSVersion</li></ul><h3 id="2020-12-12"><a href="#2020-12-12" class="headerlink" title="2020-12-12"></a>2020-12-12</h3><p>适配OpenCore 0.6.4</p><ul><li>增加booter/quirk/AllowRelocationBlock</li><li>增加booter/Patch</li><li>修改Misc/Boot/PickerAttributes</li><li>修改misc/Security/BootProtect</li><li>修改UEFI/Audio/PlayChime</li></ul><h3 id="2020-11-02"><a href="#2020-11-02" class="headerlink" title="2020-11-02"></a>2020-11-02</h3><p>适配OpenCore 0.6.3</p><ul><li>增加ForceResolution</li><li>增加ForceSecureBootScheme</li><li>增加CustomMemory</li></ul><h3 id="2020-10-14"><a href="#2020-10-14" class="headerlink" title="2020-10-14:"></a>2020-10-14:</h3><p>1.Opencore 0.6.2 正式版修改如下 variables:</p><ul><li>增加 ExtendBTFeatureFlags （章节2.4.6）</li><li>移除 DummyPowerManagement（章节2.4.6）</li><li>增加 LegacyCommpage（章节2.4.6）</li><li>增加 SystemMemoryStatus （章节2.7.2）</li><li>增加 ProcessorType（章节2.7.2）</li></ul></details><hr><h2 id="0-0-BIOS设置"><a href="#0-0-BIOS设置" class="headerlink" title="0.0 BIOS设置"></a>0.0 BIOS设置</h2><p>直接抄袭 @BAT 了</p><ul><li><strong>禁用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">Fast Boot</td><td align="center">快速启动</td></tr><tr><td align="center">CFG Lock (MSR 0xE2 write protection)</td><td align="center">CFG 锁 (MSR 0xE2 写入保护)</td></tr><tr><td align="center">VT-d</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-d</a></td></tr><tr><td align="center">CSM</td><td align="center">兼容性支持模块</td></tr><tr><td align="center">Intel SGX</td><td align="center">Intel SGX</td></tr></tbody></table><hr><ul><li><strong>启用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">VT-x</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-x</a></td></tr><tr><td align="center">Above 4G decoding</td><td align="center">大于 4G 地址空间解码</td></tr><tr><td align="center">Hyper Threading</td><td align="center">处理器超线程</td></tr><tr><td align="center">Execute Disable Bit</td><td align="center">执行禁止位</td></tr><tr><td align="center">EHCI/XHCI Hand-off</td><td align="center">接手 EHCI/XHCI 控制</td></tr><tr><td align="center">OS type: Windows 8.1/10</td><td align="center">操作系统类型: Windows 8.1/10</td></tr><tr><td align="center">Legacy RTC Device</td><td align="center">传统 RTC 设备</td></tr></tbody></table><blockquote><p>将操作系统类型设置为 <code>Windows 8.1/10</code> 是因为部分主板在 <code>Other</code> 模式下会将系统认作是 Windows 7 从而禁用 UEFI 的某些功能并开启 CSM, 200 系及以后的主板理论上不存在这个问题</p></blockquote><hr><h2 id="1-0-整理OPENCORE目录"><a href="#1-0-整理OPENCORE目录" class="headerlink" title="1.0 整理OPENCORE目录"></a>1.0 整理OPENCORE目录</h2><p>打开下载好的最新版 OC，把 Doc 文件夹下面的 <code>Sample.plist</code> 改名为 <code>config.plist</code>，并把此文件移动到 EFI 目录下面。<br>打开 <code>EFI--Kexts</code>，我们把常用的一些 kexts 先放进去，一般情况下你需要放如下 Kexts:</p><ul><li><p><a href="https://github.com/acidanthera/Lilu/releases">Lilu.kext</a>  Acidanthera驱动全家桶的SDK</p></li><li><p><a href="https://github.com/acidanthera/AppleALC/releases">Applealc.kext</a>   声卡驱动</p></li><li><p><a href="https://github.com/acidanthera/virtualsmc/releases">VirtualSMC.kext</a>    传感器驱动依赖</p></li><li><p>SMCProcessor.kext   CPU核传感器</p></li><li><p>SMCSuperIO.kext    IO传感器         </p></li><li><p><a href="https://github.com/acidanthera/whatevergreen/releases">WhateverGreen.kext</a> 显卡驱动</p></li><li><p><a href="https://github.com/acidanthera/IntelMausi/releases">IntelMausi.kext</a>  Intel类千兆网卡驱动</p></li><li><p><a href="https://github.com/Sniki/OS-X-USB-Inject-All/releases">Usbinjectall.kext</a>  USB驱动 （你也可以定制自己的USB补丁）               </p></li></ul><blockquote><p>一些机型用了 <code>1820A,1560,1830</code> 等网卡，需要自己放对应驱动；有线螃蟹卡也自己放一下驱动；笔记本类需要更多传感器的，请自行补齐 <code>VirtualSMC</code> 的那些传感器补丁</p></blockquote><hr><p>打开<code>EFI--Drives</code>,里面的驱动介绍如下：</p><ul><li><p>AudioDxe.efi           开机UEFI界面若需要声音效果需要加载。</p></li><li><p>CrScreenshotDxe.efi    开机UEFI的截图工具。</p></li><li><p>HiiDatabase.efi        用于给 Ivy Bridge (3 代酷睿) 或更老代主板上支持 UEFI 字体渲染, UEFI Shell 中文字渲染异常时使用, 新主板不需要。</p></li><li><p>NvmExpressDxe.efi      用于在 Haswell (4 代酷睿) 或更老的主板上支持 NVMe 硬盘, 新主板不需要。</p></li><li><p>OpenCanopy.efi         加载第三方开机主题。</p></li><li><p>OpenRuntime.efi        内存运用等必要的插件，必须加载。 </p></li><li><p>OpenUsbKbDxe.efi       给使用模拟 UEFI 的老主板在 OpenCore 界面正常输入用的, 请勿在 Ivy Bridge (3 代酷睿)及以上的主板上使用。</p></li><li><p>Ps2KeyboardDxe.efi     PS2键盘所需插件。</p></li><li><p>Ps2MouseDxe.efi        PS2鼠标所需插件。</p></li><li><p>UsbMouseDxe.efi        当MacOS被安装在虚拟机上所需要的鼠标插件。</p></li><li><p>XhciDxe.efi            用于在 Sandy Bridge（2代）及之前或更老的主板上加载XHCI控制器。</p></li><li><p><a href="/tools/HfsPlus.efi.zip">HfsPlus.efi</a>            用于HFS格式文件系统，这是必须加载的。</p></li></ul><hr><h2 id="2-0-Config-plist-修改"><a href="#2-0-Config-plist-修改" class="headerlink" title="2.0 Config.plist 修改"></a>2.0 Config.plist 修改</h2><p>这章会把 config 的项目分开来，内容繁琐，为了让小白明白各个选项的用途。当然有能力的人可以直接看我最前面的几个链接来配置 <code>config.plist</code>。我这里强制要求你使用 <code>Propertree</code> 来编辑 <code>Config.plist</code>，其他的任何软件我都不建议使用。</p><hr><h3 id="2-1-Config–ACPI"><a href="#2-1-Config–ACPI" class="headerlink" title="2.1 Config–ACPI"></a>2.1 Config–ACPI</h3><p>ACPI包括了四个部分：<code>Add</code>, <code>Block</code>, <code>Patch</code>, <code>Quirks</code>。这里我们先把root下面的几条 <code>#WARNING</code> 删除，这几条没有实际意义。</p><hr><h3 id="2-1-1-Config–ACPI–Add"><a href="#2-1-1-Config–ACPI–Add" class="headerlink" title="2.1.1 Config–ACPI–Add"></a>2.1.1 Config–ACPI–Add</h3><p>这部分主要填写我们使用的 SSDT 以及 DSDT 文件，如果没有请把 0-8 的 ssdt 全部删除。如果你有修改的 SSDT 或者 DSDT 文件，请先将文件放入 <code>EFI/OC/ACPI</code> 下。</p><p>因为我使用雷电卡，我需要添加两条关于雷电卡的 ssdt 文件：</p><pre><code class="xml">Item 0Comment    String       Thunderbolt3-DTGP //填一个你自己能辨别的名字，方便知道是啥Enable     Boolean      YES                //表示加载此SSDT，反之NO则为不加载Path       String       SSDT-DTGP.aml    //为你ssdt放在EFI/OC/ACPI下的文件名，必须一致Item 1Comment    String       Thunderbolt3Enable     Boolean      YESPath       String       SSDT-TB3.aml</code></pre><hr><h3 id="2-1-2-Config–ACPI–Delete"><a href="#2-1-2-Config–ACPI–Delete" class="headerlink" title="2.1.2 Config–ACPI–Delete"></a>2.1.2 Config–ACPI–Delete</h3><p>这个目录下是禁用一些 SSDT/DSDT，没什么用，我把下面的 <code>item</code> 全都删了。</p><hr><h3 id="2-1-3-Config–ACPI–Patch"><a href="#2-1-3-Config–ACPI–Patch" class="headerlink" title="2.1.3 Config–ACPI–Patch "></a>2.1.3 Config–ACPI–Patch <a id="2.1.3"></a></h3><p>这里我们需要填写一下热补丁。</p><ul><li>10.15及以上系统，<a href="https://blog.daliansky.net/Common-problems-and-solutions-in-macOS-Catalina-10.15-installation.html">一些资料</a>指出我们需要把EC控制器(EC0)改名为EC来确保能进入10.15系统</li></ul><pre><code class="xml">Comment:            EC0 to ECCount:                0Enabled:            YESFind:                &lt;4543305F&gt;Limit:                0Mask:                &lt;&gt;OemTable:            &lt;&gt;Replace:            &lt;45435F5F&gt;ReplaceMask:        &lt;&gt;Skip:                0TableLength:        0TableSignature:        &lt;&gt;</code></pre><blockquote><p>一些主板的EC控制器名字可能会叫 H_EC 等，请自行提取 DSDT 并搜索  <code>PNP0C09</code>，来获取 EC 控制器的名字，这些内容会在第三章中写出。</p></blockquote><hr><ul><li>华擎、华硕、微星主板可能会遇到采用新的 <code>AWAC</code> 时钟而无法进入系统，这同样需要添加  <code>hotpatch</code> 补丁来解决：</li></ul><pre><code class="xml">Comment:            RTC fixCount:                0Enabled:            YESFind:                &lt;A00A9353 54415301&gt;Limit:                0Mask:                &lt;&gt;OemTable:            &lt;&gt;Replace:            &lt;A00A910A FF0BFFFF&gt;ReplaceMask:        &lt;&gt;Skip:                0TableLength:        0TableSignature:        &lt;&gt;</code></pre><hr><h3 id="2-1-4-Config–ACPI–Quirks"><a href="#2-1-4-Config–ACPI–Quirks" class="headerlink" title="2.1.4 Config–ACPI–Quirks"></a>2.1.4 Config–ACPI–Quirks</h3><p>此目录下有五项，选择与解释如下：</p><ul><li><strong>FadtEnableReset:</strong> <code>NO</code><ul><li>旧的主板需要对 FADT 进行标记来激活电脑的开机和关机功能，这里我们不许要启动它</li></ul></li><li><strong>NormalizeHeaders:</strong> <code>NO</code><ul><li>清理 ACPI 头，一些主板的 ACPI 表需要打开这个修复 10.13 系统的启动。</li></ul></li><li><strong>RebaseRegions:</strong> <code>YES</code><ul><li>尝试试探性地重新定位 ACPI 内存区域, <strong>使用自定义 DSDT 则必须开启</strong></li></ul></li><li><strong>ResetHwSig:</strong> <code>NO</code><ul><li>存在重新启动后因无法维持硬件签名而导致从休眠中唤醒的问题的硬件需要开启</li></ul></li><li><strong>ResetLogoStatus:</strong> <code>NO</code><ul><li>无法在有 <code>BGRT</code> 表的系统上显示 OEM Windows 标志的硬件需要开启</li></ul></li></ul><hr><h2 id="2-2-Config–Booter"><a href="#2-2-Config–Booter" class="headerlink" title="2.2 Config–Booter"></a>2.2 Config–Booter</h2><p>内存相关选项设置。</p><hr><h3 id="2-2-1-Config–Booter–MmioWhitelist"><a href="#2-2-1-Config–Booter–MmioWhitelist" class="headerlink" title="2.2.1 Config–Booter–MmioWhitelist"></a>2.2.1 Config–Booter–MmioWhitelist</h3><ul><li><p>默认的第一项是为 Haswell 芯片提供的内存寻址修复，如果此类芯片碰到内存相关问题，请开启它(<code>enable</code>选择<code>yes</code>)。</p></li><li><p>默认第二项是开机卡 <code>PCI Configuration</code> 这里。ACPI、PCI device 同时释放到内存时发生 <code>0x1000</code> 内存地址被占用而卡在 <code>PCI Configration</code>，如果碰到此类问题，请开启它。</p></li></ul><hr><h3 id="2-2-2-Config–Booter–Patch"><a href="#2-2-2-Config–Booter–Patch" class="headerlink" title="2.2.2 Config–Booter–Patch"></a>2.2.2 Config–Booter–Patch</h3><ul><li>该功能可以对Bootx64.efi进行修改。</li></ul><hr><h3 id="2-2-3-Config–Booter–Quirks"><a href="#2-2-3-Config–Booter–Quirks" class="headerlink" title="2.2.3 Config–Booter–Quirks"></a>2.2.3 Config–Booter–Quirks</h3><p>此项与 <code>OpenRuntime.efi</code> 有关。在 <code>aptiomemoryfix</code> 停更后，此补丁已经更名为 <code>Openruntime</code>, 并将一些功能与 OC 合并、模块化。对于无法原生 <code>nvram</code> 的主板来说，这里的选项需要格外注意。当然我也会把像 300/400 系列、x299、C246、C422 这样支持原生 <code>nvram</code> 的选择方法一并写进去。</p><ul><li><p><strong>AllowRelocationBlock:</strong> <code>NO</code></p><ul><li>此功能用于10.7及更早的MacOS系统。当系统需要更低位置的内存时，该功能可以重新定位那些已经被非runtimeserivce所占据的内存。。</li></ul></li><li><p><strong>AvoidRuntimeDefrag:</strong> <code>YES</code></p><ul><li>大部分UEFI都会写入时间、电源管理等信息，这个所有黑苹果主板都应该选择 <code>YES</code>。</li></ul></li><li><p><strong>DevirtualiseMmio:</strong> <code>YES</code></p><ul><li>内存注入方式包括 <code>KASLR</code> 方式(分布式注射到各个内存地址中）以及连续性方式。在使用 <code>KASLR</code> 时，PCIe 加载到内存，可能会占据所有 <code>avaliable</code> 值而影响 OC 的内核以及内核缓存无法注入，导致启动失败。此项目前建议选择YES，并且在下一项 <code>ProtectUefiServices</code> 中也选择 <code>YES</code>。</li></ul></li></ul><blockquote><p><code>KASLR</code> 是更加高效的内存注入方式，但不代表每台机器都能使用这种方案，这里我提供两种关于内存的设置：</p></blockquote><blockquote><p>1：<code>DevirtualiseMmio</code>选择<code>yes</code>, <code>ProtectUefiServices</code>选择<code>yes</code>, 并删除 <a href="#2.6.1">2.6.1</a> 中 <code>boot-args</code> 里面的<code>slide=1</code>,以及删除 Drivers 文件夹下的 <code>Memoryallocations.efi</code>。即开启 <code>KASLR</code> 内存注入方式。  </p></blockquote><blockquote><p>2：<code>DevirtualiseMmio</code>选择<code>yes</code>, <code>ProtectUefiServices</code>选择<code>no</code>, 保留 <a href="#2.6.1">2.6.1</a> 中 <code>boot-args</code> 里面的<code>slide=1</code>,以及保留 Drivers 文件夹下的 <code>Memoryallocations.efi</code>。即开启连续性内存注入方式。</p></blockquote><ul><li><p><strong>DisableSingleUser:</strong> <code>NO</code></p><ul><li>这里关乎主机是否能开启单用户模式。什么是单用户模式，请看<a href="https://support.apple.com/zh-cn/HT201573">此文章</a>。</li></ul></li><li><p><strong>DisableVariableWrite:</strong> <code>NO</code></p><ul><li>主板支持原生 <code>nvram</code>，请选择 <code>NO</code>。非原生NVRAM主板需要模拟 <code>nvram.plist</code> 进而写入 <code>variable</code> 值，因此我们要禁止此项来防止其他程序对 <code>nvram</code> 进行写入，我们这里选 <code>YES</code></li></ul></li><li><p><strong>DiscardHibernateMap:</strong> <code>NO</code></p><ul><li>电脑从休眠(hibernation)中唤醒时,硬盘里的资料会恢复到内存中去，但这个时候 OC 的内核以及内核缓存等也会写入，这样可能导致冲突，这个选项是帮助我们解决这个问题的。而目前来看，除了原生 <code>NVRAM</code> 都无法进行休眠（注意睡眠 <code>sleep</code> 和休眠 <code>hibernation</code> 是两个概念），台式机的话就更不需要休眠功能了，这里我选择 <code>NO</code>。这里我们也不讨论如何休眠。</li></ul></li><li><p><strong>EnableSafeModeSlide:</strong> <code>YES</code></p><ul><li>安全模式下是否启用连续性的内存注入方式。我就选择 <code>YES</code>，与正常情况下保持一致。</li></ul></li><li><p><strong>EnableWriteUnprotector:</strong> <code>YES</code></p><ul><li>保证 <code>nvram</code> 能正常写入而不受到 <code>CR0</code> 寄存器的写入保护影响。</li></ul></li><li><p><strong>ForceBooterSignature:</strong> <code>NO</code></p><ul><li>休眠（hibernation）中唤醒使用OpenCore的SHA-1加密验证，我们不适用休眠功能就关闭。休眠不是睡眠！</li></ul></li><li><p><strong>ForceExitBootServices:</strong> <code>NO</code></p><ul><li>这个选项是让那些非常老旧的主板也能使用内存寻址，正常情况下选 <code>NO</code>。</li></ul></li><li><p><strong>ProtectMemoryRegions:</strong> <code>NO</code></p><ul><li>官方对此项目的解释与 <code>AvoidRuntimeDefrag</code> 类似，除非你明白这是什么，不然选择 <code>NO</code>，其实我也不明白。</li></ul></li><li><p><strong>ProtectSecureBoot:</strong> <code>NO</code></p><ul><li>保护安全启动，除非你开启安全启动，不然我们选择 <code>NO</code>。</li></ul></li><li><p><strong>ProtectUefiServices:</strong> <code>NO</code></p><ul><li>解决Z390系列主板卡开机卡++++的问题，这个功能从字面意思是与我提供的 <code>memoryallocation.efi</code>功能类似。</li></ul></li><li><p><strong>ProvideCustomSlide:</strong> <code>YES</code></p><ul><li>此选项执行固件的内存映射分析并检查所有的 <code>slide</code> 值(1 - 255)是否可用。由于 <code>boot.efi</code> 生成的这个值是利用 <code>rdrand</code> 指令随机生成的或者伪随机指令 <code>rdtsc</code> 随机生成的，因此当其选择了 一个冲突的 <code>slide</code> 值时有可能启动失败。由于这种潜在的冲突存在，此选项强制 macOS 在可用的值中使用一个伪随机值，这也确保了 <code>slide= </code>启动参数不会因为安全原因传递给操作系统。<br>是否需要此选项由信息 OCABC (Only N/256 slide values are usable!) 是否存在于调试日 志中决定。如果存在此信息，则需要启用此 <code>Quriks</code> 选项。我选择 <code>YES</code>。如果你对 <code>KASLR</code>有一定的认知并会运用，请注意这个值。内容从 @套陆 摘抄。</li></ul></li><li><p><strong>ProvideMaxSlide:</strong> <code>0</code></p><ul><li>如果你没有启用 <code>KASLR</code> 的话，请填写 <code>1-255</code> 之间的数字以存放休眠文件写进内存所需要的内存高度，反之则填写 <code>0</code>。</li></ul></li><li><p><strong>RebuildAppleMemoryMap:</strong> <code>NO</code></p><ul><li>重新生成内存地图来匹配苹果系统。苹果的内核有很多缺陷，比如单张的内存地图不能超过 4K，一旦超过就可能无法开机；又比如一些硬件会直接把读写权限写进内存里，而苹果却不能给与写入权限。如果你遇到此类的问题，请尝试开启它。注意此项目与 <code>EnableWriteUnprotector</code> 存在冲突关系，确保开启这个的时候，另一个是关闭的。另外，此项又需要与 <code>SyncRuntimePermissions</code> 项搭配使用。一般情况下请选择 <code>NO</code>。</li></ul></li><li><p><strong>SetupVirtualMap:</strong> <code>YES</code></p><ul><li>是否建立虚拟内存并对物理内存进行映射。我们在开机时，OC 的程序需要一块连续性的内存进行存放内核等东西，而实际的物理内存一般都是分散的。因此，我们通过虚拟内存建立连续性内存供OC使用，并映射到分散的物理内存中。这里我们选择 <code>YES</code>。</li></ul></li><li><p><strong>SignalAppleOS:</strong> <code>NO</code></p><ul><li>通知同一台电脑上的设备 Mac 上的硬件选择，此项是给白苹果用的。</li></ul></li></ul><ul><li><strong>SyncRuntimePermissions:</strong> <code>YES</code><ul><li>修正硬件在注入内存时无法注入权限的问题。一般此类问题存在2018年后的主板。如果你因为此选项无法进入 windows，请开启它。</li></ul></li></ul><hr><h2 id="2-3-Config–DeviceProperties"><a href="#2-3-Config–DeviceProperties" class="headerlink" title="2.3 Config–DeviceProperties"></a>2.3 Config–DeviceProperties</h2><p>此项是用来注入你的设备的，主要是显卡和声卡两部分。同样你也可以定制一些设备到你的 <code>关于本机--系统报告--PCI</code> 列表中，尽管没有多大的意义。</p><h3 id="2-3-1-声卡"><a href="#2-3-1-声卡" class="headerlink" title="2.3.1 声卡 "></a>2.3.1 声卡 <a id=2.3.1></a></h3><p>这里首先我们需要确认自己的声卡驱动已经被加载，终端下输入：</p><pre><code class="bash">kextstat | grep -E &quot;AppleHDA|AppleALC|Lilu&quot;</code></pre><p>我们会得到被加载的驱动，请确保 <code>as.vit9696.Lilu</code>；<code>as.vit9696.AppleALC</code>；<code>com.apple.driver.AppleHDAController</code>；<code>com.apple.driver.AppleHDA</code> 已经被加载。</p><p>找自己声卡的地址，准备好在文章开头要求下载的 <code>gfxutil</code>，将 <code>gfxutil</code> 程序放在桌面，输入:</p><pre><code class="bash">~/desktop/gfxutil -f HDEF //一般来说我们在使用 Applealc 后，板载声卡的部件名都叫 HDEF</code></pre><p>我们输入后会得到声卡的PCI路径，比如我输出的就是：</p><pre><code class="bash">00:1f.3 8086:a2f0 /PC00@0/HDEF@1F,3 = PciRoot(0x0)/Pci(0x1F,0x3)</code></pre><p>这里我们找到的声卡 PCI 路径为 <code>PciRoot(0x0)/Pci(0x1f,0x3)</code>。我们把预先填写在那里的 <code>PciRoot(0x0)/Pci(0x1b,0x0)</code> 项替换成我们真正的声卡路径。</p><p>后面一段我们看到预先填写的声卡ID为 <code>&lt;01000000&gt;</code>，这里我们需要把它换成合适自己声卡的 ID，输入以下命令得到自己声卡的 CodecID。</p><pre><code class="bash">ioreg -l|grep IOHDACodecVendorID</code></pre><p>点击<a href="https://github.com/headkaze/Hackintool/blob/master/Resources/Audio/Codecs.plist">此页面</a>搜索刚得到的CodecID就可查询到自己声卡的型号名称，以及可用的 <code>LayoutID</code>。</p><p>比如我的 CodecID 为 <code>283906408</code>，声卡型号 <code>ALCS1220A</code>，对应 1, 2, 3, 5, 7, 11, 13, 15, 16, 27, 28, 29, 34 的 <code>layout ID</code>。我们需要一个个测试过去，选定自己能用的。这里我们选择 7 这个 ID 进行测试，将 7 转化成 16 进制格式为 07，后面为了满足格式要求添加 6 个 0，则为 <code>07000000</code>，将这个值替换刚才预先填的<code> 01000000</code> 中；如果我们测试 ID 为 27，27 的 16 进制为 1b，补上 6 个 0 则为 <code>1b000000</code>。</p><pre><code class="xml">PciRoot(0x0)/Pci(0x1f,0x3)        device-id       data      &lt;70a10000&gt; //一般情况下这段是不需要填写的，除非你的声卡需要仿冒        layout-id       data      &lt;0b000000&gt; //这个Layout id我瞎写的，你按实际情况写</code></pre><p>如果你测试的ID都无效，请确保你的操作过程正确、并测试用万能声卡(VoodooHDA)补丁来替换 AppleALC 这个补丁。如果都不行，你可能需要自行<a href="https://blog.daliansky.net/Use-AppleALC-sound-card-to-drive-the-correct-posture-of-AppleHDA.html">编译声卡补丁</a>。</p><hr><h3 id="2-3-2-核心显卡"><a href="#2-3-2-核心显卡" class="headerlink" title="2.3.2 核心显卡"></a>2.3.2 核心显卡</h3><p>打开 <code>PciRoot(0x0)/Pci(0x2,0x0)</code> 这项，此项为驱动核心显卡。驱动核心显卡我们要分情况讨论:</p><ul><li>1.只有核心显卡的 DP 显示器用户 (HDMI设置请参照黑果小兵的博客）；</li><li> 2.没有核心显卡的用户；</li><li> 3.有核心显卡并用独显做主力的用户。</li></ul><blockquote><p>注意，这里我们只讨论 8代和9代CPU 的机器，其他CPU机型的请在论坛或者<a href="https://blog.daliansky.net/Intel-core-display-platformID-finishing.html">黑果小兵博客</a>中搜索相关代码。</p></blockquote><hr><h4 id="2-3-2-1-只有核心显卡的DP显示器用户"><a href="#2-3-2-1-只有核心显卡的DP显示器用户" class="headerlink" title="2.3.2.1 只有核心显卡的DP显示器用户"></a>2.3.2.1 只有核心显卡的DP显示器用户</h4><p>8代和9代的核显ID为:<code>3E9b0007</code>，device ID为 <code>3e9b0000</code>，但是我们需要符合苹果的倒叙格式填入：</p><pre><code class="xml">AAPL,ig-platform-id        data        &lt;07009b3e&gt;device-id                  data        &lt;9b3e0000&gt;framebuffer-unifiedmem     data        &lt;00000080&gt;      //核显显存相关</code></pre><hr><h4 id="2-3-2-2-没核心显卡的用户"><a href="#2-3-2-2-没核心显卡的用户" class="headerlink" title="2.3.2.2 没核心显卡的用户"></a>2.3.2.2 没核心显卡的用户</h4><p>带f的cpu (e.g. 9100f 9900kf), Xeon 等不带核心显卡的用户不需要管这项，直接把 <code>AAPL,ig-platform-id</code>选项卡删了。</p><hr><h4 id="2-3-2-3-有核心显卡并用独显做主力的用户"><a href="#2-3-2-3-有核心显卡并用独显做主力的用户" class="headerlink" title="2.3.2.3 有核心显卡并用独显做主力的用户"></a>2.3.2.3 有核心显卡并用独显做主力的用户</h4><p>这种情况我们一般把核心显卡作为加速用，而显示则用独立显卡。这样，我们填一个作为加速用的核显ID即可了，8代9代除外的 cpu 请搜索黑果小兵的博客：</p><pre><code class="xml">AAPL,ig-platform-id        data        &lt;0300983e&gt;</code></pre><blockquote><p>注意，10代cpu虽然使用同样的UHD 630，但具体加速代码在iMac 20.1机型下不同，请自行查询</p></blockquote><hr><h3 id="2-3-3-Delete"><a href="#2-3-3-Delete" class="headerlink" title="2.3.3 Delete"></a>2.3.3 Delete</h3><p>这里是禁用一些设备的，我们按默认就行了，不需要任何修改。</p><hr><h2 id="2-4-Config–Kernel"><a href="#2-4-Config–Kernel" class="headerlink" title="2.4 Config–Kernel"></a>2.4 Config–Kernel</h2><p>这里是内核相关选项。</p><hr><h3 id="2-4-1-Config–Kernel–Add"><a href="#2-4-1-Config–Kernel–Add" class="headerlink" title="2.4.1 Config–Kernel–Add"></a>2.4.1 Config–Kernel–Add</h3><p>这里我们需要填写kexts的相关资料。值得注意的是 OC 的 kexts 填写必须注意顺序，比如 applealc 的依赖是 <code>lilu.kext</code>，那么 <code>lilu.kext</code> 必须填在第一个，<code>SMCProcessor.kext</code> 依赖于 <code>Virtualsmc.kext</code>。那 <code>Virtualsmc.kext</code> 必须放在 <code>SMCProcessor.kext</code> 之前。</p><p>这里默认情况下很多我们需要的补丁已经被加载里面了，但是 <code>enabled</code> 那块我们要手动改成 <code>yes</code> 去开启它，把一些不用的删了：</p><pre><code class="xml">Item 0      BundlePath       String         Lilu.kext            //kext的名字      Comment          String                              //你自己填一个注释，可以不填      Enabled          Boolean        YES                  //启动此补丁，反之则为关闭      ExecutablePath   String         Contents/MacOS/Lilu  //通过右键kext显示包内容查找lilu运行文件的真正路径      MaxKernel        String                              //此补丁支持的最大系统版本，填19为10.15，18位10.14；我们一般情况下留空      MinKernel        String                              //此补丁支持的最小系统版本      PlistPath        String         Contents/Info.plist  //kext的plist位置，可以右键kext显示包内容查找正确路径       ............ ...........       ............ ...........Item 7      BundlePath       String         USBPorts.kext      Comment          String             Enabled          Boolean        YES      ExecutablePath   String                              //一些没有执行文件的kext不需要填写      MaxKernel        String      MinKernel        String      PlistPath        String         Contents/Info.plist       ............ ...........       ............ ...........</code></pre><hr><h3 id="2-4-2-Config–Kernel–Block"><a href="#2-4-2-Config–Kernel–Block" class="headerlink" title="2.4.2 Config–Kernel–Block"></a>2.4.2 Config–Kernel–Block</h3><p>禁用一些 kexts，这里好像没啥用，不用理会。</p><hr><h3 id="2-4-3-Config–Kernel–Emulate"><a href="#2-4-3-Config–Kernel–Emulate" class="headerlink" title="2.4.3 Config–Kernel–Emulate"></a>2.4.3 Config–Kernel–Emulate</h3><p>此选项帮助 Ivy Bridge 和一些不受支持的CPU加载电源管理的，我们这里不做此方面讨论。所有选项按默认即可。</p><hr><h3 id="2-4-4-Config–Kernel–Force"><a href="#2-4-4-Config–Kernel–Force" class="headerlink" title="2.4.4 Config–Kernel–Force"></a>2.4.4 Config–Kernel–Force</h3><p>特殊情况下我们需要强制加载某一些  <code>kext</code> 来达到某种目的，一般我们不理会此项。</p><hr><h3 id="2-4-5-Config–Kernel–Patch"><a href="#2-4-5-Config–Kernel–Patch" class="headerlink" title="2.4.5 Config–Kernel–Patch"></a>2.4.5 Config–Kernel–Patch</h3><p>这里是为内核打补丁用的，我会在进阶教程中详细写一下这一块。尤其是 rtc 相关的内容，我都会写进第三章的进阶教程。</p><hr><h3 id="2-4-6-Config–Kernel–Quirks"><a href="#2-4-6-Config–Kernel–Quirks" class="headerlink" title="2.4.6 Config–Kernel–Quirks"></a>2.4.6 Config–Kernel–Quirks</h3><p>这里是内核相关的快捷选项，比较重要。</p><ul><li><p><strong>AppleCpuPmCfgLock:</strong> <code>YES</code></p><ul><li>四代之前的 CPU，如果未解锁 CFG(即MSR0xE2) 请选择 <code>YES</code>。</li></ul></li><li><p><strong>AppleXcpmCfgLock:</strong> <code>YES</code></p><ul><li>四代之后的CPU若未解锁 CFG(即MSR0xE2) 请选择 <code>YES</code>。</li></ul></li><li><p><strong>AppleXcpmExtraMsrs:</strong> <code>NO</code></p><ul><li>主要在没有原生电源管理的CPU上启用，一般是 <code>Haswell-E</code>, <code>Broadwell-E</code>, <code>Skylake-X</code> 这三种 CPU 需要填写 <code>YES</code>。除此之外的 CPU 选择 <code>NO</code>。</li></ul></li><li><p><strong>AppleXcpmForceBoost:</strong> <code>NO</code></p><ul><li>开启时将电脑的 cpu 频率锁定为最高频率。</li></ul></li><li><p><strong>CustomSMBIOSGuid:</strong> <code>NO</code></p><ul><li>戴尔笔记本专用项。</li></ul></li><li><p><strong>DisableIoMapper</strong> <code>NO</code></p><ul><li>禁用 vt-d。</li></ul></li><li><p><strong>DisableLinkeditJettison</strong> <code>YES</code></p><ul><li>提升 <code>lilu</code> 等插件在 MACOS 11 系统的表现，用来替代 <code>keepsyms=1</code>。</li></ul></li><li><p><strong>DisableRtcChecksum</strong> <code>NO</code></p><ul><li>越过两条 rtc 检查 (0x58及0x59)。RTC 我们会更多地使用 <code>RTCMemoryFixup.kext</code> 来防止它。</li></ul></li><li><p><strong>ExtendBTFeatureFlags</strong> <code>NO</code></p><ul><li>代替 <code>BT4LEContinuityFixup.kext</code> 来实现 <code>continuity</code>。</li></ul></li><li><p><strong>ExternalDiskIcons</strong> <code>NO</code></p><ul><li>修复苹果系统把内部硬盘识别为外置硬盘时（黄色图标的硬盘）开启。</li></ul></li><li><p><strong>ForceSecureBootScheme</strong> <code>NO</code></p><ul><li>只在MacOS安装在虚拟机并开启<code>SecurebootModel</code>时考虑开启。</li></ul></li><li><p><strong>IncreasePciBarSize</strong> <code>NO</code></p><ul><li>解决卡 PCI configuration，一般卡 pci configuration 都是因为自己错误的设置和硬件问题。</li></ul></li><li><p><strong>LapicKernelPanic</strong> <code>NO</code></p><ul><li>适用于HP笔记本的内核奔溃选项。</li></ul></li><li><p><strong>LegacyCommpage</strong> <code>NO</code></p><ul><li>老平台主板中使用 ssse3 需要开启来使用 macOS 10.4 - 10.6。</li></ul></li><li><p><strong>PanicNoKextDump</strong> <code>YES</code></p><ul><li>防止 <code>kext</code> 出错打报告而让我们看不到真正的 <code>panic</code> 原因，初始排错时最好打开。</li></ul></li><li><p><strong>PowerTimeoutKernelPanic</strong> <code>YES</code></p><ul><li>一些设备自身的电源管理无法让系统进入睡眠而超时，导致内核奔溃，如果有这个问题请选择 <code>YES</code>。</li></ul></li><li><p><strong>ProvideCurrentCpuInfo</strong> <code>NO</code></p><ul><li>给hyper-V虚拟化MacOS时提供cpu的信息，保证全核同步。</li><li></li></ul></li><li><p><strong>SetApfsTrimTimeout</strong> <code>-1</code></p><ul><li><p>APFS文件系统根据空间是否<code>被使用</code>或者是<code>空的</code>来设计的，这种设计跟其他文件系统是不同的，一般被设计成<code>被使用</code>，<code>空的</code>或者<code>未映射</code>三种情况。这种不同可能带来在启动时系统需要更多的时间来做trim，甚至导致无法进入系统。这个选项是为了设计一个时间节点来终止trim进入系统。一般来说填入<code>-1</code>是不阻止这个trim过程，但如果你有这个问题，你可以设置一个时间，单位为微秒。</p></li><li><p>因最近的系统更新，当trim过程超过10秒，系统开机时苹果会自动跳过trim，这样会导致一些品牌的ssd无法正常工作，出现系统崩溃，冻屏，死机等问题。解决的办法有两种，一种是将此选项设置一个超长的时间来保证trim结束，(e.g.4294967295)，带来的后果是开机非常慢，第二种方法是设置一个非常短的时间直接跳过trim过程（e.g.999）。关闭trim会带来大量的问题，所有的闪存不具备覆写的功能（除了傲腾），需要通过trim来删除日志中需要删除的空间，不然的话，硬盘的速度会直线下降。我们应该避免使用有这类问题的SSD。</p></li><li><p>目前检查到的兼容性不够好的硬盘包括并不限于：</p><ul><li>Samsung 950 Pro  </li><li>Samsung 960 Evo/Pro</li><li>Samsung 970 Evo/Pro</li><li>Samsung SM961</li><li>GIGABYTE 512 GB M.2 PCIe SS</li><li>ADATA Swordfish 2 TB M.2-2280</li><li>SK Hynix HFS001TD9TNG-L5B0B</li><li>SK Hynix P31</li><li>Samsung PM981 </li><li>Micron 2200V MTFDHBA512TCK</li><li>Asgard AN3+ (STAR1000P)</li><li>Intel 760p （一些批次）</li><li>Optane</li><li>省略无数其他，列表中的有一些也许没问题，并不是一网打死。 </li></ul></li></ul></li></ul><ul><li><p><strong>ThirdPartyDrives</strong> <code>NO</code></p><ul><li>开启 SATA 类 SSD 的 <code>trim</code> 功能，我没有 SATA 类的 ssd，我选择 <code>NO</code>。自行根据情况选择。</li></ul></li><li><p><strong>XhciPortLimit</strong> <code>YES</code></p><ul><li>解除 15 个 USB 端口限制。11.3系统不要开启，并自行定义usb端口。</li></ul></li></ul><hr><h3 id="2-4-7-Config–Kernel–Scheme"><a href="#2-4-7-Config–Kernel–Scheme" class="headerlink" title="2.4.7 Config–Kernel–Scheme"></a>2.4.7 Config–Kernel–Scheme</h3><ul><li><strong>FuzzyMatch</strong> <code>NO</code><ul><li>此选项是给 10.6 以及更早的系统使用，我们不做探讨。</li></ul></li></ul><ul><li><p><strong>KernelArch</strong> <code>NO</code></p><ul><li>此选项是给 10.7 以及更早的系统使用，不做探讨，直接填写默认的 <code>x86_64</code>。</li></ul></li><li><p><strong>KernelCache</strong> <code>Auto</code></p><ul><li>选择更加合适的内核缓存方式以提升启动速度。</li></ul></li></ul><hr><h2 id="2-5-Config–Misc"><a href="#2-5-Config–Misc" class="headerlink" title="2.5 Config–Misc"></a>2.5 Config–Misc</h2><p>这里都是一些开机引导类的设置。</p><hr><h3 id="2-5-1-Config–Misc–BlessOverride"><a href="#2-5-1-Config–Misc–BlessOverride" class="headerlink" title="2.5.1 Config–Misc–BlessOverride"></a>2.5.1 Config–Misc–BlessOverride</h3><p>用于覆盖 Windows <code>bootmgfw.efi</code> 的位置以便识别 Windows 引导项, <code>OpenCore</code> 和 <code>Windows</code> 的引导文件在同一硬盘的同一个 ESP 分区下使用</p><pre><code class="XML">▼ Misc                  &lt;Dictionary&gt;|__ ▼ BlessOverride     &lt;Array&gt;    |__ Item 0          &lt;String&gt;          \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><hr><h3 id="2-5-2-Config–Misc–Boot"><a href="#2-5-2-Config–Misc–Boot" class="headerlink" title="2.5.2 Config–Misc–Boot"></a>2.5.2 Config–Misc–Boot</h3><ul><li><p><strong>ConsoleAttributes</strong> <code>0</code></p><ul><li>设置开机选择界面的颜色，默认直接填 0。使用方法为填入字体颜色和背景颜色的值的 16 进制之和。例如<font color=blue>蓝色字</font> <code>(0x01)</code> + <font color=red>红色背景</font> <code>(0x40)</code> = <code>0x41</code>。色彩选择如下：</li></ul></li><li><p>字体颜色</p><ul><li>0x00 — <font color=black>黑</font></li><li>0x01 — <font color=blue>蓝</font></li><li>0x02 — <font color=green>绿</font></li><li>0x03 — <font color=cyan>青</font></li><li>0x04 — <font color=red>红</font></li><li>0x05 — <font color=crimson>艳红</font></li><li>0x06 — <font color=brown>棕</font></li><li>0x07 —  <font color=gainsboro>淡灰</font></li><li>0x08 — <font color=dimgray>深灰</font></li><li>0x09 — <font color=lightskyblue>淡蓝</font></li><li>0x0A — <font color=lightgreen>淡绿</font></li><li>0x0B — <font color=lightcyan>淡青</font></li><li>0x0C — <font color=lightred>淡红</font></li><li>0x0D — <font color=lightcrimson>淡艳红</font></li><li>0x0E — <font color=yellow>黄</font></li><li>0x0F — <font color=white>白</font>（这里是白色）</li></ul></li><li><p>背景颜色</p><ul><li>0x00 — <font color=black>黑</font></li><li>0x10 — <font color=blue>蓝</font></li><li>0x20 — <font color=green>绿</font></li><li>0x30 — <font color=cyan>青</font></li><li>0x40 — <font color=red>红</font></li><li>0x50 — <font color=crimson>艳红</font></li><li>0x60 — <font color=brown>棕</font></li><li>0x70 — <font color=gainsboro>淡灰</font></li></ul></li><li><p><strong>HibernateMode</strong> <code>None</code></p><ul><li><p>检测休眠模式。与系统内的休眠模式 (hibernatemode 25) 配合, 引导进系统会还原休眠前的状态, 建议关闭</p></li><li><p><code>None</code>: 关闭休眠支持</p></li><li><p><code>Auto</code>: 自动检测 RTC 和 NVRAM 模式</p></li><li><p><code>RTC</code>: RTC 模式</p></li></ul></li><li><p><strong>HideAuxiliary</strong> <code>NO</code></p><ul><li>在tool下等具有Auxiliary并被开启的插件，补丁等是否需要被隐藏起来。</li></ul></li><li><p><strong>LauncherOption</strong> <code>Disabled</code></p><ul><li><code>Disabled</code>:对启动项不做任何事</li><li><code>Full</code>:把OC的启动项永远置顶在uefi启动顺序中，填入此项后，你必须同时打开<code>RequestBootVarRouting</code></li><li><code>Short</code>:主要给<code>Insyde</code>cpu来使用并创建OC启动项。</li></ul></li></ul><ul><li><p><strong>LauncherPath</strong> <code>Default</code></p><ul><li><code>Default</code>: 自动加载默认的OpenCore.efi</li><li><code>路径+xxx.efi</code>:给出指定路径来加载OC。比如我们把OpenCore.efi更名为qq.efi并放在\EFI\qq.efi，你就可以填写<code>\EFI\qq.efi</code></li></ul></li><li><p><strong>PickerAttributes</strong> <code>17</code></p><ul><li><p>当你使用OC主题时，你可以通过计算以下数值之和来配合使用OC主题，建议使用数字<code>17</code></p></li><li><p><code>0x0001</code>: 是否加载自制的图标。如果是tool类的图标应该放在Resource/Image/xx.icon（与tool同名）；如果是自定义路径的启动硬盘，应放在同样位置并被命名为<code>路径.icns</code>。</p></li><li><p><code>0x0002</code>: 在图标下显示渲染的文字指示。</p></li><li><p><code>0x0004</code>: 使用默认的图标。</p></li><li><p><code>0x0008</code>: 使用老式的图标。</p></li><li><p><code>0x0010</code>: 在主题界面中允许使用鼠标。</p></li></ul><blockquote><p>使用<code>17</code>这个值意味着是1+2+4+10</p></blockquote></li></ul><ul><li><p><strong>PickerAudioAssist</strong> <code>NO</code></p><ul><li>是否开启开机朗读文字功能，一般选择NO，如果你要开启，请同时阅读章节2.8.2和2.8.7的相关音频设置。</li></ul></li><li><p><strong>PickerMode</strong> <code>Builtin</code></p><ul><li><code>Builtin</code>: 不使用任何主题</li><li><code>External</code>: 调用第三方主题</li><li><code>Apple</code>: 给白果用的</li></ul></li><li><p><strong>PickerVariant</strong> <code>Auto</code></p><ul><li><code>Auto</code>: 自动选择，根据<code>DefaultBackgroundColour</code>来自动选择并具有时间控制的黑夜或白天的模式。</li><li><code>Default</code>: 使用Resource/Images/GoldenGate/ 这个主题</li><li><code>填路径</code>:使用自己的主题，主题文件夹该放在Resource/Images/下，比如Resource/Images/customised/xjn，则在这个选项中填customised/xjn</li></ul><blockquote><p><a href="https://github.com/acidanthera/OcBinaryData">官网推荐主题下载</a><br>请将下载好的Resources件放入ESP/EFI/OC下，同时，你需要将OpenCanopy.efi放入Drivers文件夹下并加载。</p></blockquote></li><li><p><strong>PollAppleHotKeys</strong> <code>YES</code></p><ul><li>是否开启一些热键功能，包括 <kbd>⌘</kbd>+<kbd>K</kbd>，<kbd>⌘</kbd>+<kbd>S</kbd></li></ul></li><li><p><strong>ShowPicker</strong> <code>YES</code></p><ul><li>是否显示开机启动盘选项。</li></ul></li><li><p><strong>TakeoffDelay</strong> <code>0</code></p><ul><li>开机热键延时，如果你按热键来不及按，你可以设置5000到10000之间的值让你有更多时间按热键（毫秒）。</li></ul></li><li><p><strong>Timeout</strong> <code>5</code></p><ul><li>倒计时进入指定硬盘，这里我们按需求填写，我填写5，代表5秒钟进入指定硬盘。</li></ul></li></ul><hr><h3 id="2-5-3-Config–Misc–Debug"><a href="#2-5-3-Config–Misc–Debug" class="headerlink" title="2.5.3 Config–Misc–Debug"></a>2.5.3 Config–Misc–Debug</h3><p>是否开启debug模式，这里我们暂时不需要，全部按默认设置。</p><hr><h3 id="2-5-4-Config–Misc–Entries"><a href="#2-5-4-Config–Misc–Entries" class="headerlink" title="2.5.4 Config–Misc–Entries"></a>2.5.4 Config–Misc–Entries</h3><p>这里是帮助我们添加一些你希望的引导路径，这个会在之后的进阶教程中讲，这里暂时略过不填写。</p><hr><h3 id="2-5-5-Config–Misc–Security"><a href="#2-5-5-Config–Misc–Security" class="headerlink" title="2.5.5 Config–Misc–Security"></a>2.5.5 Config–Misc–Security</h3><ul><li><p><strong>AllowNvramReset</strong> <code>YES</code></p><ul><li>是否在开机引导项中加入重置 <code>NVRAM</code> 功能的选项。</li></ul></li><li><p><strong>AllowSetDefault</strong> <code>YES</code></p><ul><li>选择 <code>yes</code> 后即可在开机选择系统页面中通过 <kbd>Ctrl</kbd>+<kbd>Enter</kbd> 键设置默认启动盘。</li></ul></li><li><p><strong>AllowToggleSip</strong> <code>NO</code></p><ul><li>在开机界面中增加一个关闭或开启sip的选项。</li><li></li></ul></li><li><p><strong>ApECID</strong> <code>0</code></p><ul><li>一般按默认的 0 填写，如果要开启安全启动的身份认证，请随便填写一串数字，比如手机号。</li></ul></li><li><p><strong>AuthRestart</strong> <code>NO</code></p><ul><li><code>Filevault</code> 相关项，选择 <code>NO</code>。</li></ul></li><li><p><strong>BlacklistAppleUpdate</strong> <code>YES</code></p><ul><li>如果使用MacOS 11，请开启它，因为在NVRAM中设置run-efi-updater并不能阻止苹果对固件的控制升级。</li></ul></li></ul><ul><li><p><strong>DmgLoading</strong> <code>Any</code></p><ul><li>如果你没有开启安全启动，请填写 <code>Any</code>；如果使用安全启动，请填写 <code>Signed</code>（注意大小写）。</li></ul></li><li><p><strong>EnablePassword</strong> <code>NO</code></p><ul><li>此选项正在开发。</li></ul></li><li><p><strong>ExposeSensitiveData</strong> <code>2</code></p><ul><li>模拟 <code>nvram</code>，填 3，如果你有原生 <code>nvram</code>，填写 2。</li></ul></li><li><p><strong>HaltLevel</strong> <code>2147483648</code></p><ul><li>按默认设置即可。</li></ul></li><li><p><strong>PasswordHash</strong> <code>留空</code></p><ul><li>按默认，如果开启了 <code>EnablePassword</code>，则填写密码的 <code>hash</code> 值。</li></ul></li><li><p><strong>PasswordSalt</strong> <code>留空</code></p><ul><li>按默认，如果开启了 <code>EnablePassword</code>，则填写密码的 <code>salt</code> 值。</li></ul></li><li><p><strong>ScanPolicy</strong> <code>0</code></p><ul><li>填0。我们也许会碰到开机的时候默认进入的系统永远是 WINDOWS，并无法更改，之后我们在进阶教程中讲述，如何让 MAC 盘排在第一个，让 WIN 排在后面。</li></ul></li><li><p><strong>SecureBootModel</strong> <code>Disabled</code></p><ul><li>是否开启安全启动模式，一般我们填写 <code>Disabled</code>（注意大小写）来关闭此功能。</li></ul></li><li><p><strong>Vault</strong> <code>Optional</code></p><ul><li>是否开启保险箱功能，我们选择 <code>Optional</code> 不开启它。</li></ul></li></ul><hr><h3 id="2-5-6-Config–Misc–Tools"><a href="#2-5-6-Config–Misc–Tools" class="headerlink" title="2.5.6 Config–Misc–Tools"></a>2.5.6 Config–Misc–Tools</h3><p>用于运行 OC 调试工具, 例如验证 CFG 锁 (VerifyMsrE2)</p><ul><li><strong>Arguments</strong><ul><li>传递的参数</li></ul></li><li><strong>Auxiliary:</strong> <code>NO</code><ul><li><code>NO</code> 默认不隐藏</li></ul></li><li><strong>Comment:</strong> <code>随便填</code><ul><li>随便填</li></ul></li><li><strong>Enabled</strong> <code>YES/NO</code><ul><li>启用或禁用</li></ul></li><li><strong>Flavour</strong> <code>Auto</code><ul><li>当<code>PickerAttributes</code>设置成<code>0x0080</code>时适应主题需求</li></ul></li><li><strong>Name</strong> <code>名称（如 openshell ）</code><ul><li>OpenCore 启动项中显示的名称</li></ul></li><li><strong>Path</strong> <code>文件名称（如 openshell.efi）</code><ul><li><code>Tools</code> 文件夹下的文件名</li></ul></li><li><strong>RealPath</strong> <code>NO</code><ul><li>一般不启用</li></ul></li><li><strong>TextMode</strong> <code>NO</code><ul><li>一般不启用</li></ul></li></ul><hr><h2 id="2-6-Config–NVRAM"><a href="#2-6-Config–NVRAM" class="headerlink" title="2.6 Config–NVRAM"></a>2.6 Config–NVRAM</h2><hr><h3 id="2-6-1-Config–NVRAM–Add"><a href="#2-6-1-Config–NVRAM–Add" class="headerlink" title="2.6.1 Config–NVRAM–Add "></a>2.6.1 Config–NVRAM–Add <a id=2.6.1></a></h3><pre><code class="xml">4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14    UIScale                     Data       &lt;02&gt; //这里填写01为普通的UI显示模式，02为开启HIDPI的UI显示模式，我选择02    DefaultBackgroundColor      Data       &lt;00000000&gt; //默认开机背景色为黑色7C436110-AB2A-4BBB-A880-FE41995C9F82    boot-args                   String     Slide=1 darkwake=0 -v //slide=1 表示从第一组内存开始连续注入；darkwake=0 代表一键唤醒机器并偏好设置中节能选项的小憩功能。如果你要用小憩功能请填8； -v 是跑代码，在没装好稳定的黑果前我建议加上，方便定位错误，弄完后再删除 -v    csr-active-config           Data       &lt;e7030000&gt; //关闭 SIP 保护    nvda_drv                    Data       &lt;31&gt; //对 10.13 系统之前的N卡的相关设置，我们不做讨论。    prev-lang:kbd               Data       &lt;7a682d48616e733a323532&gt; //语言设置相关，记得改成这个，这个是中文    ForceDisplayRotationInEFI   Number     0   开机的UEFI界面是否需要调整，比如你是竖屏的，可以填0,90,180,270。请同时开启AppleEg2Info    7C436110-AB2A-4BBB-A880-FE41995C9F82 //默认就行，如果需要使用 RTC 屏蔽选项，具体参考RTC综述</code></pre><hr><h3 id="2-6-2-Config–NVRAM–Delete"><a href="#2-6-2-Config–NVRAM–Delete" class="headerlink" title="2.6.2 Config–NVRAM–Delete"></a>2.6.2 Config–NVRAM–Delete</h3><p>NVRAM的数据不可被覆盖，必须先被删除再添加，我们这里按默认设置不必理会。</p><hr><h3 id="2-6-3-Config–NVRAM–LegacySchema"><a href="#2-6-3-Config–NVRAM–LegacySchema" class="headerlink" title="2.6.3 Config–NVRAM–LegacySchema"></a>2.6.3 Config–NVRAM–LegacySchema</h3><p>这里是模拟 <code>NVRAM</code> 的变量设置，大部分默认已经填好，我们只需添加两个变量即可。</p><p>打开 <code>7C436110-AB2A-4BBB-A880-FE41995C9F82</code> 这一栏，添加两个item如下：</p><pre><code class="bash">item 11     String      efi-boot-deviceitem 12     String      efi-boot-device-data</code></pre><hr><h3 id="2-6-4-Config–NVRAM–LegacyEnable"><a href="#2-6-4-Config–NVRAM–LegacyEnable" class="headerlink" title="2.6.4 Config–NVRAM–LegacyEnable"></a>2.6.4 Config–NVRAM–LegacyEnable</h3><p>如果你的主板不支持原生 <code>NVRAM</code>，请一定要选择 <code>YES</code>，反之则选择 <code>NO</code>。</p><hr><h3 id="2-6-5-Config–NVRAM–WriteFlash"><a href="#2-6-5-Config–NVRAM–WriteFlash" class="headerlink" title="2.6.5 Config–NVRAM–WriteFlash"></a>2.6.5 Config–NVRAM–WriteFlash</h3><p>一般情况下我们需要选择 <code>YES</code> 来保证<code>启动磁盘</code>功能的正常使用，但开启后可能会在一段时间后导致 <code>CMOS</code> 被写满，主板无法经过自检。这样的问题请请参照<a href="https://blog.xjn819.com/post/rtc-issues-related-to-oc.html">RTC综述</a></p><hr><h3 id="2-6-6-Config–NVRAM–LegacyOverwrite"><a href="#2-6-6-Config–NVRAM–LegacyOverwrite" class="headerlink" title="2.6.6 Config–NVRAM–LegacyOverwrite"></a>2.6.6 Config–NVRAM–LegacyOverwrite</h3><p>对模拟 <code>nvram</code> 用户来说，将 <code>nvram.plist</code> 写入硬件，我认为不管是原生 <code>nvram</code> 还是模拟 <code>nvram</code>，都选择 <code>NO</code>。</p><hr><h2 id="2-7-Config–PlatformInfo"><a href="#2-7-Config–PlatformInfo" class="headerlink" title="2.7 Config–PlatformInfo"></a>2.7 Config–PlatformInfo</h2><p>这里我们填合适的机型。对于最近一代的主板来说，一般的原则，只有核显的机器我们选Macmini8,1；只有独显的机器我们选择iMac Pro 1,1;有核显和独显的我们选择iMac 19,1。笔记本请按照对应的cpu型号来选择。</p><hr><h3 id="2-7-1-Config–PlatformInfo–Automatic"><a href="#2-7-1-Config–PlatformInfo–Automatic" class="headerlink" title="2.7.1 Config–PlatformInfo–Automatic"></a>2.7.1 Config–PlatformInfo–Automatic</h3><p>是否自动补全系统信息。这里我选 <code>YES</code>，不重要的信息让它自动填。</p><hr><h3 id="2-7-2-Config–PlatformInfo–CustomMemory"><a href="#2-7-2-Config–PlatformInfo–CustomMemory" class="headerlink" title="2.7.2 Config–PlatformInfo–CustomMemory"></a>2.7.2 Config–PlatformInfo–CustomMemory</h3><p>自定义内存选项，请选择<code>NO</code></p><hr><h3 id="2-7-3-Config–PlatformInfo–Generic"><a href="#2-7-3-Config–PlatformInfo–Generic" class="headerlink" title="2.7.3 Config–PlatformInfo–Generic"></a>2.7.3 Config–PlatformInfo–Generic</h3><p>这里是我们需要填写的三码部分。</p><p>将 <code>OpenCore</code> 包下 <code>Utilities/macserial</code> 程序放到桌面，在终端下输入以下命令</p><pre><code class="bash">~/desktop/macserial --model iMacPro1,1 //你也可以换成你想要的机型比如iMac 19.1</code></pre><p>输入后你回获得一些序列号以及主板主板序列号，请自己选用一组，填写到 <code>MLB</code> 以及 <code>SystemSerialNumber</code> 后重启。</p><p>重启后，请再在终端下输入：</p><pre><code class="bash">ioreg -d2 -c IOPlatformExpertDevice | awk -F\&quot; &#39;/IOPlatformUUID/&#123;print $(NF-1)&#125;&#39;</code></pre><p>得到你的主板 UUID，填入 <code>Generic</code> 的 <code>SystemUUID</code> （此操作可以帮助你的 win 不丢失激活）</p><ul><li><p><strong>AdviseFeatures</strong> <code>YES</code></p><ul><li>旧的主板不开启这项会让：<ul><li>当WINDOWS的EFI引导不在第一个分区时，将无法引导。</li><li>MacOS无法安装在APFS硬盘上。</li></ul></li></ul></li><li><p><strong>MaxBIOSVersion</strong> <code>0</code></p><ul><li>一般情况填0，旧款的白苹果需要填写<code>9999.999.999.999.999</code>。</li></ul></li><li><p><strong>SystemMemoryStatus</strong> <code>Auto</code></p><ul><li>一些机型本身是可以升级内存，但在关于本机选项卡中不显示内存选项时需要开启，一般选择 <code>Auto</code>。</li></ul></li><li><p><strong>SpoofVendor</strong> <code>YES</code></p><ul><li>是否把主板名称更改为 ACDT，一般我们选择 <code>YES</code>。</li></ul></li><li><p><strong>ProcessorType</strong> <code>0</code></p><ul><li>为一些es，qs或者amd的cpu在关于本机中显示核心数。</li></ul></li><li><p><strong>UpdateDataHub</strong> <code>YES</code></p><ul><li>更新DataHub。</li></ul></li></ul><ul><li><p><strong>UpdateNVRAM</strong> <code>YES</code></p><ul><li>更新NVRAM。</li></ul></li><li><p><strong>UpdateSMBIOS</strong> <code>YES</code></p><ul><li>更新 BIOS</li></ul></li><li><p><strong>UpdateSMBIOSMode</strong> <code>Create</code></p><ul><li>用新分配的 <code>EfiReservedMemoryType</code> 替换原有的表, 戴尔笔记本需要使用 <code>Custom</code> 并开启 <code>CustomSMBIOSGuid</code></li></ul></li><li><p><strong>UseRawUuidEncoding</strong> <code>NO</code></p><ul><li>一般来说我们都选<code>NO</code></li><li>除非你的UUID，比如：<code>AABBCCDD-EEFF-GGHH-IIJJ-KKLLMMNNOOPP</code>。解码后即是<code>AA BB CC DD EE FF GG HH II JJ KK LL MM NN OO PP</code>，但在实际系统中显示<code>DD CC BB AA FF EE HH GG II JJ KK LL MM NN OO PP</code>。你需要开启这个选项。</li></ul></li></ul><hr><h2 id="2-8-Config—-UEFI"><a href="#2-8-Config—-UEFI" class="headerlink" title="2.8 Config—-UEFI"></a>2.8 Config—-UEFI</h2><hr><h3 id="2-8-1-Config–UEFI–APFS"><a href="#2-8-1-Config–UEFI–APFS" class="headerlink" title="2.8.1 Config–UEFI–APFS"></a>2.8.1 Config–UEFI–APFS</h3><ul><li><p><strong>EnableJumpstart</strong> <code>YES</code></p><ul><li>从 APFS 容器中加载内置 APFS 驱动，建议开启 <code>YES</code>。此选项仍然依据你的<code>Scanpolicy</code>来做出决定，请确保在<code>Scanpolicy</code>中放开 APFS 格式。</li></ul></li><li><p><strong>GlobalConnect</strong> <code>NO</code></p><ul><li>一些主板需要选择 yes 才能完全加载 APFS，比如 HP笔记本。</li></ul></li><li><p><strong>HideVerbose</strong> <code>YES</code></p><ul><li>是否隐藏啰嗦模式，一般我们需要看日志的时候才开启，所以我们选择隐藏，选择 <code>YES</code>。</li></ul></li><li><p><strong>JumpstartHotPlug</strong> <code>YES</code></p><ul><li>是否加载 APFS 格式的热插设备.</li></ul></li><li><p><strong>MinDate</strong> <code>0</code></p><ul><li>加载最低发行的 APFS 格式。一些旧的 APFS 可能会危害电脑，我们填 <code>0</code>。如果你想加载旧的发行日期的 APFS 格式硬盘，请填 <code>-1</code>。</li></ul></li><li><p><strong>MinVersion</strong> <code>0</code></p><ul><li>加载最低版本的 APFS 格式。填 <code>0</code> 代表从 <code>HIGH SIERRA</code> 开始加载。填<code> -1</code> 代表所有版本，建议填 <code>0</code>。</li></ul></li></ul><hr><h3 id="2-8-2-Config–UEFI–AppleInput"><a href="#2-8-2-Config–UEFI–AppleInput" class="headerlink" title="2.8.2 Config–UEFI–AppleInput"></a>2.8.2 Config–UEFI–AppleInput</h3><ul><li><p><strong>AppleEvent</strong> <code>Auto</code></p><ul><li>在UEFI界面中使用APPLE自带的键鼠控制还是用OC制作的。<ul><li>填写<code>Builtin</code>：使用OpenCore的控制</li><li>填写<code>OEM</code>：使用Apple自带的控制</li><li>填写<code>Auto</code>：自动选择</li></ul></li></ul></li><li><p><strong>CustomDelays</strong> <code>NO</code></p><ul><li>在UEFI界面中控制键盘连击的延迟。当<code>AppleEvent</code>=OEM 时此选项无效。<ul><li><code>NO</code>：使用Apple默认的500ms首次延迟和50ms的随后延迟。</li><li><code>YES</code>：根据<code>KeyInitialDelay</code> <code>KeySubsequentDelay</code>来设置延迟。</li></ul></li></ul></li><li><p><strong>KeyInitialDelay</strong> <code>50</code></p><ul><li>设置UEFI界面第一次延迟时间，50是500ms，此选项必须在<code>CustomDelays</code>=True时生效。</li></ul></li><li><p><strong>KeySubsequentDelay</strong> <code>5</code></p><ul><li>设置UEFI界面键与键之间的延迟时间，5是50ms，此选项必须在<code>CustomDelays</code>=True时生效。</li></ul></li><li><p><strong>PointerSpeedDiv</strong> <code>1</code></p><ul><li>设置UEFI界面中，光标的跟踪速度版本，一般填1。</li></ul></li><li><p><strong>PointerSpeedMul</strong> <code>1</code></p><ul><li>设置UEFI界面中，光标的灵敏度版本，一般填1。</li></ul></li></ul><hr><h3 id="2-8-3-Config–UEFI–Audio"><a href="#2-8-3-Config–UEFI–Audio" class="headerlink" title="2.8.3 Config–UEFI–Audio"></a>2.8.3 Config–UEFI–Audio</h3><p>此项的内容是帮助你在开机阶段驱动板载音频，此项对DP等数字音频无效。</p><ul><li><p><strong>AudioCodec</strong> <code>0</code></p><ul><li>填写音频声卡in节点。可以用 <code>PinConfigurator</code> 提取。</li></ul></li><li><p><strong>AudioDevice</strong> <code>0</code></p><ul><li>填写你声卡的路径。这里我们填写<a href="#2.3.1">章节2.3.1</a>中寻找到的声卡路径。这里我填了 <code>PciRoot(0x0)/Pci(0x1f,0x3)</code>，请按你自己的实际情况填写。</li></ul></li><li><p><strong>AudioOut</strong> <code>0</code></p><ul><li>音频声卡out节点。可以用 <code>PinConfigurator</code> 提取。</li></ul></li><li><p><strong>AudioSupport</strong> <code>NO</code></p><ul><li>是否开启黑苹果的提示音支持。</li></ul></li><li><p><strong>MinimumVolume</strong> <code>20</code></p><ul><li>声音音量，范围在 <code>0-100</code> 之间。</li></ul></li><li><p><strong>PlayChime</strong> <code>Auto</code></p><ul><li>是否开启开机提示音；如果需要开启请填入<code>Enabled</code>。</li></ul></li><li><p><strong>ResetTrafficClass</strong> <code>No</code></p><ul><li>在不使用<code>AppleALC.kext</code>时驱动声卡，一些芯片组上的声卡并不被设置为TC0，比如<a href="https://www.intel.cn/content/www/cn/zh/io/io-controller-hub-9-datasheet.html">ICH09</a>。当我们使用AppleALC时，默认被设置为了alctsel。</li></ul></li><li><p><strong>SetupDelay</strong> <code>0</code></p><ul><li>一些<code>codecs</code>要求特殊的延迟才能正常使用。一般填0，而如需填写以0.5为单位增加。</li></ul></li><li><p><strong>VolumeAmplifier</strong> <code>0</code></p><ul><li>非必要情况下填写0。</li></ul></li></ul><blockquote><p>开启UEFI加载阶段的音频你必须下载<a href="https://github.com/acidanthera/OcBinaryData/tree/master/Resources">Audio文件夹</a>,并把 Audio 文件夹放到 <code>ESP/EFI/OC/Resources</code> 下。另外你必须注意 <code>AppleAudio</code> 选项。</p></blockquote><hr><h3 id="2-8-4-Config–UEFI–ConnectDrivers"><a href="#2-8-4-Config–UEFI–ConnectDrivers" class="headerlink" title="2.8.4 Config–UEFI–ConnectDrivers"></a>2.8.4 Config–UEFI–ConnectDrivers</h3><p>是否加载补丁，我们选择 <code>YES</code>。</p><hr><h3 id="2-8-5-Config–UEFI–Drivers"><a href="#2-8-5-Config–UEFI–Drivers" class="headerlink" title="2.8.5 Config–UEFI–Drivers"></a>2.8.5 Config–UEFI–Drivers</h3><pre><code class="bash">Driversitem0                      String0 .................... MemoryAllocation.efi1 .................... OpenRuntime.efi2 .................... HFSPlus.efi3 .................... OpenCanopy.efi</code></pre><h3 id="2-8-6-Config–UEFI–Input"><a href="#2-8-6-Config–UEFI–Input" class="headerlink" title="2.8.6 Config–UEFI–Input"></a>2.8.6 Config–UEFI–Input</h3><p>此选项是原生 Apple 开机热键的选项，需要配合我们之前设置的 <code>PollAppleHotKeys = yes</code> 一起用。下面的设置完全按照默认情况就行了。</p><blockquote><p>如果你是华硕的z87或者z97，你需要打开PointerSupport这个选项。</p></blockquote><hr><h3 id="2-8-7-Config–UEFI–Output"><a href="#2-8-7-Config–UEFI–Output" class="headerlink" title="2.8.7 Config–UEFI–Output"></a>2.8.7 Config–UEFI–Output</h3><ul><li><p><strong>ClearScreenOnModeSwitch</strong> <code>NO</code></p><ul><li>消除开机时从图形模式转换到文本时出现残影的问题，如果没有这个问题我们选择 <code>NO</code>。</li></ul></li><li><p><strong>ConsoleMode</strong> <code>MAX</code></p><ul><li>主机的输出方式，一般情况下填 <code>MAX</code>，或者留空。</li></ul></li><li><p><strong>DirectGopRendering</strong> <code>NO</code></p><ul><li>是否使用内置显卡直接渲染开机画面。</li></ul></li><li><p><strong>ForceResolution</strong> <code>NO</code></p><ul><li>Intel <code>Ironlake/Arrandale</code> 及之前的核心显卡需要开启此功能来自定义分辨率。</li></ul></li><li><p><strong>GopPassThrough</strong> <code>Disabled</code></p><ul><li>在UGA环境中调用显卡GOP。若要开启它，你必须同时开启<code>ProvideConsoleGop</code>。</li></ul></li></ul><ul><li><p><strong>IgnoreTextInGraphics</strong> <code>NO</code></p><ul><li>修复在不使用 <code>-v</code> 跑马模式时候，开机日志导致的苹果 LOGO 显示不正确的问题。</li></ul></li><li><p><strong>ProvideConsoleGop</strong> <code>YES</code></p><ul><li>调用显卡 GOP。</li></ul></li><li><p><strong>ReconnectOnResChange</strong> <code>NO</code></p><ul><li>一些固件在 GOP 分辨率改变后会重新连接显示器才能输出，一般情况下选择 <code>NO</code>。</li></ul></li><li><p><strong>ReplaceTabWithSpace</strong> <code>NO</code></p><ul><li>一些固件在 <code>UEFI Shell</code> 下 <kbd>Tab</kbd> 功能键不生效，开启这个会用空格键代替。</li></ul></li><li><p><strong>Resolution</strong> <code>留空</code></p><ul><li>开机 UEFI 阶段的分辨率。比如我的显示器是 4K、16：9 的，就填写 <code>3840x2160</code>。根据情况填写或者不填。</li></ul></li><li><p><strong>SanitiseClearScreen</strong> <code>YES</code></p><ul><li>修复 4K 及以上显示器的输出问题。</li></ul></li><li><p><strong>TextRenderer</strong> <code>BuiltinGraphics</code></p><ul><li>OC 开机代码字体渲染方式</li></ul></li><li><p><strong>UgaPassThrough</strong> <code>NO</code></p><ul><li>通过 uga 来代替那些无法使用 gop 的主板，一般带 uefi 的主板以及显卡请选择 <code>NO</code>。</li></ul></li></ul><hr><h3 id="2-8-8-Config–UEFI–ProtocolOverrides"><a href="#2-8-8-Config–UEFI–ProtocolOverrides" class="headerlink" title="2.8.8 Config–UEFI–ProtocolOverrides"></a>2.8.8 Config–UEFI–ProtocolOverrides</h3><ul><li><p><strong>AppleAudio</strong> <code>NO</code></p><ul><li>如果你想要开启如同白苹果一样的开机音效，请开启它，并且还需要配合 <code>UEFI--Audio</code> 的正确设置。</li></ul></li><li><p><strong>AppleBootPolicy</strong> <code>NO</code></p><ul><li>虚拟机的 Mac 需要用的。</li></ul></li><li><p><strong>AppleDebugLog</strong> <code>NO</code></p><ul><li>重新安装苹果错误日志界面。</li></ul></li><li><p><strong>AppleEg2Info</strong> <code>NO</code></p><ul><li>配合<code>ForceDisplayRotationInEFI</code>调整开机时画面的显示角度，当你要用竖屏的时候不仅要在nvram中设置<code>ForceDisplayRotationInEFI</code>的角度，这个也要开启。</li></ul></li></ul><ul><li><p><strong>AppleFramebufferInfo</strong> <code>NO</code></p><ul><li>为虚拟机使用，不是虚拟机选择 <code>NO</code>。</li></ul></li><li><p><strong>AppleImageConversion</strong> <code>NO</code></p><ul><li>重建 Apple 图标。</li></ul></li><li><p><strong>AppleImg4Verification</strong> <code>NO</code></p><ul><li>当开启安全启动时必须开启它。</li></ul></li><li><p><strong>AppleKeyMap</strong> <code>NO</code></p><ul><li>重建苹果功能键。</li></ul></li><li><p><strong>AppleRtcRam</strong> <code>NO</code></p><ul><li>重装 <code>AppleRtc</code> 协议。</li></ul></li><li><p><strong>AppleSecureBoot</strong> <code>NO</code></p><ul><li>苹果安全启动协议。</li></ul></li><li><p><strong>AppleSmcIo</strong> <code>NO</code></p><ul><li>代替之前的 <code>VirtualSMC.efi</code>，在使用<code>vault</code>功能时需要开启。</li></ul></li><li><p><strong>AppleUserInterfaceTheme</strong> <code>NO</code></p><ul><li>重新安装 <code>Apple User Interface Theme</code> 协议。</li></ul></li><li><p><strong>DataHub</strong> <code>NO</code></p><ul><li>重建 <code>Datahub</code>。</li></ul></li><li><p><strong>DeviceProperties</strong> <code>NO</code></p><ul><li>虚拟机或者老款的电脑需要选择 <code>YES</code> 才能注入 <code>Device Property</code>，我们选NO。如果你发现你注入 <code>Device Property</code> 无效，请选择 <code>YES</code>。</li></ul></li><li><p><strong>FirmwareVolume</strong> <code>NO</code></p><ul><li>Vault/虚拟机/老款 Mac 需要开启才能相关项。</li></ul></li><li><p><strong>HashServices</strong> <code>NO</code></p><ul><li>Vault 相关项。</li></ul></li><li><p><strong>OSInfo</strong> <code>NO</code></p><ul><li>通知主板以及一些程序关于 Mac 引导的信息，一般情况选择 <code>NO</code>。</li></ul></li><li><p><strong>UnicodeCollation</strong> <code>NO</code></p><ul><li>旧的主板需要，我们选 <code>NO</code>。</li></ul></li></ul><hr><h3 id="2-8-9-Config–UEFI–Quirks"><a href="#2-8-9-Config–UEFI–Quirks" class="headerlink" title="2.8.9 Config–UEFI–Quirks"></a>2.8.9 Config–UEFI–Quirks</h3><ul><li><p><strong>ActivateHpetSupport</strong> <code>NO</code></p><ul><li>老主板比如ICH6芯片组不具备相关的HPET设置，老的主板你可能需要开启它。</li></ul></li><li><p><strong>EnableVectorAcceleration</strong> <code>YES</code></p><ul><li>在CPU支持avx512或者avx的情况下，在UEFI界面中开启avx加速。</li><li></li></ul></li><li><p><strong>DisableSecurityPolicy</strong> <code>NO</code></p><ul><li>关闭主板的UEFI上的Secure Boot。请<code>不要</code>在BIOS中开启<code>Secure Boot</code>并同时开启这个！</li></ul></li><li><p><strong>ExitBootServicesDelay</strong> <code>0</code></p><ul><li>旧主板需要给予主板退出时间（单位为微秒），较新的主板直接填 <code>0</code>。旧的主板比如 Z87pro，填 <code>3000000-5000000</code>。</li></ul></li><li><p><strong>ForgeUefiSupport</strong> <code>NO</code></p><ul><li>旧的NVIDIA显卡使用UEFI 2.0的gop，但在一些老的MAC中只支持UEFI 1.X。这个开关帮助旧的MAC使用NVDIA2.0的GOP。</li></ul></li><li><p><strong>IgnoreInvalidFlexRatio</strong> <code>NO</code></p><ul><li>如果你没有在 BIOS 中解锁 <code>MSR0x194</code>，一定要选YES。</li></ul></li><li><p><strong>ReleaseUsbOwnership</strong> <code>NO</code></p><ul><li>大部分的主板都有自动释放 USB 所有权的功能——BIOS/XHCI EHCI hand-off，我们选 <code>NO</code>。如果你开机键盘鼠标卡死了，或者 USB 失灵，试试选 <code>YES</code>。</li></ul></li><li><p><strong>ReloadOptionRoms</strong> <code>NO</code></p><ul><li>配合<code>ForgeUefiSupport</code>使用。</li></ul></li><li><p><strong>RequestBootVarRouting</strong> <code>YES</code></p><ul><li>增加 <code>启动磁盘</code> 的可靠性。</li></ul></li><li><p><strong>TscSyncTimeout</strong> <code>0</code></p><ul><li>帮助一些 X99、X299 的主板开启全核同步功能。此选项旨在代替 <code>TSCAdjustReset.kext</code> 等类似补丁，推荐的值是 <code>500000</code>。但是此选项并不能在睡眠唤醒后生效，所以请填写默认值 <code>0</code>，并使用 <code>TSCAdjustReset.kext</code> 来做全核同步。</li></ul></li><li><p><strong>UnblockFsConnect</strong> <code>NO</code></p><ul><li>惠普笔记本可能会让 OC 无法扫描到启动项，一般选择NO，如果你是惠普笔记本，请选择YES。</li></ul></li></ul><hr><h3 id="2-8-10-Config—-UEFI—-ReservedMemory-Properties"><a href="#2-8-10-Config—-UEFI—-ReservedMemory-Properties" class="headerlink" title="2.8.10 Config—-UEFI—-ReservedMemory Properties"></a>2.8.10 Config—-UEFI—-ReservedMemory Properties</h3><p>此项为保留内存所用。一些硬件会把硬件 EFI 写进内存过程中占据必要的 UEFI 运行空间，所以我们可以通过此项来预留内存来保证 UEFI 的运行。填写方式可以参考<a href="https://blog.daliansky.net/Slide-value-acquisition-and-calculation.html">小兵的文章</a>。来寻找指定内存的起始位置，以 4K 为一个节点。一般情况下，此项我们并不需要理会。</p><hr><h2 id="3-0-OpenCore-完善"><a href="#3-0-OpenCore-完善" class="headerlink" title="3.0 OpenCore 完善"></a>3.0 OpenCore 完善</h2><h3 id="3-1-模拟NVRAM"><a href="#3-1-模拟NVRAM" class="headerlink" title="3.1 模拟NVRAM "></a>3.1 模拟NVRAM <a id=3.1></a></h3><p>对 OC 而言，<code>NVRAM</code> 是非常核心的一环，不管是原生还是模拟的。<span style="color:red;">如果你是原生nvram的主板，请不必理会这章节</span>。</p><p>这章节的主要内容为非原生 NVRAM 模拟生成 <code>nvram.plist</code>。</p><ul><li><p>首先打开我们之前下载好的 OpenCore，进入目录下的 <code>Utilities/LogoutHook</code> 文件夹，你会看到 <code>LogoutHook.command</code> 文件。</p></li><li><p>打开 Terminal（终端）并输入 <code>cd ~</code> 返回到用户根目录，输入 <code>mv</code> 和一个空格，然后鼠标拖动 <code>LogoutHook.command</code> 文件到 Terminal（终端），再在终端输入 <code>~/.LogoutHook.command</code></p></li></ul><pre><code class="bash">例如（不要直接复制这条命令行） mv /Users/xjn/Downloads/OpenCore-0.6.2-RELEASE/Utilities/LogoutHook/LogoutHook.command ~/.LogoutHook.command</code></pre><ul><li>最后在 Terminal（终端）中，输入以下命令按回车：</li></ul><pre><code class="bash">sudo defaults write com.apple.loginwindow LogoutHook /Users/$USER/.LogoutHook.command</code></pre><ul><li><p>终端会提示要求你输入密码（密码打进去不会显示）。</p></li><li><p>重启，你会在 <code>ESP/EFI/</code> 下看到 <code>nvram.plist</code>，代表已经成功模拟了。</p></li></ul><hr><h3 id="3-2-建立自己的开机选择系统目录"><a href="#3-2-建立自己的开机选择系统目录" class="headerlink" title="3.2 建立自己的开机选择系统目录"></a>3.2 建立自己的开机选择系统目录</h3><details>  <summary><font color=red>因此部分需求太小众且繁琐，我折叠起来了，点击展开</font></summary><p>这个教程主要针对的是非原生 <code>nvram</code> 主板的用户，<span style="color:red;">如果你是原生 <code>nvram</code> 的用户，直接在偏好设置—启动磁盘中选定你希望设置为默认启动的磁盘即可，不必往下看浪费时间！</span></p><p>此步骤可能只适合 OC 纯净安装的系统，如果你之前使用过 clover 或者 oc mod 版本，请参照《精解opencore》中模拟 nvram 的方法。</p><p>非原生 nvram 用户必须完成以下几点：</p><ul><li><p>通过 <a href="#3.1">3.1的教程</a> 建立 <code>nvram.plist</code>.</p></li><li><p>确保 OpenCore 的版本为 2019年11月20日 之后的。更新 OpenCore 替换 <code>BOOT/BOOTx64.efi</code> 以及 <code>OC/OpenCore.efi</code> 即可。</p></li><li><p>确保 <code>config.plist</code> 下 <code>/Misc/Security/</code> 的 <code>ExposeSensitiveData=3</code> ;  <code>Booter/Quirks/</code> 的 <code>DisableVariableWrite=YES</code> ; <code>NVRAM/LegacyEnable</code>= <code>YES</code></p></li><li><p>确保文件夹 <code>ESP/EFI/OC/Drivers/</code> 下没有 <code>VariableRuntimeDxe.efi</code></p></li></ul><p>如果你是华硕的非原生nvram主板，你还需要做（此文件由群友 @哞 提供）：</p><ul><li>下载<a href="#3.1">LoginHook.command</a>，把它与 <code>LogoutHook.command</code> 放在一起，并执行:</li></ul><pre><code class="bash">sudo defaults write com.apple.loginwindow LoginHook ~/.LoginHook.command</code></pre><blockquote><p>3.2.1 以及 3.2.2 也是排列启动盘开机进入顺序的，比较麻烦，不推荐。</p></blockquote><hr><h4 id="3-2-1-第一部分"><a href="#3-2-1-第一部分" class="headerlink" title="3.2.1 第一部分"></a>3.2.1 第一部分</h4><p>我们首先要对 <code>Config--Misc--Security--scanpolicy</code> 这个值进行修改，默认的是 0，代表着扫描所有硬盘，而我们现在只让它扫我们的苹果系统硬盘。</p><p>感谢 @xlivans 提供的 OC 扫描策略：</p><blockquote><p>  - <code>2F0303</code> —官方推荐值+允许扫描HFS文件系统+允许扫描USB设备</p></blockquote><blockquote><p>    最终<code>扫描策略数值</code> = <code>3080963</code></p></blockquote><blockquote><p>OC-引导扫描策略</p></blockquote><blockquote><ul><li>设置位置：<code>Misc\Security\ScanPolicy</code></li></ul></blockquote><blockquote><ul><li><strong>定义：</strong></li></ul></blockquote><blockquote><p>  （01）0x00000001 — 限定为文件系统，由以下<code>允许扫描文件系统子项</code>开启</p></blockquote><blockquote><p>  （02）0x00000002 — 限定为设备类型，由以下<code>允许扫描设备类型子项</code>开启</p></blockquote><blockquote><p>  <code>允许扫描文件系统子项</code>：</p></blockquote><blockquote><p>  （03）0x00000100 — 允许扫描APFS文件系统</p></blockquote><blockquote><p>  （04）0x00000200 — 允许扫描HFS文件系统</p></blockquote><blockquote><p>  （05）0x00000400 — 允许扫描EFI系统分区文件系统</p></blockquote><blockquote><p>  <code>允许扫描设备类型子项</code>：</p></blockquote><blockquote><p>  （06）0x00010000 — 允许扫描SATA设备</p></blockquote><blockquote><p>  （07）0x00020000 — 允许扫描SAS和Mac NVMe设备</p></blockquote><blockquote><p>  （08）0x00040000 — 允许扫描SCSI设备</p></blockquote><blockquote><p>  （09）0x00080000 — 允许扫描NVMe设备</p></blockquote><blockquote><p>  （10）0x00100000 — 允许扫描CD / DVD设备</p></blockquote><blockquote><p>  （11）0x00200000 — 允许扫描USB设备</p></blockquote><blockquote><p>  （12）0x00400000 — 允许扫描FireWire设备</p></blockquote><blockquote><p>  （13）0x00800000 — 允许扫描读卡器设备</p></blockquote><blockquote><p>  <code>扫描策略数值</code>=（01）+（02）+1个或数个<code>允许扫描文件系统子项</code>+1个或数个<code>允许扫描设备类型子项</code></p></blockquote><blockquote><p>  例如：希望扫描对象是APFS文件系统的USB设备，<code>扫描策略数值</code>=（01）+（02）+（03）+（11），经16进制加法计算得出，<code>扫描策略数值</code>=<code>0x200103</code>。</p></blockquote><blockquote><p>  <code>注意</code>，使用时需将16进制转换为10进制。示例最终<code>扫描策略数值</code>=<code>2097411</code></p></blockquote><blockquote><ul><li>几种扫描策略</li></ul></blockquote><blockquote><p>  - <code>F0103</code> —官方推荐值：（01）+（02）+（03）+（06）+（07）+（08）+（09）</p></blockquote><blockquote><p>    最终<code>扫描策略数值</code> = <code>983299</code></p></blockquote><blockquote><p>  - <code>0</code>—允许扫描所有已知文件系统+允许扫描所有已知设备类型。</p></blockquote><blockquote><p>  - <code>2F0303</code> —官方推荐值+允许扫描HFS文件系统+允许扫描USB设备</p></blockquote><blockquote><p>    最终<code>扫描策略数值</code> = <code>3080963</code></p></blockquote><p>我们这里让 OC 只扫描 MAC 盘。根据说明，（1）+（2）是必须选的；因为我的 MAC 是 APFS，所以系统子项类我选（3）；我的 MAC 是安装在 NVME 上的，所以我在设备类型上选择（09），如果你是安装在 SATA 盘上的，你应该选（6）。</p><p>这样我们的公式就是：</p><pre><code class="bash">（1）+（2）+（3）+（9）= 0x00000001+0x00000002+0x00000100+0x00080000</code></pre><p>拿起苹果自带的计算器，按住<code>command+3</code>切换到编程型计算器，并转换到16进制模式:</p><pre><code class="bash">1+2+100+80000=80103</code></pre><p>得到数值后，我们再按一下转换10进制的按键，得出 <code>524547</code> 这个数值。</p><p>我们把 <code>524547</code> 填到 <code>scanpolicy</code> 中，重启，你就会看到第一个选项就是你的MAC盘了。但如果你还安装了WINDOWS什么的，选项中却没有了，别急，我们现在要把WIN的引导添加到mac的后面去。</p><hr><h4 id="3-2-2-第二部分"><a href="#3-2-2-第二部分" class="headerlink" title="3.2.2 第二部分"></a>3.2.2 第二部分</h4><p>现在我们要在开机画面中，将其他的一些系统排在mac后面。此项需要你下载debug版本的Opencore,请在文章开始部分提到的Opencore程序下载界面进行下载，并备份好你目前的EFI。</p><p>首先我们需要把下载好的 Opencore-Debug 版本里的 <code>ESP/EFI/BOOT/BOOTx64.efi</code> 以及 <code>ESP/EFI/OpenCore.efi</code> 两个文件替换到你正在使用中的 EFI 里去。修改你正在使用的 <code>EFI/OC/Config.plist</code>:</p><pre><code class="xml">Misc    Debug       DisableWatchDog    Boolean    YES       Target             Number     65     Security       ScanPolicy         Number     0 //这里我们要先改为0来寻找windows的地址，之后找到后改回之前算出来的即可</code></pre><p>接着，我们需要寻找你其他系统的UUID，我们打开终端，输入</p><pre><code class="bash">diskutil list</code></pre><p>找到你需要的盘的盘名，比如我的windows在disk0这个位置，而引导WIN的EFI文件夹的盘位是disk0s1。注意，Windows必须为<code>GPT引导模式</code>。</p><pre><code class="bash">/dev/disk1 (internal, physical):   #:                       TYPE NAME                    SIZE       IDENTIFIER   0:      GUID_partition_scheme                        *1.0 TB     disk0   1:                        EFI                         314.6 MB   disk0s1   2:       Microsoft Basic Data BOOTCAMP                999.7 GB   disk0s2</code></pre><p>接着输入：</p><pre><code class="bash">diskutil info disk0s1</code></pre><p>在输出内容里，我们需要的是 <code>Disk / Partition UUID</code>，我的是 <code>FF555974-AB3F-40B7-8530-AE6462E197CE</code>，把它记下来。</p><p>现在我们通过oc的开机选项直接重启到windows，我们打开<a href="https://www.diskgenius.cn/download.php">DiskGenius</a>，并且到我们mac的EFI盘符下，我们看到有一个日志报告 <code>opencore-xxxxx-xxxxx</code> 生成，为了好记，我们右键把它改名叫 <code>111.txt</code>，并拖到桌面。</p><p>打开刚才的 <code>111.txt</code>，我们搜索刚才记录下来的 <code>FF555974-AB3F-40B7-8530-AE6462E197CE</code></p><p>搜到类似这样的路径就是我们需要的：</p><pre><code class="bash">PciRoot(0x0)/Pci(0x1B,0x0)/Pci(0x0,0x0)/NVMe(0x1,CB-27-B3-91-53-38-25-00)/HD(1,GPT,FF555974-AB3F-40B7-8530-AE6462E197CE,0x800,0x96000)/\EFI\BOOT\BOOTX64.EFI</code></pre><p>把之前我们备份好的EFI，全部替换回去。把 <code>disablewatchdog</code>，<code>target</code>，<code>scanpolicy</code> 都改回原来的。这样我们的EFI又回到正式版本了，而不是 DEBUG 版本了。</p><p>回到Mac，打开 <code>config.plist</code>，我们把 win 的引导路径添加到 <code> misc--entries</code>，并在此下面添加一个 item,输入如图内容：</p><pre><code class="xml">Entries   Arguments     String       Comment       String     Windows 10//你随便取个名字   Enabled       Boolean    YES   Name          String     Windows 10/开机选择界面的名字   Path          String     PciRoot(0x0)/Pci(0x1B,0x0)/Pci(0x0,0x0)/NVMe(0x1,CB-27-B3-91-53-38-25-00)/HD(1,GPT,FF555974-AB3F-40B7-8530-AE6462E197CE,0x800,0x96000)/\EFI\BOOT\BOOTX64.EFI   TextMode      Boolean    No</code></pre><p>保存重启后，你会看到windows10放在了mac的下面。</p><blockquote><p>tips: 你可以<code>showpicker</code>选择no，就不会看到选择界面了，而当你需要时，只需要在开机时候按住option或者esc就可以唤出选择界面了，非常白果的体验哦。</p></blockquote></details><hr><h3 id="3-3-提取DSDT"><a href="#3-3-提取DSDT" class="headerlink" title="3.3 提取DSDT"></a>3.3 提取DSDT</h3><p>尽管提取原始DSDT的方法非常多，我认为 <code>CLOVER</code> 的提取方法是最方便并且靠谱的。我们需要一个空的U盘或者空的ESP分区，我的教程是非常偏向小白的，所以这里提取我也会用到windows，以及Diskgenius这个软件，做最简单的示范。</p><ul><li><p>进入Windows，插入U盘，打开<a href="https://www.diskgenius.cn/download.php">DiskGenius</a>，选中我们的U盘，并选择顶部菜单栏的快速分区</p><ul><li>分区表类型：<code>GUID</code></li><li>不要创建新的 <code>ESP</code> 分区</li><li>不要创建新的 <code>MSR</code> 分区</li><li>分区格式为 <code>FAT32</code></li></ul></li><li><p>格式化完成后，放入我从黑果小兵镜像包提取出来的<a href="/tools/EFI.zip">EFI</a>放进去。这是一个 clover 引导，但并不能引导你的系统，只能提取 DSDT。</p></li><li><p>插上U盘，重启，通过U盘引导，看到Clover界面，我们按F4，这样原始的DSDT文件就收集好了。</p></li><li><p>重新通过OC引导进入系统，我们打开U盘，EFI/Clover/ACPI/Orgin下，有我们的原始ACPI内容，我们只需要DSDT.aml这个就行了，保存到安全的地方。</p></li></ul><hr><h3 id="3-4-加载原生电源管理"><a href="#3-4-加载原生电源管理" class="headerlink" title="3.4 加载原生电源管理"></a>3.4 加载原生电源管理</h3><p>提取 DSDT 后使用 <code>MaciASL</code> 打开，搜索你 CPU 的名字。一般情况下，CPU 的名字可能是: <code>PR.CPU0</code>,<code>PR.P000</code>,<code>PR.PR00</code>,<code>SB.CPU0</code>,<code>SB.P000</code>,<code>SB.PR00</code>, <code>SCK0.C000</code>, <code>SCK0.CPU0</code>。请依次搜索直到找到自己的CPU名字，比如我的就是<code>SCK0.C000</code></p><pre><code class="asl">Processor (C000, 0x00, 0x00001810, 0x06)                &#123;                    Name (_HID, &quot;ACPI0007&quot; /* Processor Device */)  // _HID: Hardware ID                    Name (_UID, &quot;SCK0-C000&quot;)  // _UID: Unique ID                    Method (_PXM, 0, NotSerialized)  // _PXM: Device Proximity                    &#123;                        If ((CLOD == 0x00))                        &#123;                            Return (0x00)                        &#125;                        Else                        &#123;                            Local0 = DerefOf (APT0 [0x00])                            Local1 = CNBS /* \CNBS */                            Local1 -= 0x01                            Local0 &gt;&gt;= Local1                            Local0 &amp;= 0x01                            Local1 = 0x00                            Local1 *= 0x02                            If ((Local0 == 0x01))                            &#123;                                Local1 += 0x01                            &#125;                            Return (Local1)                        &#125;                    &#125;</code></pre><p>打开宪武大大的<a href="https://github.com/daliansky/OC-little">OC Little</a>，到 <code>05-注入设备/05-1-注入x86/</code> 目录下，我们看到宪武大大已经把大部分不同名字的CPU的 dsl 文件都做好了。我的 CPU 名字叫 <code>SCK0.C000</code>，打开 <code>SSDT-PLUG-_SCK0.C000.dsl</code>，左上角另存为（save as), 其中文件格式(file format)必须选择 <code>ACPI Machine Language Binary</code>，文件名字随便写吧，我就叫 <code>plug-xcpm.aml</code>，记住后缀为 <code>.aml</code>。</p><p>将 <code>plug-xcpm.aml</code> 放入 <code>EFI/OC/ACPI</code> 下，并在 <code>config.plist</code> 中添加加载此 aml 文件:</p><pre><code class="xml">ACPI  Add    Item 0      Comment    String       plug-xcpm      Enable     Boolean      YES      Path       String       plug-xcpm.aml</code></pre><p>加载后，重启，并清理一次 <code>nvram</code>，我们看到偏好设置–节能中，原生电源管理已经被加载了。</p><hr><h4 id="3-4-1-节能五项"><a href="#3-4-1-节能五项" class="headerlink" title="3.4.1 节能五项"></a>3.4.1 节能五项</h4><p>节能五项是白果台式机中，<code>系统偏好设置</code>—<code>节能</code> 中的五个选项。在加载原生电源管理后，一般有4项节能出现，而第五项“断电后重启”这项还需要加载 <code>PPMC</code> 以及 <code>LPCB</code> 下的 <code>PMCR</code> 才能出现。虽然没啥鸟用，但对于强迫者而言，少一个一定很难受吧。如果你是笔记本，不需要看这章，白果笔记本本身没有。如果你没有机械硬盘，也不会出现 <code>Put hard disks to sleep when possible</code>。</p><p>直接下载<a href="/tools/SSDT-PM.zip">SSDT-PM.aml</a>载入即可。</p><hr><h3 id="3-5-解锁-macOS-的系统目录"><a href="#3-5-解锁-macOS-的系统目录" class="headerlink" title="3.5 解锁 macOS 的系统目录"></a>3.5 解锁 macOS 的系统目录</h3><p>bugprogrammer给出了一个一劳永逸的解决方案：</p><p><a href="http://www.bugprogrammer.me/2019/07/13/unlockSystem.html">解锁macOS10.15的系统分区</a></p><p>11系统的解锁略麻烦：<a href="https://www.bugprogrammer.me/2020/07/09/about-BigSur.html#%E5%88%A0%E9%99%A4%E5%BF%AB%E7%85%A7%EF%BC%8C%E9%87%8D%E8%8E%B7%E6%9D%83%E9%99%90">解锁MacOS11的系统区</a></p><hr><h3 id="3-6-关于EC控制器"><a href="#3-6-关于EC控制器" class="headerlink" title="3.6 关于EC控制器"></a>3.6 关于EC控制器</h3><p>EC控制器是电脑自带的一个叫 <code>embedded controller</code> 的部件。在 10.15 的系统环境中，笔记本电脑必须重命名原来的 EC，而一些台式机主板则需要禁用。下面我会分开来讲解如何禁用 EC、如何加载 USB 电源管理支持。</p><hr><h4 id="3-6-1-禁用EC控制器"><a href="#3-6-1-禁用EC控制器" class="headerlink" title="3.6.1 禁用EC控制器"></a>3.6.1 禁用EC控制器</h4><p><a href="#2.1.3">之前的章节</a>中提供了重命名这种方式去讲 EC0 更名为 EC，其实这种方法是只适合笔记本的，台式机最好还是禁用 EC。</p><p>打开之前提取出来的 DSDT.aml，搜索 <code>PNP0C09</code>，这里我搜到我的EC真实名字叫做 <code>H_EC</code>，你的可能叫 <code>EC0</code> 或者别的什么奇怪的名字。</p><p>这里我可以看到我的 <code>H_EC</code> 已经是屏蔽掉的，怎么判定，你看下面有一个 <code>Return (Zero)</code>，意味着这个部件是不生效的，即禁用。这样的情况我们不需要做任何 SSDT 去禁用这个真的 EC。</p><pre><code class="asl">    Scope (_SB.PCI0.LPCB)    &#123;        Device (H_EC)        &#123;            Name (_HID, EisaId (&quot;PNP0C09&quot;) /* Embedded Controller Device */)  // _HID: Hardware ID            Name (_UID, One)  // _UID: Unique ID            Method (_STA, 0, NotSerialized)  // _STA: Status            &#123;                ^^^GFX0.CLID = 0x03                Return (Zero)            &#125;</code></pre><p>那么什么样的情况是需要我们去屏蔽的呢？我发现基本上华硕的台式机主板都会启用这个EC控制器，下面代码是华硕主板的EC部件，搜索 <code>PNP0C09</code>，我们看到这种情况下，这个叫 EC0 的 <code>EC</code> 控制器是开启的，注意他没有 <code>return (Zero)</code> 这个语句，我们需要通过 SSDT 去屏蔽它。</p><pre><code class="asl">        Device (EC0)        &#123;            Name (_HID, EisaId (&quot;PNP0C09&quot;) /* Embedded Controller Device */)  // _HID: Hardware ID            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings            &#123;                IO (Decode16,                    0x0062,             // Range Minimum                    0x0062,             // Range Maximum                    0x00,               // Alignment                    0x01,               // Length                    )                IO (Decode16,                    0x0066,             // Range Minimum                    0x0066,             // Range Maximum                    0x00,               // Alignment                    0x01,               // Length                    )            &#125;)</code></pre><p>这里我提供了一个禁用 EC 的补丁，请直接下载，打开后左上角另存为（save as), 其中文件格式(file format)必须选择 <code>ACPI Machine Language Binary</code>，文件名字随便写吧，我就叫 <code>ssdt-no-EC.aml</code>，记住后缀为 <code>.aml</code>。将 <code>ssdt-no-EC.aml</code> 放入 <code>EFI/OC/ACPI</code> 目录下，并在 <code>config.plist</code> 中加载此 aml 文件。</p><p>直接下载<a href="/tools/SSDT-no-EC.dsl.zip">SSDT-PM.aml</a>载入即可。</p><p>如果你的 EC 名字叫 H_EC 或者别的什么的，你打开这个 <code>.dsl</code> 文件，替换代码中所有的 EC0 为 H_EC。</p><pre><code class="asl">&#123;    External (_SB.PCI0.LPCB, DeviceObj)    External (_SB_.PCI0.LPCB.H_EC, DeviceObj)    Scope (\_SB.PCI0.LPCB.H_EC)    &#123;        Method (_STA, 0, NotSerialized)  // _STA: Status        &#123;            If (_OSI (&quot;Darwin&quot;))            &#123;                Return (0)            &#125;            Else            &#123;                Return (0x0F)            &#125;        &#125;    &#125; &#125;</code></pre><blockquote><p>当你的电脑没有EC后，你仍然需要仿冒EC来完成全部操作。</p></blockquote><hr><h4 id="3-6-2-重命名EC控制器"><a href="#3-6-2-重命名EC控制器" class="headerlink" title="3.6.2 重命名EC控制器"></a>3.6.2 重命名EC控制器</h4><p>笔记本不能禁用 EC，禁用 EC 后会直接导致笔记本没有电池。那么我们怎么去重命名 EC 呢？按照上面提到的方法，找到你 EC 的真实名字，在<a href="#2.1.3">之前的章节</a>中我提供了假如你的笔记本的 EC 叫做 <code>EC0</code> 时候的重命名办法，那如果你的 E C叫别的乱七八糟的名字呢？</p><p>EC 名，比如你的 EC 叫做 <code>H_EC</code>，我们打开在线的<a href="https://tool.lu/hexstr/">HEX转换器</a>，输入 <code>H_EC</code>，并点击下面的16进制转换，就可以看到转换出来的值是 <code>485F4543</code>，把这个值替换到 <code>Find</code> 这个选项卡中就行了。你也会注意到，EC 的  hex-16 进制为 <code>45435F5F</code>，刚好是 <code>Replace</code> 的值。这就是一个非常简单实用的 OC 重命名。切记！OC 万不得已不要用重命名！</p><pre><code class="xml">Comment:                H_EC to ECCount:                    0Enabled:                YESFind:                    &lt;485F4543&gt;Limit:                    0Mask:                    &lt;&gt;OemTable:                &lt;&gt;Replace:                &lt;45435F5F&gt;ReplaceMask:            &lt;&gt;Skip:                    0TableLength:            0TableSignature:            &lt;&gt;</code></pre><hr><h4 id="3-6-3-仿冒EC及USBX供电"><a href="#3-6-3-仿冒EC及USBX供电" class="headerlink" title="3.6.3 仿冒EC及USBX供电"></a>3.6.3 仿冒EC及USBX供电</h4><p>禁用EC后你需要创建仿冒EC来进入系统，同时开启USB的快速供电技术（需设备支持）。你可以比较下面两张图，第二张是功能正确开启的。<br><img src="https://i.loli.net/2020/10/31/qonmCcpUJyrk84g.png" alt="Screen Shot 2020-10-31 at 3.40.07 PM.png"></p><p>这部分内容是仿冒 EC，注意不是每一个DSDT的路径都在 <code>SB.PCI0.LPCB</code>，请搜索 <code>0x001F0000</code> 来确定实际位置和名称。比如我的主板是在 <code>SB.PC00.LPC0</code>。</p><pre><code class="asl">    Scope (\_SB.PCI0.LPCB)    &#123;        Device (EC)        &#123;            Name (_HID, &quot;ACID0001&quot;)  // _HID: Hardware ID            Method (_STA, 0, NotSerialized)  // _STA: Status            &#123;                If (_OSI (&quot;Darwin&quot;))                &#123;                    Return (0x0F)                &#125;                Else                &#123;                    Return (Zero)                &#125;            &#125;        &#125;    &#125;</code></pre><p><img src="https://i.loli.net/2020/10/31/vhNd2tGwArqlZuk.png" alt="Screenshot-2020-02-05-at-10.47.54-AM.png"></p><hr><h3 id="3-7-睡眠即醒的相关问题"><a href="#3-7-睡眠即醒的相关问题" class="headerlink" title="3.7 睡眠即醒的相关问题"></a>3.7 睡眠即醒的相关问题</h3><p>睡眠即醒很大程度上跟 USB 的定制相关，一般一个好的 USB 定制就能解决睡眠即醒的问题。当然还有很多无法解决的问题，比如蓝牙不能在 HUB 下进行内建，等等。甚至有些时候我们都不知道为什么黑果会睡不着，那有没有一个办法让黑果强制睡眠呢？答案是有的。经过我的摸索，有几种方法能达到强制睡眠的效果，只是方法不同而已，但主要围绕的还是 <code>0d/6d</code> 的数值来做一些工作。这些方法涉及了很多 OC 领域的一些小技巧，我也顺便展示给大家。</p><blockquote><p><code>0d/6d</code> 补丁是阻止一些部件参与唤醒工作，这其中包括了xhc部件，意味着你无法使用鼠标键盘唤醒，只能用电源键唤醒。但若你有一组除了xhc之外的usb控制器，那把键盘鼠标插在那两个控制器上，可以在使用强制睡眠的情况下用键盘鼠标唤醒电脑。</p></blockquote><hr><h4 id="3-7-1-分辨0D-06"><a href="#3-7-1-分辨0D-06" class="headerlink" title="3.7.1 分辨0D/06"></a>3.7.1 分辨0D/06</h4><p>主板一般有5个部件是直接参与唤醒工作的，这五个部件分别是 XHC（USB控制器）、CNVW（CNVI网卡，如果你的主板自带或者预留了口的话）、GLAN（有线网卡）、XDCI（USB相关）、HDEF（音频）。旧的一些主板可能会有不同的命名，比如 XHC 有叫 EH01，HDEF 叫做 HDAS 等，这里不做讨论。而这些设备往往会直接影响睡眠，比如你输入：</p><pre><code class="bash">log show --last 1d | grep &quot;Wake reason&quot;</code></pre><p>我们会看到类似的输出结果</p><pre><code class="bash">2020-10-31 03:35:45.196371+0800 0x74       Default     0x0                  0      0    kernel: (AppleACPIPlatform) AppleACPIPlatformPower Wake reason: XDCI CNVW2020-10-31 03:35:45.196373+0800 0x74       Default     0x0                  0      0    kernel: (AppleACPIPlatform) AppleACPIPlatformPower Wake reason: XDCI CNVW</code></pre><p>那么即 是<code>XDCI</code> <code>CNVW</code> 导致了睡眠出现了问题。于是，我们用几种方法去屏蔽或者说修改这些部件，来达到电脑正常睡眠的效果。</p><p>我们打开之前提取的SSDT，随便搜索五大部件中的一个，比如说 XDCI：<br><img src="https://i.loli.net/2020/10/31/k5jDCx9c3WdJunh.png" alt="截屏2019-11-07下午11.06.02.png"></p><p>主要是看上图中 <code>XDCI</code> 下的 <code>_PRW</code> 属性值，可以直接看到 Return 的值为 <code>GPRW (0x6D, 0x04)</code>。其中 <code>6D</code> 这个数值看主板而定，有些主板叫做 <code>0D</code>，而后面 <code>04</code> 这个值的含义为 S4 级别的电源管理，即休眠甚至关机情况下的唤醒；有些后面的数值是 <code>03</code>，代表着 S3 级电源管理。这个我打一个大家比较熟悉的例子， <code>GLAN</code> 这个网卡部件的 <code>PRW</code> 值也是 <code>0x04</code>，为什么要是 <code>04</code> 呢？因为这样我们可以使用远程通过网络启动主机功能。</p><h4 id="3-7-1-1-方法一-OC-全局重命名强制睡眠"><a href="#3-7-1-1-方法一-OC-全局重命名强制睡眠" class="headerlink" title="3.7.1.1 方法一: OC 全局重命名强制睡眠"></a>3.7.1.1 方法一: OC 全局重命名强制睡眠</h4><p>上一步中已经确认了你的主板是 <code>0D</code> 还是 <code>06</code>，打开 <code>OC little</code> 的 <code>06/0D</code> 补丁，选择合适自己主板的补丁集，比如我的是 <code>Name-6D更名.plist</code>。将补丁抄入自己的 <code>config.plist</code> 后重启生效。</p><blockquote><p>全局重命名会导致其他系统无法通过 OC 引导开机，不建议使用。</p></blockquote><hr><h4 id="3-7-1-2-方法二-沿用Clover版本的0D-06补丁-amp-展示TgtBridge在OC下的用法"><a href="#3-7-1-2-方法二-沿用Clover版本的0D-06补丁-amp-展示TgtBridge在OC下的用法" class="headerlink" title="3.7.1.2 方法二: 沿用Clover版本的0D/06补丁&amp;展示TgtBridge在OC下的用法"></a>3.7.1.2 方法二: 沿用Clover版本的0D/06补丁&amp;展示TgtBridge在OC下的用法</h4><p>宪武大大做的 clover 版本的 0d/6d 补丁，其实没啥必要讲，只是有留言问了 tgtbridge 在 oc 下怎么用，那我就展示一下吧。这个补丁原理是一样的，通过重命名的方式改 <code>_prw</code>。</p><p>直接下载宪武大大的<a href="https://github.com/daliansky/P-little/tree/master/%E9%83%A8%E4%BB%B6%E8%A1%A5%E4%B8%81%E5%8C%85/11-1-%E7%9D%A1%E4%BA%86%E5%8D%B3%E9%86%92(0D:6D)%E8%A1%A5%E4%B8%81">clover hotpatch</a>补丁包，打开plist文件。那我们拿出一组数据来讲解怎么把它翻译成oc版本：</p><pre><code class="xml">Comment      String       XHC:_PRW to XPRWDisabled     Boolean      True//此补丁并未生效，这里要改成false才会生效Find         5F505257         //hex转text的含义即是：_PRW Replace      58505257         //hex转text的含义即是：XPRW TgtBridge    5848435F         //hex转text的含义即是：XHC_</code></pre><p>这组改名是对 <code>XHC</code> 下的 PRW 改名为<code> xprw</code>，这样的话，之前 prw 下的 <code>(0x6D, 0x04)</code> 即不生效了。而指定 xhc 的方法即是使用了 tgtbridge，因为整张 dsdt 上有几十上百个 <code>_PRW</code>，你必须通过 tgtbridge 来指定到底是哪一个部件的 <code>_PRW</code>。</p><p>那么 OC 到底怎么使用 tgtbridge 来特定某一部件下的内容重命名呢？我们先把上面一段 clover 的补丁转换成 oc 的版本先吧：</p><pre><code class="xml">Comment           String        XHC:_PRW to XPRWCount             Number                      //需要重点解释Enabled           Boolean       True          //表示应用此补丁，不应用选FalseFind              Data          5F505257      //hex转text的含义即是：_PRWLimit             Number        0             //这个按默认即可 不去管他Mask              Data          &lt;&gt;            //这个按默认即可 不去管他OemTableId        Data          &lt;&gt;            //这个按默认即可 不去管他Replace           Data          58505257      //hex转text的含义即是：XPRWReplaceMask       Data          &lt;&gt;            //这个按默认即可 不去管他Skip              Number                      //需要重点解释TableLength       Number        0             //这个按默认即可 不去管他TableSignature    Data          44534454      //hex转text的含义即是：DSDT，这里按默认即可，代表对dsdt进行修改</code></pre><p>这里就是一个还没全部翻译好的 oc 版改名 xhc 的 prw。那么如何定位 xhc 下的 <code>_prw</code> 呢，主要是填写 <code>Count</code> 和 <code>Skip</code>。其实 oc 的 <code>tgtbridge</code> 是通过一个个数过去来定位具体哪一个位置的。比如xhc的prw是整张dsdt里面的第55个，那 <code>skip</code> 填 <code>54</code>，意味着跳过前 <code>54</code> 个，从第 <code>55</code> 个开始执行。那执行多少次呢？执行一次 <code>count</code> 就填 1；比如你要同时改第 <code>55</code> 个和 <code>56</code> 个，那 count 就填 <code>2</code>。说了这么多，我来实操一下吧：</p><p>打开dsdt，在左下角直接搜索_PRW，就能把整张表的_PRW筛选出来了：<br><img src="https://i.loli.net/2020/10/31/EfxazsJNZLKmgv3.png" alt="截屏2019-11-08上午2.57.43.png"></p><p>我总共数了一下，一共有56个_PRW。我们再在主内容栏上按 <kbd> ⌘ </kbd>+<kbd>F</kbd> 搜索 xhc，直接找到 xhc 的 <code>_PRW</code>，刚好我们看到我的 xhc 实在整张表的倒数第 4 个，也就是正数第 53 个：</p><p><img src="https://i.loli.net/2020/10/31/SzvArXcH4OimtR9.png" alt="截屏2019-11-08上午3.00.36.png"></p><p>那么我们就可以补充完整张表了：</p><pre><code class="xml">Comment          String       XHC:_PRW to XPRWCount            Number       1Enabled          Boolean      TrueFind             Data         5F505257Limit            Number       0Mask             Data         &lt;&gt;OemTableId       Data         &lt;&gt;Replace          Data         58505257ReplaceMask      Data         &lt;&gt;Skip             Number       52TableLength      Number       0TableSignature   Data         44534454</code></pre><p>如果你想第 53、54、55 个都改掉，那 count 就写 3，意味着顺序执行3次。好了，就这样，有问题留言。</p><hr><h4 id="3-7-1-3-方法三：配合SSDT-重命名的强制睡眠补丁（推荐）"><a href="#3-7-1-3-方法三：配合SSDT-重命名的强制睡眠补丁（推荐）" class="headerlink" title="3.7.1.3 方法三：配合SSDT+重命名的强制睡眠补丁（推荐）"></a>3.7.1.3 方法三：配合SSDT+重命名的强制睡眠补丁（推荐）</h4><p>oc 不提倡用户直接全局重命名，如果真的要用重命名，也一定是搭配 ssdt 去做重命名，所以这个方法也是宪武大大和我最推荐的一种方法。</p><p>打开宪武大大的 OC-SSDT 包，找到  <code>0D/6D</code> 文件夹，打开 <code>SSDT-GPRW.dsl</code>。</p><pre><code class="asl">// In config ACPI, GPRW to XPRW// Find: 47505257 02// Replace: 58505257 02 //这里提示你要应用这个补丁，你必须在config中的ACPI-PATCH里面加入如上重命名内容//DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;ACDT&quot;, &quot;GPRW&quot;, 0)&#123;  External(XPRW, MethodObj) //寻找dsdt表中叫做XPRW的内容，这是要你在config中先把gprw改名成xprw才会生效，这就是为什么这个补丁的重命名必须是这个ssdt和重命名一起用的原因，你第一个重命名不生效，这个ssdt也不会生效。  Method (GPRW, 2, NotSerialized)  &#123;    If (_OSI (&quot;Darwin&quot;)) //为了不破坏dsdt完整性，这里做了系统判断，当你运行windows的时候，此ssdt不生效     &#123;       If ((0x6D == Arg0)) //如果你的dsdt中是6D进行判断       &#123;         Return (Package ()         &#123; 0x6D,           Zero          &#125;)       &#125;       If ((0x0D == Arg0)) //如果你的dsdt中是0D进行判断       &#123;         Return (Package ()         &#123; 0x0D,           Zero          &#125;)        &#125;      &#125;  Return (XPRW (Arg0, Arg1)) //当运行mac系统时，如果你的dsdt中XPRW为6d，或者0d时返回为0，即屏蔽。  &#125;&#125;</code></pre><p>这个 ssdt 不需要你改任何内容，打开后左上角另存为（save as), 其中文件格式(file format)必须选择 <code>ACPI Machine Language Binary</code>，文件名字就叫，记住后缀为 aml。记得将 <code>ssdt-gprw.aml</code> 放入 <code>EFI/OC/ACPI</code> 目录下，并在 <code>config.plist</code> 中加载此 aml 文件。</p><p>同时，我们需要在 <code>ACPI--Patch</code> 下增加一条全局重命名来配合此 SSDT。</p><pre><code class="xml">Comment: GPRW to XPRWCount:0Enabled:YESFind:&lt;4750525702&gt;Limit:0Mask:&lt;&gt;OemTable:&lt;&gt;Replace:&lt;5850525702&gt;ReplaceMask:&lt;&gt;Skip:0TableLength:0TableSignature:&lt;&gt;</code></pre><hr><h3 id="3-8-OC官方内核补丁集介绍"><a href="#3-8-OC官方内核补丁集介绍" class="headerlink" title="3.8 OC官方内核补丁集介绍"></a>3.8 OC官方内核补丁集介绍</h3><p>这里会长期更新OC官方提供的Kernel Patch。</p><hr><h4 id="3-8-1-华硕等机型开机卡F1"><a href="#3-8-1-华硕等机型开机卡F1" class="headerlink" title="3.8.1 华硕等机型开机卡F1"></a>3.8.1 华硕等机型开机卡F1</h4><p>注意此kp补丁只对10.14.4以上系统版本生效，旧的我懒得提供了，需要留言。更好的解决卡f1的方案请参照<a href="https://blog.xjn819.com/post/rtc-issues-related-to-oc.html">rtc综述</a></p><pre><code class="xml">Kernel  Patch     Item 0     Base         String     Comment      String    f1 patch （随便填，好记就行）     Count        Number    1     Enabled      Boolean   Yes     Find         Data      75330fb7     Identifier   String    com.apple.driver.AppleRTC     Limit        Number    0     Mask         Data           MaxKernel    String     MinKernel    String     Replace      Data      eb330fb7     ReplaceMask  Data     Skip         Number    0</code></pre><hr><h4 id="3-8-2-关机卡RTC"><a href="#3-8-2-关机卡RTC" class="headerlink" title="3.8.2 关机卡RTC"></a>3.8.2 关机卡RTC</h4><pre><code class="xml">Kernel    Patch      Item 2       Base         String      __ZN8AppleRTC14updateChecksumEv       Comment      String      Disable RTC ck poweroff（随便填，好记就行）       Count        Number      1       Enabled      Boolean     Yes       Find         Data       Identifier   String      com.apple.driver.AppleRTC       Limit        Number      0       Mask         Data       MaxKernel    String       MinKernel    String       Replace      Data        c3       ReplaceMask  Data       Skip         Number      0</code></pre><hr><h3 id="3-9-300系列主板开启原生NVRAM"><a href="#3-9-300系列主板开启原生NVRAM" class="headerlink" title="3.9 300系列主板开启原生NVRAM"></a>3.9 300系列主板开启原生NVRAM</h3><p>打开你的DSDT，搜索 <code>001F0000</code>，确定自己的</p><ul><li>lpc部件名字，如图示，我的lpc部件名叫做<code>LPC0</code>, 别的主板可能叫做<code>LPCB</code>，请根据实际情况记录</li><li>lpc的路径，如图左下角红线提示，我的LPC路径在<code>_SB_.PC00.LPC0</code></li></ul><p><img src="https://i.loli.net/2020/11/01/fO69YhztbwBrMsd.png" alt="Screenshot-2020-02-05-at-10.47.54-AM.png"></p><ul><li>下载<a href="/tools/SSDT-PMC.dsl.zip">SSDT-PMC.dsl</a>，根据自己的dsdt编辑相关内容：</li></ul><p><img src="https://i.loli.net/2020/11/01/gCaplW4bBY39KJs.png" alt="Screenshot-2020-02-05-at-10.53.33-AM.png"></p><p>左上角另存为（save as), 其中文件格式(file format)必须选择 <code>ACPI Machine Language Binary</code>，文件名字随便写吧，我就叫 <code>ssdt-pmc.aml</code>，记住后缀为aml。记得将 <code>ssdt-pmc.aml</code> 放入 <code>EFI/OC/ACPI</code> 目录下，并在 <code>config.plist</code> 中添加加载此aml文件。</p><ul><li>如果你之前模拟过nvram，请执行以下命令删除相关模拟内容：</li></ul><pre><code class="bash"># 删除文件 LogoutHook.commandsudo rm -rf $(sudo defaults read com.apple.loginwindow LogoutHook)# 清空 LogoutHook 的触发设置sudo defaults delete com.apple.loginwindow LogoutHook</code></pre><ul><li><p>删除EFI下的nvram.plist。</p></li><li><p>同时你需要对config.plist进行设置：</p><ul><li>NVRAM–LegacyEnable 选择No</li><li>NVRAM–LegacyOverwrite 选择No</li><li>Booter–Quirks—-DisableVariableWrite 选择no</li><li>你也许要打开NVRAM—WriteFlash 选择YES（请尽可能不要选！）</li></ul></li></ul><hr><h3 id="3-10-Acidanthera-Debug-错误调试"><a href="#3-10-Acidanthera-Debug-错误调试" class="headerlink" title="3.10 Acidanthera Debug 错误调试"></a>3.10 Acidanthera Debug 错误调试</h3><p>此博客有很多疏漏，你可能会碰到很多奇怪的问题而无法解决。一般来说，一张开机-v的截图只能解决一些很简单的问题，一些帮助者可能通过经验判断你的错误所在，但这样的图无法定位错误，而Acidanthera提供了非常非常强大的排错功能，我们可以利用它收集错误报告，在网络上获得帮助。</p><p>如果我们需要debug报告，我们需要将所有的Acidanthera的kext以及OC bootloader替换成debug版本，所有的debug版本都会在github中提供。我们下载debug版本的Opencore，替换：</p><ul><li>EFI/BOOT/<ul><li>BOOTx64.efi</li></ul></li><li>EFI/OC/Bootstrap/<ul><li> Bootstrap.efi</li></ul></li><li>EFI/OC/Drivers/<ul><li>OpenRuntime.efi</li></ul></li><li>EFI/OC/<ul><li>OpenCore.efi</li></ul></li><li>下载所有Acidanthera的debug版本kexts，并替换到EFI/OC/kexts</li></ul><p>修改config.plist中的如下内容：</p><ul><li><strong>AppleDebug</strong> <code>YES</code></li><li><strong>ApplePanic</strong> <code>YES</code></li><li><strong>DisableWatchdog</strong> <code>YES</code></li><li><strong>Target</strong> <code>67</code></li><li><strong>DisplayLevel</strong> <code>2147483714</code></li><li><strong>PickerMode</strong> <code>Builtin</code></li></ul><p>在Config.plist/NVRAM/7C436110-AB2A-4BBB-A880-FE41995C9F82/boot-args栏目中增加</p><ul><li><code>-liludbgall liludump=30</code></li></ul><p>保存后重启，你会得到：</p><ul><li>/EFI/下找到开机启动日志 (e.g. opencore-2020-11-16-083514.txt)</li><li>/var/log下得到所有Acidanthera的kext的日志(e.g.Lilu_1.5.0_20.1.txt)</li></ul><p>如果无法进入系统，则只需要第一份日志。</p><p>你可以通过这两份日志快速定位错误，或者在网路上寻求帮助。</p><hr><h2 id="4-0-OpenCore-进阶"><a href="#4-0-OpenCore-进阶" class="headerlink" title="4.0 OpenCore 进阶"></a>4.0 OpenCore 进阶</h2><p>以下内容对你正常使用黑苹果已经无关了，如果你追求更好的黑果表现，可以看下去，但这部分内容也需要你自己有更好的能力与耐心。如果你不具备足够的条件，我不建议你看下去；如果你的失误导致硬件的损坏，我也不会、也没能力负责。</p><hr><h3 id="4-1-CPU的变频优化"><a href="#4-1-CPU的变频优化" class="headerlink" title="4.1 CPU的变频优化"></a>4.1 CPU的变频优化</h3><p>此章节对你的要求会相对高一点，并且请你具备如下条件：</p><ul><li>有耐心</li><li>CFG已经解锁（这也许不是必要条件）</li><li>已经打开原生电源管理。</li><li>此章节只适用于4代之后的CPU。</li><li>在调整CPU变频时，出现失误导致CPU温度过高，能有正确的处理能力保证CPU不烧毁，我对极端的后果不负责任。</li><li>此教程对无核显用户不友好，需要自己更多的领悟。</li><li>如果你不同意第五条，请不要看下去。</li></ul><p>在Intel四代之后，苹果引入了新的内核级电源管理方式：<code>XCPM</code>（XNU CPU Power Management），这种新的管理方式可以高效地管理电源及变频。同时，苹果也推出了<code>HWP</code> (HardWare controlled Performance states)，这种技术可以快速根据特定程序的需求，作出变频转换。我们这个章节，本质上就是在加载<code>XCPM</code>的情况下，调整<code>HWP</code>来优化CPU的变频。</p><p>同时我要说的是，我在论坛上看到很多所谓的“变频”，有的甚至加载了50多个档位的变频，其实这种是完全没有意义的。我认为，变频是能在你需要的高频的时候快速进入高频状态，在关闭程序后又能很快回到低档位，换句话说，其实只需要三个档位就高了：睿频档，正常频率，以及低频档。</p><ul><li><p>你需要搞清楚自己的cpu型号，并找到、换成与自己cpu型号最接近或者一样的白苹果型号，并且此型号必须带有<code>HWP</code>。一般新的笔记本机型都具有，台式机的话推荐iMac19.1以及Macmini8.1。可查询<a href="https://blog.daliansky.net/A-command-to-teach-you-how-to-confirm-their-own-models-and-how-to-open-the-HWP.html">此帖</a>选取适合的机型。</p></li><li><p>执行如下命令：</p></li></ul><pre><code class="bash">cd ~/desktopmkdir cpucd cpugit clone https://github.com/corpnewt/CPUFriendFriend.gitgit clone https://github.com/acidanthera/CPUFriend.git cp ~/desktop/cpu/CPUFriend/tools/ResourceConverter.sh ~/desktop/cpu/CpuFriendFriend/CPUFriendFriend.command</code></pre><ul><li><p>你会看到如图的命令行，这里1 of 4代表第一段睿频的设置，以此类推，数值越大睿频越高，下面要求你填写的是最低的频率值，你想要低一点的800MHZ就填08，高一点的1300MHZ就填0D（注意大小写）<img src="https://i.loli.net/2020/11/01/cRhHzeEiAQXLSds.png" alt="Screen-Shot-2019-12-09-at-11.28.30-AM.png"></p></li><li><p>填完前两段后，它会要求你填写EPP值，EPP值越低，性能表现越强。我们是填的前两段的低频率部分，我们可以选择节能型的，比如0x80，如果你想极致性能，可以填0x00。<br><img src="https://i.loli.net/2020/11/01/6p4iKMAeIHPyfBC.png" alt="Screen-Shot-2019-12-09-at-11.32.38-AM.png"></p></li><li><p>直至你填完所有4段变频需求后，便会生成你的变频plist。我们执行以下命令:</p></li></ul><pre><code class="bash">cp ~/Desktop/cpu/CpuFriendFriend/Results/*.* ~/Desktop/cpu</code></pre><ul><li>我们会在桌面的CPU文件夹中找到你所需要的<code>ResourceConverter.sh</code>以及Mac-xxxxxxx.plist两个文件</li><li>执行以下命令生成你最终需要的<code>CPUFriendDataProvider.kext</code>,注意命令行中<code>Mac-AA95B1DDAB278B95.plist</code>，请替换成你自己的文件名，这样我们就可以在桌面的CPU文件夹下拿到<code>CPUFriendDataProvider.kext</code>。</li></ul><pre><code class="bash">cd ~/Desktop/cpu./ResourceConverter.sh --kext ~/Desktop/cpu/Mac-AA95B1DDAB278B95.plist</code></pre><ul><li><p>我们再到CPUFriend的<a href="https://github.com/acidanthera/CPUFriend/releases">release</a>页面下，下载最新的release版本，得到里面的CPUFriend.kext</p></li><li><p>将<code>CPUFriendDataProvider.kext</code>与<code>CPUFriend.kext</code>一起放到oc/kexts下,并在config中加载，注意：<code>CPUFriend.kext</code>应该放在<code>CPUFriendDataProvider.kext</code>的前面。</p></li><li><p>感谢 @请叫我官人 的帮助。完成，自行测试。</p></li></ul><hr><h3 id="4-2-5700-XT-Redeon-VII显卡的性能优化"><a href="#4-2-5700-XT-Redeon-VII显卡的性能优化" class="headerlink" title="4.2 5700/XT/Redeon VII显卡的性能优化"></a>4.2 5700/XT/Redeon VII显卡的性能优化</h3><p>此教程已经发于pcbeta:<a href="http://bbs.pcbeta.com/viewthread-1836920-1-1.html">点此直达</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Opencore引导的相关设置，无聊更新，慢更。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/categories/Hackintosh/"/>
    
    
    <category term="OpenCore" scheme="https://blog.xjn819.com/tags/OpenCore/"/>
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/tags/Hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>RTC综述</title>
    <link href="https://blog.xjn819.com/post/rtc-issues-related-to-oc.html"/>
    <id>https://blog.xjn819.com/post/rtc-issues-related-to-oc.html</id>
    <published>2020-10-01T14:27:50.000Z</published>
    <updated>2020-11-01T19:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章试图教育用户解决RTC(CMOS)记忆体相关的错误导致无法开机，卡F1，无法关机，时钟停止，无法唤醒等问题。此文章为《使用OpenCore引导黑苹果》的补充内容，因原文中RTC相关内容较为散乱，而特意补充。</p><hr><blockquote><p>特别提醒：在使用以下方式修复rtc的过程之前，强烈建议先短接主板CMOS以及清除NVRAM后再进行操作！NVRAM和CMOS存储位置不同，请确定两件事都做了！！</p></blockquote><hr><h2 id="RTC的问题表现"><a href="#RTC的问题表现" class="headerlink" title="RTC的问题表现"></a>RTC的问题表现</h2><ul><li>华硕等主板开机卡F1</li><li>开机卡在PCI Configuration代码处</li><li>睡眠后唤醒奔溃，得到的错误报告为：Sleep Wake Failure in EFI</li><li>无法关机</li><li>电脑时钟不走，或者睡眠唤醒后时钟不走</li></ul><hr><h2 id="RTC如何工作"><a href="#RTC如何工作" class="headerlink" title="RTC如何工作"></a>RTC如何工作</h2><p>RTC为l2c下的从设备，rtc为系统提供时间，电源，硬件信息等指示数据，l2c主动联系从设备rtc获取信息，反馈给系统。这些信息都被注册在rtc的各个内存位置上，这些内存地址对应的数据可通过OC-liilte或者搜索自己主板型号的intel datasheet获得。</p><blockquote><p>举例：<br>系统设定一个自动关机的时间，比如22:20分，此信息通过系统trigger到rtc，l2c扫到rtc信息，则自动关机。</p></blockquote><hr><h2 id="苹果系统下RTC的问题如何产生？"><a href="#苹果系统下RTC的问题如何产生？" class="headerlink" title="苹果系统下RTC的问题如何产生？"></a>苹果系统下RTC的问题如何产生？</h2><p>问题主要是因为Apple。</p><ul><li>Apple公司使用自己定义的Apple RTC，而普通主板可能引用了最新的AWAC装置来代替传统RTC而导致无法开机。</li><li>Apple公司使用自己定义的Apple RTC，Apple RTC记录的内存范围可能不被我们普通的主板所支持，超出了我们普通主板0x70-0x78范围而导致了错误。</li></ul><hr><h2 id="如何解决上述问题"><a href="#如何解决上述问题" class="headerlink" title="如何解决上述问题"></a>如何解决上述问题</h2><p>对于《苹果系统下RTC的问题如何产生？》，第一个问题是这样的：一些具有AWAC的设备我们可能需要禁用AWAC来启用Legacy RTC。这里可通过<a href="https://github.com/daliansky/OC-little/tree/master/03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9B%B4%E5%90%8D%E4%B8%8E%E9%A2%84%E7%BD%AE%E5%8F%98%E9%87%8F/%E8%A1%A5%E4%B8%81%E5%BA%93">OC-Little</a>包中的禁用AWAC来实现。其中SSDT-AWAC.dsl更适用于主板DSDT代码特别多的主板，请根据情况二选一并转换成aml后使用。</p><hr><p>对于第二个问题，它可能带来的影响包括时钟不走，关机不断电，开机卡f1，无法唤醒，唤醒崩溃等。这种问题就像我之前说的，是因为apple rtc写入到了普通主板rtc不支持的范围而导致的。</p><p>我之前在主文章有写到通过<a href="https://github.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/blob/master/config_parts/config_master.plist#L291L296">二进制补丁</a>来解决开机卡F1，但这种方式其实是不妥当的，这是因为：</p><ul><li>这种补丁会因为系统版本的更新而失效</li><li>并不能控制Efiboot来写入RTC</li><li>卡F1的因素过多，而二进制补丁不可能具有通用性</li></ul><p>因此，OC团队提供了三种方式来更好的解决RTC引起的各种问题。</p><ul><li><p>提供DisableRtcChecksum选项来忽略RTC地址中的0x58-0x59范围。但遗憾的是此quirk只适用于0x58-0x59地址损坏的rtc情况，并不具备通用性。</p></li><li><p>ACDT团队提供了<a href="https://github.com/acidanthera/RTCMemoryFixup/releases">RTCMemoryFixup.kext</a>让用户可以自主选择所有你想屏蔽的地址。此kext需要用二分法来使用。</p></li><li><p>将此kext放入OC/Kexts下面，并在config中加载它。</p></li><li><p>一般来说，我们CMOS的总内存池是从00-FF（这个是16进制，换算成10进制就是从0-255)，我们可以通过增加boot-args:rtcfx_exclude=00-FF来完全屏蔽cmos（当然这样写你完全失去了cmos记忆的功能了）</p></li><li><p>我们需要通过二分法来定位你出错的cmos位置。把00-FF分成两部分，也就是00-7F以及80-FF。我们分别填一次rtcfx_exclude=00-7F以及rtcfx_exclude=80-FF，试试看问题有没有解决。比如说我使用的rtcfx_exclude=80-FF是解决了，那我们继续对80-FF进行拆分为：0x80-0xBF 和 0xC0-0xFF。以此类推，直到你拆分到最后的那一段位置为止。</p></li><li><p>ACDT团队提供了写入NVRAM的方式来屏蔽RTC地址。如图，RTC-blacklist中 8586878889 代表屏蔽85 86 87 89的RTC地址，如果屏蔽85以及86则填写8586。注16进制。      <br><img src="https://i.loli.net/2020/11/02/4SjaDbtdNivyOVA.png" alt="rtc-blacklist.png"></p></li></ul><hr><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>有两个非常特殊的情况：</p><ul><li>一些主板本身的DSDT就把RTC的地址写错了，我们需要更正。比如，华硕299的主板没有对rtc的0x72以及0x73进行映射，源dsdt中的资源分配如下代码。0x70只加到了0x72之前，从0x74位开始加到了0x78之前，也就是0x72以及0x73被忽略。因此需要官方的ssdt对rtc的资源进行重新分配</li></ul><pre><code class="asl">Device (RTC)&#123;    Name (_HID, EisaId (&quot;PNP0B00&quot;) /* AT Real-Time Clock */)  // _HID: Hardware ID    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings    &#123;        IO (Decode16,            0x0070,             // Range Minimum            0x0070,             // Range Maximum            0x01,               // Alignment            0x02,               // Length            )        IO (Decode16,            0x0074,             // Range Minimum            0x0074,             // Range Maximum            0x01,               // Alignment            0x04,               // Length            )        IRQNoFlags ()            &#123;8&#125;    &#125;)</code></pre><ul><li>Smbus是一种可能已经被淘汰的总线方式，此部件在很多新的机型中已经不再被需要。但经证实在过往的一些mac版本中需要激活它才能进入睡眠唤醒，这是一种很奇怪的现象，但是一般来说此补丁不该被需要。请注意原文中的<code>0x57</code>应该根据自己的主板来决定。比如我的x299主板应该搜索<code>x299 intel datasheet</code>，获得自己主板的<code>datasheet</code>后，得知自己Smbus串口的位置为<code>0xc6</code>，替换原文中的所有<code>0x57</code>为<code>0xc6</code>。此SSDT应只用于debug。</li></ul><pre><code class="asl">/* * SMBus compatibility table. */DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;ACDT&quot;, &quot;MCHCSBUS&quot;, 0x00000000)&#123;    External (_SB_.PCI0, DeviceObj)    External (_SB_.PCI0.SBUS, DeviceObj)    Scope (_SB.PCI0)    &#123;        Device (MCHC)        &#123;            Name (_ADR, Zero)  // _ADR: Address            Method (_STA, 0, NotSerialized)  // _STA: Status            &#123;                If (_OSI (&quot;Darwin&quot;))                &#123;                    Return (0x0F)                &#125;                Else                &#123;                    Return (Zero)                &#125;            &#125;        &#125;    &#125;    Device (_SB.PCI0.SBUS.BUS0)    &#123;        Name (_CID, &quot;smbus&quot;)  // _CID: Compatible ID        Name (_ADR, Zero)  // _ADR: Address        Device (DVL0)        &#123;            Name (_ADR, 0x57)  // _ADR: Address            Name (_CID, &quot;diagsvault&quot;)  // _CID: Compatible ID            Method (_DSM, 4, NotSerialized)  // _DSM: Device-Specific Method            &#123;                If (!Arg2)                &#123;                    Return (Buffer (One)                    &#123;                         0x57                                             // W                    &#125;)                &#125;                Return (Package (0x02)                &#123;                    &quot;address&quot;,                     0x57                &#125;)            &#125;        &#125;        Method (_STA, 0, NotSerialized)  // _STA: Status        &#123;            If (_OSI (&quot;Darwin&quot;))            &#123;                Return (0x0F)            &#125;            Else            &#123;                Return (Zero)            &#125;        &#125;    &#125;    Method (DTGP, 5, NotSerialized)    &#123;        If ((Arg0 == ToUUID (&quot;a0b5b7c6-1318-441c-b0c9-fe695eaf949b&quot;)))        &#123;            If ((Arg1 == One))            &#123;                If ((Arg2 == Zero))                &#123;                    Arg4 = Buffer (One)                        &#123;                             0x03                                             // .                        &#125;                    Return (One)                &#125;                If ((Arg2 == One))                &#123;                    Return (One)                &#125;            &#125;        &#125;        Arg4 = Buffer (One)            &#123;                 0x00                                             // .            &#125;        Return (Zero)    &#125;&#125;</code></pre><hr><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><p>Dortania Team, (2020).,<Fixing RTC write issues>. available at: <a href="https://dortania.github.io/OpenCore-Post-Install/misc/rtc.html#finding-our-bad-rtc-region">https://dortania.github.io/OpenCore-Post-Install/misc/rtc.html#finding-our-bad-rtc-region</a>, last accessed at 10 Oct 2020.</p></li><li><p>OC little, (2020)., &lt;03-二进制更名与预置变量&gt;. available at:<a href="https://github.com/daliansky/OC-little/tree/master/03-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9B%B4%E5%90%8D%E4%B8%8E%E9%A2%84%E7%BD%AE%E5%8F%98%E9%87%8F">https://github.com/daliansky/OC-little/tree/master/03-二进制更名与预置变量</a>, last accessed at 10 Oct 2020.</p></li><li><p>Acidanthera (2020)., <AcpiSamples> available at: <a href="https://github.com/acidanthera/OpenCorePkg/tree/master/Docs/AcpiSamples">https://github.com/acidanthera/OpenCorePkg/tree/master/Docs/AcpiSamples</a> , last accessed at 10 Oct 2020.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章试图教育用户解决RTC(CMOS)记忆体相关的错误导致无法开机，卡F1，无法关机，时钟停止，无法唤醒等问题。此文章为《使用OpenCore引导黑苹果》的补充内容，因原文中RTC相关内容较为散乱，而特意补充。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;特别提醒</summary>
      
    
    
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/categories/Hackintosh/"/>
    
    
    <category term="OpenCore" scheme="https://blog.xjn819.com/tags/OpenCore/"/>
    
    <category term="Hackintosh" scheme="https://blog.xjn819.com/tags/Hackintosh/"/>
    
  </entry>
  
</feed>
