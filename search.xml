<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="undefined/undefined.html"/>
      <url>undefined/undefined.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 OpenCore 引导黑苹果</title>
      <link href="post/543.html"/>
      <url>post/543.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenCore(OC)是一种新的引导方式，越来越多的kexts开始放弃Clover, 我相信提早使用OC会对你未来使用黑苹果会有很大的帮助。这是一个自然的现象，就像变色龙被Clover淘汰，而现在OC代替Clover也是大势所趋。你应该需要看一些相关的文章，来帮助你理解我的正文内容，同时也需要下载我推荐的软件：</p><hr><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p><a href="https://khronokernel-2.gitbook.io/opencore-vanilla-desktop-guide/">Opencore Vanilla Desktop Guide</a></p><p><a href="https://github.com/khronokernel/Getting-Started-With-OpenCore">Getting Started With OpenCore</a></p><p><a href="https://blog.daliansky.net/OpenCore-BootLoader.html">精解OpenCore</a></p><hr><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>Xcode （从app store或其他地方下载，强烈建议使用v10版本的xcode，v11花里胡哨已经劝退=。=)</p><p><a href="https://github.com/corpnewt/ProperTree">ProperTree</a>最新推荐的config编辑器</p><p><a href="https://github.com/williambj1/OpenCore-Factory/releases">OpenCore</a> (由BAT维护的每日工厂版，尝鲜用户可以下载这个)</p><p><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenCore</a>（官方稳定版本）</p><p><a href="http://headsoft.com.au/download/mac/Hackintool.zip">Hackintool</a></p><p><a href="http://blog.xjn819.com/wp-content/uploads/2019/10/MaciASL.zip">MaciASL</a></p><p><a href="https://github.com/daliansky/OC-little">宪武大大oc部件</a></p><p><a href="https://github.com/acidanthera/gfxutil/releases">gfxutil</a> </p><hr><h2 id="更新日记"><a href="#更新日记" class="headerlink" title="更新日记"></a>更新日记</h2><details>  <summary><font color=red>点击查询帖子最近更新</font></summary><p>2020-10-14:</p><p>1.Opencore 0.6.2正式版修改如下variables:</p><p>增加ExtendBTFeatureFlags （章节2.4.6）<br>移除DummyPowerManagement（章节2.4.6）<br>增加LegacyCommpage（章节2.4.6）<br>增加SystemMemoryStatus （章节2.7.2）<br>增加ProcessorType（章节2.7.2）</p><p>2020-09-11:</p><p>1.Opencore 0.6.1正式版新增如下variables：</p><p>Force （章节2.4.4）<br>DisableLinkeditJettison （章节2.4.6）<br>Scheme （章节2.4.7）<br>Security下新增内`容（章节2.5.5）<br>AppleImg4Verification （章节2.8.5）<br>AppleSecureBoot（章节2.8.5）</p><p>2.考虑到稳定性，提供官方的Opencore稳定版链接，同时注明BAT的工厂版链接。感谢BAT一直以来提供的稳定持久的编译服务。</p><p>2020-07-23:</p><p>1.大家似乎对macos 11的测试版有点急迫，我这里半路更新Opencore0.60的内容。</p><p>2.增加ProvideMaxSlide （章节2.2.2）</p><p>3.增加GlobalConnect （章节2.8.8）</p><p>4.增加AppleFramebufferInfo （章节2.8.5）</p><p>5.增加UgaPassThrough （章节2.8.4）</p><p>6.删除BlacklistAppleUpdate （章节2.5.5）</p><p>7.增加boot-args:vsmcgen=1 用以暴露smc来安装macOS 11（章节2.6.1）</p><p>8.增加以及修改3.8.1/3.8.2/3.11.1章节讨论关于rtc的问题，以便于安装MacOS 11。</p><p>9.修改章节3.9关于核心显卡加速。</p></details><hr><h1 id="0-0-BIOS设置"><a href="#0-0-BIOS设置" class="headerlink" title="0.0 BIOS设置"></a>0.0 BIOS设置</h1><p>直接抄袭@BAT了</p><ul><li><strong>禁用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">Fast Boot</td><td align="center">快速启动</td></tr><tr><td align="center">CFG Lock (MSR 0xE2 write protection)</td><td align="center">CFG 锁 (MSR 0xE2 写入保护)</td></tr><tr><td align="center">VT-d</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-d</a></td></tr><tr><td align="center">CSM</td><td align="center">兼容性支持模块</td></tr><tr><td align="center">Intel SGX</td><td align="center">Intel SGX</td></tr></tbody></table><hr><ul><li><strong>启用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">VT-x</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-x</a></td></tr><tr><td align="center">Above 4G decoding</td><td align="center">大于 4G 地址空间解码</td></tr><tr><td align="center">Hyper Threading</td><td align="center">处理器超线程</td></tr><tr><td align="center">Execute Disable Bit</td><td align="center">执行禁止位</td></tr><tr><td align="center">EHCI/XHCI Hand-off</td><td align="center">接手 EHCI/XHCI 控制</td></tr><tr><td align="center">OS type: Windows 8.1/10</td><td align="center">操作系统类型: Windows 8.1/10</td></tr><tr><td align="center">Legacy RTC Device</td><td align="center">传统 RTC 设备</td></tr></tbody></table><blockquote><p>将 操作系统类型设置为 <code>Windows 8.1/10</code> 是因为部分主板在 <code>Other</code> 模式下会将系统认作是 Windows 7 从而禁用 UEFI 的某些功能并开启 CSM, 200 系及以后的主板理论上不存在这个问题</p></blockquote><hr><h1 id="1-0-整理OPENCORE目录"><a href="#1-0-整理OPENCORE目录" class="headerlink" title="1.0 整理OPENCORE目录"></a>1.0 整理OPENCORE目录</h1><p>打开下载好的最新版OC，把Doc文件夹下面的Sample.plist改名为config.plist，并把此文件移动到EFI目录下面。<br>打开EFI—Kexts，我们把常用的一些kexts先放进去，一般情况下你需要放如下Kexts:</p><p>Lilu.kext    Acidanthera驱动全家桶的SDK</p><p>Applealc.kext   声卡驱动/下载地址</p><p>VirtualSMC.kext    传感器驱动依赖 </p><p>SMCProcessor.kext   CPU核传感器</p><p>SMCSuperIO.kext    IO传感器         </p><p>WhateverGreen.kext 显卡驱动</p><p>IntelMausi.kext  Intel类千兆网卡驱动</p><p>Usbinjectall.kext  USB驱动 （你也可以定制自己的USB补丁）<br>               <br>NVMeFix.kext      为NVME硬盘增加ASPT属性来保证节电，虽然对台式机没啥用，但是官方推荐所有NVME用户都使用此补丁</p><blockquote><p>一些机型用了1820A,1560,1830等网卡，需要自己放对应驱动；有线螃蟹卡也自己放一下驱动；笔记本类需要更多传感器的，请自行补齐VirtualSMC的那些传感器补丁</p></blockquote><hr><h1 id="2-0-Config-plist-修改"><a href="#2-0-Config-plist-修改" class="headerlink" title="2.0 Config.plist 修改"></a>2.0 Config.plist 修改</h1><p>这章会把config的项目分开来，内容繁琐，为了让小白明白各个选项的用途。当然有能力的人可以直接看我最前面的几个链接来配置config.plist。我这里强制要求你使用<code>Propertree</code>来编辑Config.plist，其他的任何软件我都不建议使用。</p><hr><h2 id="2-1-Config—–ACPI"><a href="#2-1-Config—–ACPI" class="headerlink" title="2.1 Config—–ACPI"></a>2.1 Config—–ACPI</h2><p>ACPI包括了四个部分：Add, Block, Patch, Quirks。这里我们先把root下面的几条#WARNING删除，这几条没有实际意义。</p><hr><h3 id="2-1-1-Config—–ACPI—–Add"><a href="#2-1-1-Config—–ACPI—–Add" class="headerlink" title="2.1.1  Config—–ACPI—–Add"></a>2.1.1  Config—–ACPI—–Add</h3><p>这部分主要填写我们使用的SSDT以及DSDT文件，如果没有请把0-8的ssdt全部删除。如果你有修改的SSDT或者DSDT文件，请先将文件放入EFI/OC/ACPI下。</p><p>因为我使用雷电卡，我需要添加两条关于雷电卡的ssdt文件：</p><pre><code class="bash">Item 0 Comment    String       Thunderbolt3-DTGP //填一个你自己能辨别的名字，方便知道是啥 Enable     Boolean      YES //表示加载此SSDT，反之NO则为不加载Path       String       SSDT-DTGP.aml //为你ssdt放在EFI/OC/ACPI下的文件名，必须一致Item 1 Comment    String       Thunderbolt3Enable     Boolean      YES Path       String       SSDT-TB3.aml</code></pre><hr><h3 id="2-1-2-Config—–ACPI—–Delete"><a href="#2-1-2-Config—–ACPI—–Delete" class="headerlink" title="2.1.2  Config—–ACPI—–Delete"></a>2.1.2  Config—–ACPI—–Delete</h3><p>这个目录下是禁用一些SSDT/DSDT，没什么用，我把下面的item全都删了。</p><hr><h3 id="2-1-3-Config—–ACPI—–Patch"><a href="#2-1-3-Config—–ACPI—–Patch" class="headerlink" title="2.1.3  Config—–ACPI—–Patch"></a>2.1.3  Config—–ACPI—–Patch</h3><p>这里我们需要填写一下热补丁。</p><ul><li>10.15及以上系统，<a href="https://blog.daliansky.net/Common-problems-and-solutions-in-macOS-Catalina-10.15-installation.html">一些资料</a>指出我们需要把EC控制器(EC0)改名为EC来确保能进入10.15系统</li></ul><pre><code class="bash">Comment: EC0 to EC Count:0 Enabled:YES Find:&lt;4543305F&gt; Limit:0 Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;45435F5F&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><blockquote><p>一些主板的EC控制器名字可能会叫H_EC等，请自行提取DSDT并搜索PNP0C09，来获取EC控制器的名字，这些内容会在第三章中写出。</p></blockquote><hr><ul><li>华擎、华硕、微星主板可能会遇到采用新的AWAC时钟而无法进入系统，这同样需要添加hotpatch补丁来解决：</li></ul><pre><code class="bash">Comment: RTC fix Count:0 Enabled:YES Find:&lt;A00A9353 54415301&gt; Limit:0Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;A00A910A FF0BFFFF&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><hr><h3 id="2-1-4-Config—–ACPI—–Quirks"><a href="#2-1-4-Config—–ACPI—–Quirks" class="headerlink" title="2.1.4  Config—–ACPI—–Quirks"></a>2.1.4  Config—–ACPI—–Quirks</h3><p>此目录下有五项，选择与解释如下：</p><ul><li><strong>FadtEnableReset:</strong> <code>NO</code><ul><li>旧的主板需要对FADT进行标记来激活电脑的开机和关机功能，这里我们不许要启动它</li></ul></li><li><strong>NormalizeHeaders:</strong> <code>NO</code><ul><li>清理ACPI头，一些主板的ACPI表需要打开这个修复10.13系统的启动。</li></ul></li><li><strong>RebaseRegions:</strong> <code>YES</code><ul><li>尝试试探性地重新定位 ACPI 内存区域, <strong>使用自定义 DSDT 则必须开启</strong></li></ul></li><li><strong>ResetHwSig:</strong> <code>NO</code><ul><li>存在重新启动后因无法维持硬件签名而导致从休眠中唤醒的问题的硬件需要开启</li></ul></li><li><strong>ResetLogoStatus:</strong> <code>NO</code><ul><li>无法在有 <code>BGRT</code> 表的系统上显示 OEM Windows 标志的硬件需要开启</li></ul></li></ul><hr><h2 id="2-2-Config—–Booter"><a href="#2-2-Config—–Booter" class="headerlink" title="2.2 Config—–Booter"></a>2.2 Config—–Booter</h2><p>内存相关选项设置。</p><hr><h3 id="2-2-1-Config—Boot—MmioWhitelist"><a href="#2-2-1-Config—Boot—MmioWhitelist" class="headerlink" title="2.2.1 Config—Boot—MmioWhitelist"></a>2.2.1 Config—Boot—MmioWhitelist</h3><ul><li><p>默认的第一项是为Haswell芯片提供的内存寻址修复，如果此类芯片碰到内存相关问题，请开启它(enable选择yes)。</p></li><li><p>默认第二项是开机卡PCI Configuration这里。ACPI、PCI device同时释放到内存时发生0x1000内存地址被占用而卡在PCI Configration.如果碰到此类问题，请开启它。</p></li></ul><hr><h3 id="2-2-2-Config—Boot—Quirks"><a href="#2-2-2-Config—Boot—Quirks" class="headerlink" title="2.2.2 Config—Boot—Quirks"></a>2.2.2 Config—Boot—Quirks</h3><p>此项与OpenRuntime.efi有关。在aptiomemoryfix停更后，此补丁已经更名为Openruntime, 并将一些功能与OC合并、模块化。对于无法原生nvram的主板来说，这里的选项需要格外注意。当然我也会把像300/400系列、x299、c422这样支持原生nvram的选择方法一并写进去。</p><ul><li><strong>AvoidRuntimeDefrag:</strong> <code>YES</code><ul><li>大部分UEFI都会写入时间、电源管理等信息，这个所有黑苹果主板都应该选择YES。</li></ul></li></ul><ul><li><strong>DevirtualiseMmio:</strong> <code>YES</code> <ul><li>内存注入方式包括KASLR方式(分布式注射到各个内存地址中）以及连续性方式。在使用KASLR时，PCIE加载到内存，可能会占据所有avaliable值而影响OC的内核以及内核缓存无法注入，导致启动失败。此项目前建议选择YES，并且在下一项ProtectUefiServices中也选择yes。</li></ul></li></ul><blockquote><p>KASLR是更加高效的内存注入方式，但不代表每台机器都能使用这种方案，这里我提供两种关于内存的设置：<br>1：<code>DevirtualiseMmio</code>选择yes, <code>ProtectUefiServices</code>选择yes, 并删除2.6.1中boot-args里面的<code>slide=1</code>,以及删除Drivers文件夹下的<code>Memoryallocations.efi</code>。即开启KASLR内存注入方式。<br>2：<code>DevirtualiseMmio</code>选择yes, <code>ProtectUefiServices</code>选择no, 保留2.6.1中boot-args里面的<code>slide=1</code>,以及保留Drivers文件夹下的<code>Memoryallocations.efi</code>。即开启连续性内存注入方式。</p></blockquote><ul><li><p><strong>DisableSingleUser:</strong> <code>NO</code> </p><ul><li>这里关乎主机是否能开启单用户模式。什么是单用户模式，请看<a href="https://support.apple.com/zh-cn/HT201573">此文章</a>。</li></ul></li><li><p><strong>DisableVariableWrite:</strong> </p><ul><li>非原生NVRAM主板需要模拟nvram.plist进而写入variable值，因此我们要禁止此项来防止其他程序对nvram进行写入，我们这里选YES。需要注意一点，如果你的主板支持原生nvram，请选择NO！</li></ul></li><li><p><strong>DiscardHibernateMap:</strong> <code>NO</code> </p><ul><li>电脑从休眠(hibernation)中唤醒时,硬盘里的资料会恢复到内存中去，但这个时候OC的内核以及内核缓存等也会写入，这样可能导致冲突，这个选项是帮助我们解决这个问题的。而目前来看，除了原生NVRAM都无法进行休眠（注意睡眠sleep和休眠hibernation是两个概念），台式机的话就更不需要休眠功能了，这里我选择NO。这里我们也不讨论如何休眠。</li></ul></li><li><p><strong>EnableSafeModeSlide:</strong> <code>YES</code> </p><ul><li>安全模式下是否启用连续性的内存注入方式。我就选择YES，与正常情况下保持一致。</li></ul></li><li><p><strong>EnableWriteUnprotector:</strong> <code>YES</code> </p><ul><li>保证nvram能正常写入而不受到CR0寄存器的写入保护影响。</li></ul></li><li><p><strong>ForceExitBootServices:</strong> <code>NO</code> </p><ul><li>这个选项是让那些非常老旧的主板也能使用内存寻址，正常情况下选NO。</li></ul></li><li><p><strong>ProtectMemoryRegions:</strong> <code>NO</code> </p><ul><li>官方对此项目的解释与AvoidRuntimeDefrag类似，除非你明白这是什么，不然选择NO，其实我也不明白。</li></ul></li><li><p><strong>ProtectSecureBoot:</strong> <code>NO</code> </p><ul><li>保护安全启动，除非你开启安全启动，不然我们选择NO。</li></ul></li><li><p><strong>ProtectUefiServices:</strong> <code>NO</code> </p><ul><li>解决Z390系列主板卡开机卡++++的问题，这个功能从字面意思是与我提供的memoryallocation.efi功能类似。</li></ul></li><li><p><strong>ProvideCustomSlide:</strong> <code>YES</code> </p><ul><li>此选项执行固件的内存映射分析并检查所有的 slide 值(1 - 255)是否可用。由于 boot.efi 生成的这个值是利用 rdrand 指令随机生成的或者伪随机指令 rdtsc 随机生成的，因此当其选择了 一个冲突的 slide 值时有可能启动失败。由于这种潜在的冲突存在，此选项强制 macOS 在可用的值中使用一个伪随机值，这也确保了 slide= 启动参数不会因为安全原因传递给操作系统。<br>是否需要此选项由信息 OCABC (Only N/256 slide values are usable!) 是否存在于调试日 志中决定。如果存在此信息，则需要启用此 Quriks 选项。我选择YES。如果你对KASLR有一定的认知并会运用，请注意这个值。内容从@套陆 摘抄。</li></ul></li><li><p><strong>ProvideMaxSlide:</strong> </p><ul><li>如果你没有启用KASLR的话，请填写1-255之间的数字以存放休眠文件写进内存所需要的内存高度，反之则填写0。</li></ul></li><li><p><strong>RebuildAppleMemoryMap:</strong> <code>NO</code> </p><ul><li>重新生成内存地图来匹配苹果系统。苹果的内核有很多缺陷，比如单张的内存地图不能超过4K，一旦超过就可能无法开机；又比如一些硬件会直接把读写权限写进内存里，而苹果却不能给与写入权限。如果你遇到此类的问题，请尝试开启它。注意此项目与EnableWriteUnprotector存在冲突关系，确保开启这个的时候，另一个是关闭的。另外，此项又需要与SyncRuntimePermissions项搭配使用。一般情况下请选择NO。</li></ul></li><li><p><strong>SetupVirtualMap:</strong> <code>YES</code> </p><ul><li>是否建立虚拟内存并对物理内存进行映射。我们在开机时，OC的程序需要一块连续性的内存进行存放内核等东西，而实际的物理内存一般都是分散的。因此，我们通过虚拟内存建立连续性内存供OC使用，并映射到分散的物理内存中。这里我们选择YES。</li></ul></li><li><p><strong>SignalAppleOS:</strong> <code>NO</code> </p><ul><li>通知同一台电脑上的设备mac上的硬件选择，此项是给白苹果用的。</li></ul></li></ul><ul><li><strong>SyncRuntimePermissions:</strong> <code>YES</code> <ul><li>修正硬件在注入内存时无法注入权限的问题。一般此类问题存在2018年后的主板。如果你因为此选项无法进入windows，请开启它。</li></ul></li></ul><hr><h2 id="2-3-Config—–DeviceProperties"><a href="#2-3-Config—–DeviceProperties" class="headerlink" title="2.3 Config—–DeviceProperties"></a>2.3 Config—–DeviceProperties</h2><p>此项是用来注入你的设备的，主要是显卡和声卡两部分。同样你也可以定制一些设备到你的关于本机–系统报告–PCI列表中，尽管没有多大的意义。</p><h3 id="2-3-1-声卡"><a href="#2-3-1-声卡" class="headerlink" title="2.3.1  声卡"></a>2.3.1  声卡</h3><p>这里首先我们需要确认自己的声卡驱动已经被加载，终端下输入：</p><pre><code class="bash">kextstat | grep -E &quot;AppleHDA|AppleALC|Lilu&quot;</code></pre><p>我们会得到被加载的驱动，请确保<code>as.vit9696.Lilu</code>；<code>as.vit9696.AppleALC</code>；<code>com.apple.driver.AppleHDAController</code>；<code>com.apple.driver.AppleHDA</code>已经被加载。</p><p>找自己声卡的地址，准备好在文章开头要求下载的gfxutil，将gfxutil程序放在桌面，输入:</p><pre><code class="bash">~/desktop/gfxutil -f HDEF //一般来说我们在使用Applealc后，板载声卡的部件名都叫HDEF</code></pre><p>我们输入后会得到声卡的PCI路径，比如我输出的就是：</p><pre><code class="bash">00:1f.3 8086:a2f0 /PC00@0/HDEF@1F,3 = PciRoot(0x0)/Pci(0x1F,0x3)</code></pre><p>这里我们找到的声卡PCI路径为PciRoot(0x0)/Pci(0x1f,0x3)。我们把预先填写在那里的PciRoot(0x0)/Pci(0x1b,0x0)项替换成我们真正的声卡路径。</p><p>后面一段我们看到预先填写的声卡ID为&lt;01000000&gt;，这里我们需要把它换成合适自己声卡的ID，输入以下命令得到自己声卡的CodecID。</p><pre><code class="bash">ioreg -l|grep IOHDACodecVendorID</code></pre><p>点击<a href="https://github.com/acidanthera/gfxutil/releases">此页面</a>搜索刚得到的CodecID就可查询到自己声卡的型号名称，以及可用的LayoutID。</p><p>比如我的CodecID为<code>283906408</code>，声卡型号<code>ALCS1220A</code>，对应1, 2, 3, 5, 7, 11, 13, 15, 16, 27, 28, 29, 34的layout ID。我们需要一个个测试过去，选定自己能用的。这里我们选择7这个ID进行测试，将7转化成16进制格式为07，后面为了满足格式要求添加6个0，则为07000000，将这个值替换刚才预先填的01000000中；如果我们测试ID为27，27的16进制为1b，补上6个0则为1b000000。</p><pre><code class="bash">PciRoot(0x0)/Pci(0x1f,0x3)         device-id       data      &lt;70a10000&gt; //一般情况下这段是不需要填写的，除非你的声卡需要仿冒        layout-id       data      &lt;0b000000&gt; //这个Layout id我瞎写的，你按实际情况写</code></pre><p>如果你测试的ID都无效，请确保你的操作过程正确、并测试用万能声卡(VoodooHDA)补丁来替换AppleALC这个补丁。如果都不行，你可能需要自行<a href="https://blog.daliansky.net/Use-AppleALC-sound-card-to-drive-the-correct-posture-of-AppleHDA.html">编译声卡补丁</a>。</p><hr><h3 id="2-3-2-核心显卡"><a href="#2-3-2-核心显卡" class="headerlink" title="2.3.2  核心显卡"></a>2.3.2  核心显卡</h3><p>打开PciRoot(0x0)/Pci(0x2,0x0)这项，此项为驱动核心显卡。驱动核心显卡我们要分情况讨论:1.只有核心显卡的DP显示器用户 (HDMI我会在进阶设置中写）；2.没有核心显卡的用户；3.有核心显卡并用独显做主力的用户。注意，这里我们只讨论8代和9代CPU的机器，其他CPU机型的请在论坛或者<a href="https://blog.daliansky.net/Intel-core-display-platformID-finishing.html">黑果小兵博客</a>中搜索相关代码。</p><hr><h4 id="2-3-2-1-只有核心显卡的DP显示器用户"><a href="#2-3-2-1-只有核心显卡的DP显示器用户" class="headerlink" title="2.3.2.1 只有核心显卡的DP显示器用户"></a>2.3.2.1 只有核心显卡的DP显示器用户</h4><p>8代和9代的核显ID为:3E9b0007，device ID为3e9b0000，但是我们需要符合苹果的倒叙格式填入：</p><pre><code class="bash">AAPL,ig-platform-id        data        &lt;07009b3e&gt; device-id                  data        &lt;9b3e0000&gt;framebuffer-unifiedmem     data        &lt;00000080&gt;      //核显显存相关</code></pre><hr><h4 id="2-3-2-2-没核心显卡的用户"><a href="#2-3-2-2-没核心显卡的用户" class="headerlink" title="2.3.2.2 没核心显卡的用户"></a>2.3.2.2 没核心显卡的用户</h4><p>带f的cpu (e.g. 9100f 9900kf), Xeon等不带核心显卡的用户不需要管这项，直接把AAPL,ig-platform-id选项卡删了。</p><hr><h4 id="2-3-2-3-有核心显卡并用独显做主力的用户"><a href="#2-3-2-3-有核心显卡并用独显做主力的用户" class="headerlink" title="2.3.2.3 有核心显卡并用独显做主力的用户"></a>2.3.2.3 有核心显卡并用独显做主力的用户</h4><p>这种情况我们一般把核心显卡作为加速用，而显示则用独立显卡。这样，我们填一个作为加速用的核显ID即可了，8代9代10代除外的cpu请搜索黑果小兵的博客：</p><pre><code class="bash">AAPL,ig-platform-id        data        &lt;0300983e&gt;</code></pre><hr><h3 id="2-3-3-Delete"><a href="#2-3-3-Delete" class="headerlink" title="2.3.3 Delete"></a>2.3.3 Delete</h3><p>这里是禁用一些设备的，我们按默认就行了，不需要任何修改。</p><hr><h2 id="2-4-Config—–Kernel"><a href="#2-4-Config—–Kernel" class="headerlink" title="2.4 Config—–Kernel"></a>2.4 Config—–Kernel</h2><p>这里是内核相关选项。</p><hr><h3 id="2-4-1-Config—–Kernel—–Add"><a href="#2-4-1-Config—–Kernel—–Add" class="headerlink" title="2.4.1 Config—–Kernel—–Add"></a>2.4.1 Config—–Kernel—–Add</h3><p>这里我们需要填写kexts的相关资料。值得注意的是OC的kexts填写必须注意顺序，比如applealc的依赖是lilu，那么lilu必须填在第一个；SMCProcessor.kext依赖于Virtualsmc.kext。那virtualsmc必须放在SMCProcessor.kext之前。</p><p>这里默认情况下很多我们需要的补丁已经被加载里面了，但是enabled那块我们要手动改成yes去开启它，把一些不用的删了：</p><pre><code class="bash">Item 0      BundlePath       String         Lilu.kext            //kext的名字       Comment          String                              //你自己填一个注释，可以不填       Enabled          Boolean        YES                  //启动此补丁，反之则为关闭       ExecutablePath   String         Contents/MacOS/Lilu  //通过右键kext显示包内容查找lilu运行文件的真正路径       MaxKernel        String                              //此补丁支持的最大系统版本，填19为10.15，18位10.14；我们一般情况下留空       MinKernel        String                              //此补丁支持的最小系统版本       PlistPath        String         Contents/Info.plist  //kext的plist位置，可以右键kext显示包内容查找正确路径       ............ ...........       ............ ...........Item 7      BundlePath       String         USBPorts.kext       Comment          String             Enabled          Boolean        YES       ExecutablePath   String                              //一些没有执行文件的kext不需要填写      MaxKernel        String       MinKernel        String      PlistPath        String         Contents/Info.plist       ............ ...........       ............ ...........</code></pre><hr><h3 id="2-4-2-Config—–Kernel—–Block"><a href="#2-4-2-Config—–Kernel—–Block" class="headerlink" title="2.4.2 Config—–Kernel—–Block"></a>2.4.2 Config—–Kernel—–Block</h3><p>禁用一些kexts，这里好像没啥用，不用理会。</p><hr><h3 id="2-4-3-Config—–Kernel—–Emulate"><a href="#2-4-3-Config—–Kernel—–Emulate" class="headerlink" title="2.4.3 Config—–Kernel—–Emulate"></a>2.4.3 Config—–Kernel—–Emulate</h3><p>此选项帮助Ivy Bridge 和一些不受支持的CPU加载电源管理的，我们这里不做此方面讨论。所有选项按默认即可。</p><hr><h3 id="2-4-4-Config—–Kernel—–Force"><a href="#2-4-4-Config—–Kernel—–Force" class="headerlink" title="2.4.4 Config—–Kernel—–Force"></a>2.4.4 Config—–Kernel—–Force</h3><p>特殊情况下我们需要强制加载某一些kext来达到某种目的，一般我们不理会此项。</p><hr><h3 id="2-4-5-Config—–Kernel—–Patch"><a href="#2-4-5-Config—–Kernel—–Patch" class="headerlink" title="2.4.5 Config—–Kernel—–Patch"></a>2.4.5 Config—–Kernel—–Patch</h3><p>这里是为内核打补丁用的，我会在进阶教程中详细写一下这一块。尤其是rtc相关的内容，我都会写进第三章的进阶教程。</p><hr><h3 id="2-4-6-Config—–Kernel—–Quirks"><a href="#2-4-6-Config—–Kernel—–Quirks" class="headerlink" title="2.4.6 Config—–Kernel—–Quirks"></a>2.4.6 Config—–Kernel—–Quirks</h3><p>这里是内核相关的快捷选项，比较重要。</p><ul><li><p><strong>AppleCpuPmCfgLock:</strong> <code>YES</code> </p><ul><li>四代之前的CPU，如果未解锁CFG(即MSR0xE2)请选择YES。</li></ul></li><li><p><strong>AppleXcpmCfgLock:</strong> <code>YES</code> </p><ul><li>四代之后的CPU若未解锁CFG(即MSR0xE2)请选择YES。</li></ul></li><li><p><strong>AppleXcpmExtraMsrs:</strong> </p><ul><li>主要在没有原生电源管理的CPU上启用，一般是<code>Haswell-E</code>, <code>Broadwell-E</code>, <code>Skylake-X</code>这三种CPU需要填写YES。除此之外的CPU选择NO。</li></ul></li><li><p><strong>AppleXcpmForceBoost:</strong> <code>NO</code> </p><ul><li>开启时将电脑的cpu频率锁定为最高频率。</li></ul></li><li><p><strong>CustomSMBIOSGuid:</strong> <code>NO</code> </p><ul><li>戴尔笔记本专用项。</li></ul></li><li><p><strong>DisableIoMapper</strong> <code>NO</code> </p><ul><li>禁用vt-d。</li></ul></li><li><p><strong>DisableLinkeditJettison</strong> <code>YES</code> </p><ul><li>提升lilu等插件在MACOS 11系统的表现，用来替代keepsyms=1。</li></ul></li><li><p><strong>DisableRtcChecksum</strong> <code>NO</code> </p><ul><li>越过两条rtc检查(0x58及0x59)。RTC我们会更多地使用<code>RTCMemoryFixup.kext</code>来防止它。</li></ul></li><li><p><strong>ExtendBTFeatureFlags</strong> <code>NO</code> </p><ul><li>代替BT4LEContinuityFixup.kext来实现continuity。</li></ul></li><li><p><strong>ExternalDiskIcons</strong> <code>NO</code> </p><ul><li>修复苹果系统把内部硬盘识别为外置硬盘时（黄色图标的硬盘）开启。</li></ul></li><li><p><strong>IncreasePciBarSize</strong> <code>NO</code> </p><ul><li>解决卡PCI configuration，一般卡pci configuration都是因为自己错误的设置和硬件问题。</li></ul></li><li><p><strong>LapicKernelPanic</strong> <code>NO</code> </p><ul><li>适用于HP笔记本的内核奔溃选项。</li></ul></li><li><p><strong>LegacyCommpage</strong> <code>NO</code> </p><ul><li>老平台主板中使用ssse3需要开启来使用macos10.4-10.6。</li></ul></li><li><p><strong>PanicNoKextDump</strong> <code>YES</code> </p><ul><li>防止kext出错打报告而让我们看不到真正的panic原因，初始排错时最好打开。</li></ul></li><li><p><strong>PowerTimeoutKernelPanic</strong> <code>YES</code> </p><ul><li>一些设备自身的电源管理无法让系统进入睡眠而超时，导致内核奔溃，如果有这个问题请选择YES。</li></ul></li><li><p><strong>ThirdPartyDrives</strong> </p><ul><li>开启Sata类SSD的trim功能，我没有sata类的ssd，我选择NO。自行根据情况选择。</li></ul></li><li><p><strong>XhciPortLimit</strong> <code>YES</code> </p><ul><li>解除15个USB端口限制。</li></ul></li></ul><hr><h3 id="2-4-7-Config—–Kernel—–Scheme"><a href="#2-4-7-Config—–Kernel—–Scheme" class="headerlink" title="2.4.7 Config—–Kernel—–Scheme"></a>2.4.7 Config—–Kernel—–Scheme</h3><ul><li><strong>FuzzyMatch</strong> <code>NO</code> <ul><li>此选项是给10.6以及更早的系统使用，我们不做探讨。</li></ul></li></ul><ul><li><p><strong>KernelArch</strong> <code>NO</code> </p><ul><li>此选项是给10.7以及更早的系统使用，不做探讨，直接填写默认的x86_64。</li></ul></li><li><p><strong>KernelCache</strong> <code>Auto</code> </p><ul><li>选择更加合适的内核缓存方式以提升启动速度。</li></ul></li></ul><hr><h2 id="2-5-Config—–Misc"><a href="#2-5-Config—–Misc" class="headerlink" title="2.5 Config—–Misc"></a>2.5 Config—–Misc</h2><p>这里都是一些开机引导类的设置。</p><p><strong>BlessOverride:</strong> 用于覆盖 Windows <code>bootmgfw.efi</code> 的位置以便识别 Windows 引导项, OpenCore 和 Windows 的引导文件在同一硬盘的同一 ESP 分区下使用</p><pre><code class="XML">▼ Misc                  &lt;Dictionary&gt;|__ ▼ BlessOverride     &lt;Array&gt;    |__ Item 0          &lt;String&gt;          \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><h3 id="2-5-1-Config—–Misc—–Boot"><a href="#2-5-1-Config—–Misc—–Boot" class="headerlink" title="2.5.1 Config—–Misc—–Boot"></a>2.5.1 Config—–Misc—–Boot</h3><ul><li><strong>ConsoleAttributes</strong> <code>0</code><ul><li>设置开机选择界面的颜色，默认直接填0。使用方法为填入字体颜色和背景颜色的值的16进制之和。例如蓝色字（0x01)+红色背景（0x40)=0x41。色彩选择如下：</li></ul></li></ul><ul><li>0x00 — 黑</li><li>0x01 — 蓝</li><li>0x02 — 绿</li><li>0x03 — 青</li><li>0x04 — 红</li><li>0x05 — 艳红</li><li>0x06 — 棕</li><li>0x07 — 淡灰</li><li>0x08 — 深灰</li><li>0x09 — 淡蓝</li><li>0x0A — 淡绿</li><li>0x0B — 淡青</li><li>0x0C — 淡红</li><li>0x0D — 淡艳红</li><li>0x0E — 黄</li><li>0x0F — 白</li><li>0x00 — 背景 黑</li><li>0x10 — 背景 蓝</li><li>0x20 — 背景 绿</li><li>0x30 — 背景 青</li><li>0x40 — 背景 红</li><li>0x50 — 背景 艳红</li><li>0x60 — 背景 棕</li><li>0x70 — 背景 淡灰</li></ul><ul><li><p><strong>HibernateMode</strong> <code>None</code></p><ul><li><p>检测休眠模式。与系统内的休眠模式 (hibernatemode 25) 配合, 引导进系统会还原休眠前的状态, 建议关闭</p></li><li><p><code>None</code>: 关闭休眠支持</p></li><li><p><code>Auto</code>: 自动检测 RTC 和 NVRAM 模式</p></li><li><p><code>RTC</code>: RTC 模式</p></li></ul></li><li><p><strong>PickerAttributes</strong> <code>0</code></p><ul><li><p>当你使用OC主题时，你可以通过计算以下数值之和来配合使用OC主题，OC主题至今还在测试阶段。默认填0，你可能使用到的值如下：</p></li><li><p><code>0x0004</code>: 简化主题图标下的文字</p></li><li><p><code>0x0008</code>: 使用老式的图标</p></li></ul></li><li><p><strong>PickerAudioAssist</strong> <code>NO</code></p><ul><li>是否开启开机朗读文字功能，一般选择NO，如果你要开启，请同时阅读章节2.8.5和2.8.7的相关音频设置。</li></ul></li><li><p><strong>PickerMode</strong> </p><ul><li>是否使用OC的开机启动盘选项，如果我们填Builtin就是不使用任何主题；如果我们填External就会调用第三方主题。</li></ul></li></ul><blockquote><p><a href="https://github.com/acidanthera/OcBinaryData">官网推荐主题下载</a><br>  请将下载好的Resources件放入ESP/EFI/OC下，同时，你需要将OpenCanopy.efi放入Drivers文件夹下并加载。</p></blockquote><hr><ul><li><strong>PollAppleHotKeys</strong> <code>YES</code><ul><li>是否开启一些热键功能，包括Cmd+K;Cmd+S。</li></ul></li></ul><ul><li><p><strong>ShowPicker</strong> <code>YES</code></p><ul><li>是否显示开机启动盘选项。</li></ul></li><li><p><strong>TakeoffDelay</strong> <code>0</code></p><ul><li>开机热键延时，如果你按热键来不及按，你可以设置5000到10000之间的值让你有更多时间按热键（毫秒）。</li></ul></li><li><p><strong>Timeout</strong> <code>5</code></p><ul><li>倒计时进入指定硬盘，这里我们按需求填写，我填写5，代表5秒钟进入指定硬盘。</li></ul></li></ul><hr><h3 id="2-5-2-Config—–Misc—–Debug"><a href="#2-5-2-Config—–Misc—–Debug" class="headerlink" title="2.5.2 Config—–Misc—–Debug"></a>2.5.2 Config—–Misc—–Debug</h3><p>是否开启debug模式，这里我们暂时不需要，全部按默认设置。</p><hr><h3 id="2-5-3-Config—–Misc—–Entries"><a href="#2-5-3-Config—–Misc—–Entries" class="headerlink" title="2.5.3 Config—–Misc—–Entries"></a>2.5.3 Config—–Misc—–Entries</h3><p>这里是帮助我们添加一些你希望的引导路径，这个会在之后的进阶教程中讲，这里暂时略过不填写。</p><hr><h3 id="2-5-4-Config—–Misc—–Security"><a href="#2-5-4-Config—–Misc—–Security" class="headerlink" title="2.5.4 Config—–Misc—–Security"></a>2.5.4 Config—–Misc—–Security</h3><ul><li><p><strong>AllowNvramReset</strong> <code>YES</code></p><ul><li>是否在开机引导项中加入重置NVRAM功能的选项。</li></ul></li><li><p><strong>AllowSetDefault</strong> <code>YES</code></p><ul><li>是否在开机引导项中加入重置NVRAM功能的选项。</li></ul></li><li><p><strong>ApECID</strong> <code>0</code></p><ul><li>一般按默认的0填写，如果要开启安全启动的身份认证，请随便填写一串数字，比如手机号。</li></ul></li><li><p><strong>AuthRestart</strong> <code>NO</code></p><ul><li>Filevault相关项，选择NO。</li></ul></li><li><p><strong>BootProtect</strong> <code>Bootstrap</code></p><ul><li>此选项能保证OPENCORE.EFI的永久性而免遭到其他操作系统对开机顺位的破坏。在填写此项后，你同样需要保证<code>RequestBootVarRouting</code>是开启的。</li></ul></li><li><p><strong>DmgLoading</strong> <code>Any</code></p><ul><li>如果你没有开启安全启动，请填写Any；如果使用安全启动，请填写Signed（注意大小写）。</li></ul></li><li><p><strong>EnablePassword</strong> <code>NO</code></p><ul><li>此选项正在开发。</li></ul></li><li><p><strong>ExposeSensitiveData</strong> </p><ul><li>模拟nvram，填3。原生nvram，填写2。</li></ul></li><li><p><strong>HaltLevel</strong> <code>2,147,483,648</code></p><ul><li>按默认设置即可。</li></ul></li><li><p><strong>PasswordHash</strong> </p><ul><li>按默认，如果开启了<code>EnablePassword</code>，则填写密码的hash值。</li></ul></li><li><p><strong>PasswordSalt</strong> </p><ul><li>按默认，如果开启了<code>EnablePassword</code>，则填写密码的salt值。</li></ul></li><li><p><strong>ScanPolicy</strong> <code>0</code></p><ul><li>填0。我们也许会碰到开机的时候默认进入的系统永远是WINDOWS，并无法更改，之后我们在进阶教程中讲述，如何让MAC盘排在第一个，让WIN排在后面。</li></ul></li><li><p><strong>SecureBootModel</strong> <code>Disabled</code></p><ul><li>是否开启安全启动模式，一般我们填写Disabled（注意大小写）来关闭此功能。</li></ul></li><li><p><strong>Vault</strong> <code>Optional</code></p><ul><li>是否开启保险箱功能，我们选择<code>Optional</code>不开启它。</li></ul></li></ul><hr><h3 id="2-5-5-Config—–Misc—–Tools"><a href="#2-5-5-Config—–Misc—–Tools" class="headerlink" title="2.5.5 Config—–Misc—–Tools"></a>2.5.5 Config—–Misc—–Tools</h3><p>用于运行 OC 调试工具, 例如验证 CFG 锁 (VerifyMsrE2)</p><ul><li><strong>Arguments</strong><ul><li>传递的参数</li></ul></li><li><strong>Auxiliary:</strong> <code>NO</code><ul><li><code>NO</code> 默认不隐藏</li></ul></li><li><strong>Name</strong><ul><li>OpenCore 启动项中显示的名称</li></ul></li><li><strong>Enabled</strong><ul><li>启用或禁用</li></ul></li><li><strong>Path</strong><ul><li><code>Tools</code> 文件夹下的文件名</li></ul></li></ul><h2 id="2-6-Config—–NVRAM"><a href="#2-6-Config—–NVRAM" class="headerlink" title="2.6 Config—–NVRAM"></a>2.6 Config—–NVRAM</h2><h3 id="2-6-1-Config—–NVRAM—–Add"><a href="#2-6-1-Config—–NVRAM—–Add" class="headerlink" title="2.6.1 Config—–NVRAM—–Add"></a>2.6.1 Config—–NVRAM—–Add</h3><pre><code class="bash">4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14     UIScale                 Data       &lt;02&gt; //这里填写01为普通的UI显示模式，02为开启HIDPI的UI显示模式，我选择02     DefaultBackgroundColor  Data       &lt;00000000&gt; //默认开机背景色为黑色 7C436110-AB2A-4BBB-A880-FE41995C9F82     boot-args               String     Slide=1 darkwake=0 -v //slide=1表示从第一组内存开始连续注入；darkwake=0代表一键唤醒机器并偏好设置中节能选项的小憩功能。如果你要用小憩功能请填8； -v是跑代码，在没装好稳定的黑果前我建议加上，方便定位错误，弄完后再删除-v     csr-active-config       Data       &lt;e7030000&gt; //关闭SIP保护     nvda_drv                Data       &lt;31&gt; //对10.13系统之前的N卡的相关设置，我们不做讨论。     prev-lang:kbd           Data       &lt;7a682d48616e733a 323532&gt; //语言设置相关，记得改成这个，这个是中文     7C436110-AB2A-4BBB-A880-FE41995C9F82 //默认就行，如果需要使用RTC屏蔽选项，具体参考《RTC综述》</code></pre><hr><h3 id="2-6-2-Config—–NVRAM"><a href="#2-6-2-Config—–NVRAM" class="headerlink" title="2.6.2 Config—–NVRAM"></a>2.6.2 Config—–NVRAM</h3><ul><li><strong>Delete</strong> <ul><li>NVRAM的数据不可被覆盖，必须先被删除再添加，我们这里按默认设置不必理会。</li></ul></li></ul><ul><li><p><strong>LegacySchema</strong> </p><ul><li><p>这里是<code>模拟NVRAM</code>的变量设置，大部分默认已经填好，我们只需添加两个变量即可。</p><p>打开7C436110-AB2A-4BBB-A880-FE41995C9F82这一栏，添加两个item如下：</p><pre><code class="bash">item 11     String      efi-boot-device item 12     String      efi-boot-device-data</code></pre></li></ul></li></ul><ul><li><strong>LegacyOverwrite</strong> <code>NO</code><ul><li>对模拟nvram用户来说，将nvram.plist写入硬件，我认为不管是原生nvram还是模拟nvram，都选择NO</li></ul></li></ul><ul><li><strong>WriteFlash</strong> <code>YES</code><ul><li>一般情况下我们需要选择YES来保证<code>启动磁盘</code>功能的正常使用，但开启后可能会在一段时间后导致CMOS被写满，主板无法经过自检。这样的问题请请参照<a href="">RTC综述</a></li></ul></li></ul><hr><h3 id="2-7-Config—–PlatformInfo"><a href="#2-7-Config—–PlatformInfo" class="headerlink" title="2.7 Config—–PlatformInfo"></a>2.7 Config—–PlatformInfo</h3><p>这里我们填合适的机型。对于最近一代的主板来说，一般的原则，只有核显的机器我们选Macmini8,1；只有独显的机器我们选择iMac Pro 1,1;有核显和独显的我们选择iMac 19,1。笔记本请按照对应的cpu型号来选择。</p><ul><li><strong>Automatic</strong> <code>YES</code><ul><li>是否自动补全系统信息。这里我选YES，不重要的信息让它自动填。</li></ul></li></ul><ul><li><p><strong>Generic</strong></p><ul><li><p>这里是我们需要填写的三码部分。</p><p>将Opencore包下Utilities/macserial程序放到桌面，在终端下输入以下命令</p><pre><code class="bash">~/desktop/macserial --model iMacPro1,1 //你也可以换成你想要的机型比如iMac 19.1</code></pre><p>输入后你回获得一些序列号以及主板主板序列号，请自己选用一组，填写到MLB以及SystemSerialNumber后重启。</p><p>重启后，请再在终端下输入：</p><pre><code class="bash">ioreg -d2 -c IOPlatformExpertDevice | awk -F\&quot; &#39;/IOPlatformUUID/&#123;print $(NF-1)&#125;&#39;</code></pre><p>得到你的主板UUID，填入Generic的SystemUUID （此操作可以帮助你的win不丢失激活）</p></li><li><p><strong>AdviseWindows</strong> <code>YES</code></p><ul><li>如果你的windows的efi不在showpicker的第一个，必须选择YES。</li></ul></li><li><p><strong>SystemMemoryStatus</strong> <code>Auto</code></p><ul><li>一些机型本身是可以升级内存，但在关于本机选项卡中不显示内存选项时需要开启，一般选择Auto。</li></ul></li><li><p><strong>SpoofVendor</strong> <code>YES</code></p><ul><li>是否把主板名称更改为ACDT，一般我们选择yes。</li></ul></li><li><p><strong>ProcessorType</strong> <code>0</code></p><ul><li>为一些es，qs或者amd的cpu在关于本机中显示核心数。</li></ul></li></ul></li></ul><ul><li><strong>UpdateDataHub</strong> <code>YES</code><ul><li>更新DataHub。</li></ul></li></ul><ul><li><p><strong>UpdateNVRAM</strong> <code>YES</code></p><ul><li>更新NVRAM。</li></ul></li><li><p><strong>UpdateSMBIOS</strong> <code>YES</code></p><ul><li>更新BIOS</li></ul></li><li><p><strong>UpdateSMBIOSMode</strong> <code>Create</code></p><ul><li>用新分配的 EfiReservedMemoryType 替换原有的表, 戴尔笔记本需要使用 <code>Custom</code> 并开启 <code>CustomSMBIOSGuid</code></li></ul></li></ul><hr><h2 id="2-8-Config—–UEFI"><a href="#2-8-Config—–UEFI" class="headerlink" title="2.8 Config—–UEFI"></a>2.8 Config—–UEFI</h2><ul><li><p><strong>ConnectDrivers</strong> <code>YES</code></p><ul><li>是否加载补丁</li></ul></li><li><p><strong>Drivers</strong></p><pre><code class="bash">Drivers        item0     String        .................... MemoryAllocation.efi        .................... OpenRuntime.efi       .................... HFSPlus.efi        .................... OpenCanopy.efi</code></pre></li></ul><ul><li><strong>Input</strong> <code>YES</code><ul><li>是否加载补丁</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hackintosh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCore </tag>
            
            <tag> Hackintosh </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
