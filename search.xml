<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 OpenCore 引导黑苹果</title>
      <link href="post/opencore-guide.html"/>
      <url>post/opencore-guide.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenCore(OC)是一种新的引导方式，越来越多的kexts开始放弃Clover, 我相信提早使用OC会对你未来使用黑苹果会有很大的帮助。这是一个自然的现象，就像变色龙被Clover淘汰，而现在OC代替Clover也是大势所趋。你应该需要看一些相关的文章，来帮助你理解我的正文内容，同时也需要下载我推荐的软件：</p><hr><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p><a href="https://khronokernel-2.gitbook.io/opencore-vanilla-desktop-guide/">Opencore Vanilla Desktop Guide</a></p><p><a href="https://github.com/khronokernel/Getting-Started-With-OpenCore">Getting Started With OpenCore</a></p><p><a href="https://blog.daliansky.net/OpenCore-BootLoader.html">精解OpenCore</a></p><hr><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>Xcode （从app store或其他地方下载，强烈建议使用v10版本的xcode，v11花里胡哨已经劝退=。=)</p><p><a href="https://github.com/corpnewt/ProperTree">ProperTree</a>最新推荐的config编辑器</p><p><a href="https://github.com/williambj1/OpenCore-Factory/releases">OpenCore</a> (由BAT维护的每日工厂版，尝鲜用户可以下载这个)</p><p><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenCore</a>（官方稳定版本）</p><p><a href="http://headsoft.com.au/download/mac/Hackintool.zip">Hackintool</a></p><p><a href="http://blog.xjn819.com/wp-content/uploads/2019/10/MaciASL.zip">MaciASL</a></p><p><a href="https://github.com/daliansky/OC-little">宪武大大oc部件</a></p><p><a href="https://github.com/acidanthera/gfxutil/releases">gfxutil</a> </p><hr><h2 id="更新日记"><a href="#更新日记" class="headerlink" title="更新日记"></a>更新日记</h2><details>  <summary><font color=red>点击查询帖子最近更新</font></summary><p>2020-10-14:</p><p>1.Opencore 0.6.2正式版修改如下variables:</p><p>增加ExtendBTFeatureFlags （章节2.4.6）<br>移除DummyPowerManagement（章节2.4.6）<br>增加LegacyCommpage（章节2.4.6）<br>增加SystemMemoryStatus （章节2.7.2）<br>增加ProcessorType（章节2.7.2）</p></details><hr><h1 id="BIOS设置"><a href="#BIOS设置" class="headerlink" title="BIOS设置"></a>BIOS设置</h1><p>直接抄袭@BAT了</p><ul><li><strong>禁用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">Fast Boot</td><td align="center">快速启动</td></tr><tr><td align="center">CFG Lock (MSR 0xE2 write protection)</td><td align="center">CFG 锁 (MSR 0xE2 写入保护)</td></tr><tr><td align="center">VT-d</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-d</a></td></tr><tr><td align="center">CSM</td><td align="center">兼容性支持模块</td></tr><tr><td align="center">Intel SGX</td><td align="center">Intel SGX</td></tr></tbody></table><hr><ul><li><strong>启用:</strong></li></ul><table><thead><tr><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">VT-x</td><td align="center"><a href="https://zhidao.baidu.com/question/495526512.html">VT-x</a></td></tr><tr><td align="center">Above 4G decoding</td><td align="center">大于 4G 地址空间解码</td></tr><tr><td align="center">Hyper Threading</td><td align="center">处理器超线程</td></tr><tr><td align="center">Execute Disable Bit</td><td align="center">执行禁止位</td></tr><tr><td align="center">EHCI/XHCI Hand-off</td><td align="center">接手 EHCI/XHCI 控制</td></tr><tr><td align="center">OS type: Windows 8.1/10</td><td align="center">操作系统类型: Windows 8.1/10</td></tr><tr><td align="center">Legacy RTC Device</td><td align="center">传统 RTC 设备</td></tr></tbody></table><blockquote><p>将 操作系统类型设置为 <code>Windows 8.1/10</code> 是因为部分主板在 <code>Other</code> 模式下会将系统认作是 Windows 7 从而禁用 UEFI 的某些功能并开启 CSM, 200 系及以后的主板理论上不存在这个问题</p></blockquote><hr><h1 id="整理OPENCORE目录"><a href="#整理OPENCORE目录" class="headerlink" title="整理OPENCORE目录"></a>整理OPENCORE目录</h1><p>打开下载好的最新版OC，把Doc文件夹下面的Sample.plist改名为config.plist，并把此文件移动到EFI目录下面。<br>打开EFI—Kexts，我们把常用的一些kexts先放进去，一般情况下你需要放如下Kexts:</p><p>Lilu.kext    Acidanthera驱动全家桶的SDK</p><p>Applealc.kext   声卡驱动/下载地址</p><p>VirtualSMC.kext    传感器驱动依赖 </p><p>SMCProcessor.kext   CPU核传感器</p><p>SMCSuperIO.kext    IO传感器         </p><p>WhateverGreen.kext 显卡驱动</p><p>IntelMausi.kext  Intel类千兆网卡驱动</p><p>Usbinjectall.kext  USB驱动 （你也可以定制自己的USB补丁）<br>               <br>NVMeFix.kext      为NVME硬盘增加ASPT属性来保证节电，虽然对台式机没啥用，但是官方推荐所有NVME用户都使用此补丁</p><blockquote><p>一些机型用了1820A,1560,1830等网卡，需要自己放对应驱动；有线螃蟹卡也自己放一下驱动；笔记本类需要更多传感器的，请自行补齐VirtualSMC的那些传感器补丁</p></blockquote><hr><h1 id="Config-plist-修改"><a href="#Config-plist-修改" class="headerlink" title="Config.plist 修改"></a>Config.plist 修改</h1><p>这章会把config的项目分开来，内容繁琐，为了让小白明白各个选项的用途。当然有能力的人可以直接看我最前面的几个链接来配置config.plist。我这里强制要求你使用<code>Propertree</code>来编辑Config.plist，其他的任何软件我都不建议使用。</p><hr><h2 id="Config—-ACPI"><a href="#Config—-ACPI" class="headerlink" title="Config—-ACPI"></a>Config—-ACPI</h2><p>ACPI包括了四个部分：Add, Block, Patch, Quirks。这里我们先把root下面的几条#WARNING删除，这几条没有实际意义。</p><hr><h3 id="Config—–ACPI—–Add"><a href="#Config—–ACPI—–Add" class="headerlink" title="Config—–ACPI—–Add"></a>Config—–ACPI—–Add</h3><p>这部分主要填写我们使用的SSDT以及DSDT文件，如果没有请把0-8的ssdt全部删除。如果你有修改的SSDT或者DSDT文件，请先将文件放入EFI/OC/ACPI下。</p><p>因为我使用雷电卡，我需要添加两条关于雷电卡的ssdt文件：</p><pre><code class="xml">Item 0 Comment    String       Thunderbolt3-DTGP //填一个你自己能辨别的名字，方便知道是啥 Enable     Boolean      YES //表示加载此SSDT，反之NO则为不加载Path       String       SSDT-DTGP.aml //为你ssdt放在EFI/OC/ACPI下的文件名，必须一致Item 1 Comment    String       Thunderbolt3Enable     Boolean      YES Path       String       SSDT-TB3.aml</code></pre><hr><h3 id="Config—–ACPI—–Delete"><a href="#Config—–ACPI—–Delete" class="headerlink" title="Config—–ACPI—–Delete"></a>Config—–ACPI—–Delete</h3><p>这个目录下是禁用一些SSDT/DSDT，没什么用，我把下面的item全都删了。</p><hr><h3 id="Config—–ACPI—–Patch"><a href="#Config—–ACPI—–Patch" class="headerlink" title="Config—–ACPI—–Patch"></a>Config—–ACPI—–Patch</h3><a id="1.0"><p>这里我们需要填写一下热补丁。</p><ul><li>10.15及以上系统，<a href="https://blog.daliansky.net/Common-problems-and-solutions-in-macOS-Catalina-10.15-installation.html">一些资料</a>指出我们需要把EC控制器(EC0)改名为EC来确保能进入10.15系统</li></ul><pre><code class="xml">Comment: EC0 to EC Count:0 Enabled:YES Find:&lt;4543305F&gt; Limit:0 Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;45435F5F&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><blockquote><p>一些主板的EC控制器名字可能会叫H_EC等，请自行提取DSDT并搜索PNP0C09，来获取EC控制器的名字，这些内容会在第三章中写出。</p></blockquote><hr><ul><li>华擎、华硕、微星主板可能会遇到采用新的AWAC时钟而无法进入系统，这同样需要添加hotpatch补丁来解决：</li></ul><pre><code class="xml">Comment: RTC fix Count:0 Enabled:YES Find:&lt;A00A9353 54415301&gt; Limit:0Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;A00A910A FF0BFFFF&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><hr><h3 id="Config—–ACPI—–Quirks"><a href="#Config—–ACPI—–Quirks" class="headerlink" title="Config—–ACPI—–Quirks"></a>Config—–ACPI—–Quirks</h3><p>此目录下有五项，选择与解释如下：</p><ul><li><strong>FadtEnableReset:</strong> <code>NO</code><ul><li>旧的主板需要对FADT进行标记来激活电脑的开机和关机功能，这里我们不许要启动它</li></ul></li><li><strong>NormalizeHeaders:</strong> <code>NO</code><ul><li>清理ACPI头，一些主板的ACPI表需要打开这个修复10.13系统的启动。</li></ul></li><li><strong>RebaseRegions:</strong> <code>YES</code><ul><li>尝试试探性地重新定位 ACPI 内存区域, <strong>使用自定义 DSDT 则必须开启</strong></li></ul></li><li><strong>ResetHwSig:</strong> <code>NO</code><ul><li>存在重新启动后因无法维持硬件签名而导致从休眠中唤醒的问题的硬件需要开启</li></ul></li><li><strong>ResetLogoStatus:</strong> <code>NO</code><ul><li>无法在有 <code>BGRT</code> 表的系统上显示 OEM Windows 标志的硬件需要开启</li></ul></li></ul><hr><h2 id="Config—-Booter"><a href="#Config—-Booter" class="headerlink" title="Config—-Booter"></a>Config—-Booter</h2><p>内存相关选项设置。</p><hr><h3 id="Config—Boot—MmioWhitelist"><a href="#Config—Boot—MmioWhitelist" class="headerlink" title="Config—Boot—MmioWhitelist"></a>Config—Boot—MmioWhitelist</h3><ul><li><p>默认的第一项是为Haswell芯片提供的内存寻址修复，如果此类芯片碰到内存相关问题，请开启它(enable选择yes)。</p></li><li><p>默认第二项是开机卡PCI Configuration这里。ACPI、PCI device同时释放到内存时发生0x1000内存地址被占用而卡在PCI Configration.如果碰到此类问题，请开启它。</p></li></ul><hr><h3 id="Config—Boot—Quirks"><a href="#Config—Boot—Quirks" class="headerlink" title="Config—Boot—Quirks"></a>Config—Boot—Quirks</h3><p>此项与OpenRuntime.efi有关。在aptiomemoryfix停更后，此补丁已经更名为Openruntime, 并将一些功能与OC合并、模块化。对于无法原生nvram的主板来说，这里的选项需要格外注意。当然我也会把像300/400系列、x299、c422这样支持原生nvram的选择方法一并写进去。</p><ul><li><strong>AvoidRuntimeDefrag:</strong> <code>YES</code><ul><li>大部分UEFI都会写入时间、电源管理等信息，这个所有黑苹果主板都应该选择YES。</li></ul></li></ul><ul><li><strong>DevirtualiseMmio:</strong> <code>YES</code> <ul><li>内存注入方式包括KASLR方式(分布式注射到各个内存地址中）以及连续性方式。在使用KASLR时，PCIE加载到内存，可能会占据所有avaliable值而影响OC的内核以及内核缓存无法注入，导致启动失败。此项目前建议选择YES，并且在下一项ProtectUefiServices中也选择yes。</li></ul></li></ul><blockquote><p>KASLR是更加高效的内存注入方式，但不代表每台机器都能使用这种方案，这里我提供两种关于内存的设置：<br>1：<code>DevirtualiseMmio</code>选择yes, <code>ProtectUefiServices</code>选择yes, 并删除2.6.1中boot-args里面的<code>slide=1</code>,以及删除Drivers文件夹下的<code>Memoryallocations.efi</code>。即开启KASLR内存注入方式。<br>2：<code>DevirtualiseMmio</code>选择yes, <code>ProtectUefiServices</code>选择no, 保留2.6.1中boot-args里面的<code>slide=1</code>,以及保留Drivers文件夹下的<code>Memoryallocations.efi</code>。即开启连续性内存注入方式。</p></blockquote><ul><li><p><strong>DisableSingleUser:</strong> <code>NO</code> </p><ul><li>这里关乎主机是否能开启单用户模式。什么是单用户模式，请看<a href="https://support.apple.com/zh-cn/HT201573">此文章</a>。</li></ul></li><li><p><strong>DisableVariableWrite:</strong> </p><ul><li>非原生NVRAM主板需要模拟nvram.plist进而写入variable值，因此我们要禁止此项来防止其他程序对nvram进行写入，我们这里选YES。需要注意一点，如果你的主板支持原生nvram，请选择NO！</li></ul></li><li><p><strong>DiscardHibernateMap:</strong> <code>NO</code> </p><ul><li>电脑从休眠(hibernation)中唤醒时,硬盘里的资料会恢复到内存中去，但这个时候OC的内核以及内核缓存等也会写入，这样可能导致冲突，这个选项是帮助我们解决这个问题的。而目前来看，除了原生NVRAM都无法进行休眠（注意睡眠sleep和休眠hibernation是两个概念），台式机的话就更不需要休眠功能了，这里我选择NO。这里我们也不讨论如何休眠。</li></ul></li><li><p><strong>EnableSafeModeSlide:</strong> <code>YES</code> </p><ul><li>安全模式下是否启用连续性的内存注入方式。我就选择YES，与正常情况下保持一致。</li></ul></li><li><p><strong>EnableWriteUnprotector:</strong> <code>YES</code> </p><ul><li>保证nvram能正常写入而不受到CR0寄存器的写入保护影响。</li></ul></li><li><p><strong>ForceExitBootServices:</strong> <code>NO</code> </p><ul><li>这个选项是让那些非常老旧的主板也能使用内存寻址，正常情况下选NO。</li></ul></li><li><p><strong>ProtectMemoryRegions:</strong> <code>NO</code> </p><ul><li>官方对此项目的解释与AvoidRuntimeDefrag类似，除非你明白这是什么，不然选择NO，其实我也不明白。</li></ul></li><li><p><strong>ProtectSecureBoot:</strong> <code>NO</code> </p><ul><li>保护安全启动，除非你开启安全启动，不然我们选择NO。</li></ul></li><li><p><strong>ProtectUefiServices:</strong> <code>NO</code> </p><ul><li>解决Z390系列主板卡开机卡++++的问题，这个功能从字面意思是与我提供的memoryallocation.efi功能类似。</li></ul></li><li><p><strong>ProvideCustomSlide:</strong> <code>YES</code> </p><ul><li>此选项执行固件的内存映射分析并检查所有的 slide 值(1 - 255)是否可用。由于 boot.efi 生成的这个值是利用 rdrand 指令随机生成的或者伪随机指令 rdtsc 随机生成的，因此当其选择了 一个冲突的 slide 值时有可能启动失败。由于这种潜在的冲突存在，此选项强制 macOS 在可用的值中使用一个伪随机值，这也确保了 slide= 启动参数不会因为安全原因传递给操作系统。<br>是否需要此选项由信息 OCABC (Only N/256 slide values are usable!) 是否存在于调试日 志中决定。如果存在此信息，则需要启用此 Quriks 选项。我选择YES。如果你对KASLR有一定的认知并会运用，请注意这个值。内容从@套陆 摘抄。</li></ul></li><li><p><strong>ProvideMaxSlide:</strong> </p><ul><li>如果你没有启用KASLR的话，请填写1-255之间的数字以存放休眠文件写进内存所需要的内存高度，反之则填写0。</li></ul></li><li><p><strong>RebuildAppleMemoryMap:</strong> <code>NO</code> </p><ul><li>重新生成内存地图来匹配苹果系统。苹果的内核有很多缺陷，比如单张的内存地图不能超过4K，一旦超过就可能无法开机；又比如一些硬件会直接把读写权限写进内存里，而苹果却不能给与写入权限。如果你遇到此类的问题，请尝试开启它。注意此项目与EnableWriteUnprotector存在冲突关系，确保开启这个的时候，另一个是关闭的。另外，此项又需要与SyncRuntimePermissions项搭配使用。一般情况下请选择NO。</li></ul></li><li><p><strong>SetupVirtualMap:</strong> <code>YES</code> </p><ul><li>是否建立虚拟内存并对物理内存进行映射。我们在开机时，OC的程序需要一块连续性的内存进行存放内核等东西，而实际的物理内存一般都是分散的。因此，我们通过虚拟内存建立连续性内存供OC使用，并映射到分散的物理内存中。这里我们选择YES。</li></ul></li><li><p><strong>SignalAppleOS:</strong> <code>NO</code> </p><ul><li>通知同一台电脑上的设备mac上的硬件选择，此项是给白苹果用的。</li></ul></li></ul><ul><li><strong>SyncRuntimePermissions:</strong> <code>YES</code> <ul><li>修正硬件在注入内存时无法注入权限的问题。一般此类问题存在2018年后的主板。如果你因为此选项无法进入windows，请开启它。</li></ul></li></ul><hr><h2 id="Config—-DeviceProperties"><a href="#Config—-DeviceProperties" class="headerlink" title="Config—-DeviceProperties"></a>Config—-DeviceProperties</h2><p>此项是用来注入你的设备的，主要是显卡和声卡两部分。同样你也可以定制一些设备到你的关于本机–系统报告–PCI列表中，尽管没有多大的意义。</p><h3 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h3><p>这里首先我们需要确认自己的声卡驱动已经被加载，终端下输入：</p><pre><code class="bash">kextstat | grep -E &quot;AppleHDA|AppleALC|Lilu&quot;</code></pre><p>我们会得到被加载的驱动，请确保<code>as.vit9696.Lilu</code>；<code>as.vit9696.AppleALC</code>；<code>com.apple.driver.AppleHDAController</code>；<code>com.apple.driver.AppleHDA</code>已经被加载。</p><p>找自己声卡的地址，准备好在文章开头要求下载的gfxutil，将gfxutil程序放在桌面，输入:</p><pre><code class="bash">~/desktop/gfxutil -f HDEF //一般来说我们在使用Applealc后，板载声卡的部件名都叫HDEF</code></pre><p>我们输入后会得到声卡的PCI路径，比如我输出的就是：</p><pre><code class="bash">00:1f.3 8086:a2f0 /PC00@0/HDEF@1F,3 = PciRoot(0x0)/Pci(0x1F,0x3)</code></pre><p>这里我们找到的声卡PCI路径为PciRoot(0x0)/Pci(0x1f,0x3)。我们把预先填写在那里的PciRoot(0x0)/Pci(0x1b,0x0)项替换成我们真正的声卡路径。</p><p>后面一段我们看到预先填写的声卡ID为&lt;01000000&gt;，这里我们需要把它换成合适自己声卡的ID，输入以下命令得到自己声卡的CodecID。</p><pre><code class="bash">ioreg -l|grep IOHDACodecVendorID</code></pre><p>点击<a href="https://github.com/acidanthera/gfxutil/releases">此页面</a>搜索刚得到的CodecID就可查询到自己声卡的型号名称，以及可用的LayoutID。</p><p>比如我的CodecID为<code>283906408</code>，声卡型号<code>ALCS1220A</code>，对应1, 2, 3, 5, 7, 11, 13, 15, 16, 27, 28, 29, 34的layout ID。我们需要一个个测试过去，选定自己能用的。这里我们选择7这个ID进行测试，将7转化成16进制格式为07，后面为了满足格式要求添加6个0，则为07000000，将这个值替换刚才预先填的01000000中；如果我们测试ID为27，27的16进制为1b，补上6个0则为1b000000。</p><pre><code class="xml">PciRoot(0x0)/Pci(0x1f,0x3)         device-id       data      &lt;70a10000&gt; //一般情况下这段是不需要填写的，除非你的声卡需要仿冒        layout-id       data      &lt;0b000000&gt; //这个Layout id我瞎写的，你按实际情况写</code></pre><p>如果你测试的ID都无效，请确保你的操作过程正确、并测试用万能声卡(VoodooHDA)补丁来替换AppleALC这个补丁。如果都不行，你可能需要自行<a href="https://blog.daliansky.net/Use-AppleALC-sound-card-to-drive-the-correct-posture-of-AppleHDA.html">编译声卡补丁</a>。</p><hr><h3 id="核心显卡"><a href="#核心显卡" class="headerlink" title="核心显卡"></a>核心显卡</h3><p>打开PciRoot(0x0)/Pci(0x2,0x0)这项，此项为驱动核心显卡。驱动核心显卡我们要分情况讨论:1.只有核心显卡的DP显示器用户 (HDMI我会在进阶设置中写）；2.没有核心显卡的用户；3.有核心显卡并用独显做主力的用户。注意，这里我们只讨论8代和9代CPU的机器，其他CPU机型的请在论坛或者<a href="https://blog.daliansky.net/Intel-core-display-platformID-finishing.html">黑果小兵博客</a>中搜索相关代码。</p><hr><h4 id="只有核心显卡的DP显示器用户"><a href="#只有核心显卡的DP显示器用户" class="headerlink" title="只有核心显卡的DP显示器用户"></a>只有核心显卡的DP显示器用户</h4><p>8代和9代的核显ID为:3E9b0007，device ID为3e9b0000，但是我们需要符合苹果的倒叙格式填入：</p><pre><code class="xml">AAPL,ig-platform-id        data        &lt;07009b3e&gt; device-id                  data        &lt;9b3e0000&gt;framebuffer-unifiedmem     data        &lt;00000080&gt;      //核显显存相关</code></pre><hr><h4 id="没核心显卡的用户"><a href="#没核心显卡的用户" class="headerlink" title="没核心显卡的用户"></a>没核心显卡的用户</h4><p>带f的cpu (e.g. 9100f 9900kf), Xeon等不带核心显卡的用户不需要管这项，直接把AAPL,ig-platform-id选项卡删了。</p><hr><h4 id="有核心显卡并用独显做主力的用户"><a href="#有核心显卡并用独显做主力的用户" class="headerlink" title="有核心显卡并用独显做主力的用户"></a>有核心显卡并用独显做主力的用户</h4><p>这种情况我们一般把核心显卡作为加速用，而显示则用独立显卡。这样，我们填一个作为加速用的核显ID即可了，8代9代10代除外的cpu请搜索黑果小兵的博客：</p><pre><code class="xml">AAPL,ig-platform-id        data        &lt;0300983e&gt;</code></pre><hr><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>这里是禁用一些设备的，我们按默认就行了，不需要任何修改。</p><hr><h2 id="Config—-Kernel"><a href="#Config—-Kernel" class="headerlink" title="Config—-Kernel"></a>Config—-Kernel</h2><p>这里是内核相关选项。</p><hr><h3 id="Config—Kernel—Add"><a href="#Config—Kernel—Add" class="headerlink" title="Config—Kernel—Add"></a>Config—Kernel—Add</h3><p>这里我们需要填写kexts的相关资料。值得注意的是OC的kexts填写必须注意顺序，比如applealc的依赖是lilu，那么lilu必须填在第一个；SMCProcessor.kext依赖于Virtualsmc.kext。那virtualsmc必须放在SMCProcessor.kext之前。</p><p>这里默认情况下很多我们需要的补丁已经被加载里面了，但是enabled那块我们要手动改成yes去开启它，把一些不用的删了：</p><pre><code class="xml">Item 0      BundlePath       String         Lilu.kext            //kext的名字       Comment          String                              //你自己填一个注释，可以不填       Enabled          Boolean        YES                  //启动此补丁，反之则为关闭       ExecutablePath   String         Contents/MacOS/Lilu  //通过右键kext显示包内容查找lilu运行文件的真正路径       MaxKernel        String                              //此补丁支持的最大系统版本，填19为10.15，18位10.14；我们一般情况下留空       MinKernel        String                              //此补丁支持的最小系统版本       PlistPath        String         Contents/Info.plist  //kext的plist位置，可以右键kext显示包内容查找正确路径       ............ ...........       ............ ...........Item 7      BundlePath       String         USBPorts.kext       Comment          String             Enabled          Boolean        YES       ExecutablePath   String                              //一些没有执行文件的kext不需要填写      MaxKernel        String       MinKernel        String      PlistPath        String         Contents/Info.plist       ............ ...........       ............ ...........</code></pre><hr><h3 id="Config—-Kernel—-Block"><a href="#Config—-Kernel—-Block" class="headerlink" title="Config—-Kernel—-Block"></a>Config—-Kernel—-Block</h3><p>禁用一些kexts，这里好像没啥用，不用理会。</p><hr><h3 id="Config—-Kernel—-Emulate"><a href="#Config—-Kernel—-Emulate" class="headerlink" title="Config—-Kernel—-Emulate"></a>Config—-Kernel—-Emulate</h3><p>此选项帮助Ivy Bridge 和一些不受支持的CPU加载电源管理的，我们这里不做此方面讨论。所有选项按默认即可。</p><hr><h3 id="Config—-Kernel—-Force"><a href="#Config—-Kernel—-Force" class="headerlink" title="Config—-Kernel—-Force"></a>Config—-Kernel—-Force</h3><p>特殊情况下我们需要强制加载某一些kext来达到某种目的，一般我们不理会此项。</p><hr><h3 id="Config—-Kernel—-Patch"><a href="#Config—-Kernel—-Patch" class="headerlink" title="Config—-Kernel—-Patch"></a>Config—-Kernel—-Patch</h3><p>这里是为内核打补丁用的，我会在进阶教程中详细写一下这一块。尤其是rtc相关的内容，我都会写进第三章的进阶教程。</p><hr><h3 id="Config—-Kernel—-Quirks"><a href="#Config—-Kernel—-Quirks" class="headerlink" title="Config—-Kernel—-Quirks"></a>Config—-Kernel—-Quirks</h3><p>这里是内核相关的快捷选项，比较重要。</p><ul><li><p><strong>AppleCpuPmCfgLock:</strong> <code>YES</code> </p><ul><li>四代之前的CPU，如果未解锁CFG(即MSR0xE2)请选择YES。</li></ul></li><li><p><strong>AppleXcpmCfgLock:</strong> <code>YES</code> </p><ul><li>四代之后的CPU若未解锁CFG(即MSR0xE2)请选择YES。</li></ul></li><li><p><strong>AppleXcpmExtraMsrs:</strong> </p><ul><li>主要在没有原生电源管理的CPU上启用，一般是<code>Haswell-E</code>, <code>Broadwell-E</code>, <code>Skylake-X</code>这三种CPU需要填写YES。除此之外的CPU选择NO。</li></ul></li><li><p><strong>AppleXcpmForceBoost:</strong> <code>NO</code> </p><ul><li>开启时将电脑的cpu频率锁定为最高频率。</li></ul></li><li><p><strong>CustomSMBIOSGuid:</strong> <code>NO</code> </p><ul><li>戴尔笔记本专用项。</li></ul></li><li><p><strong>DisableIoMapper</strong> <code>NO</code> </p><ul><li>禁用vt-d。</li></ul></li><li><p><strong>DisableLinkeditJettison</strong> <code>YES</code> </p><ul><li>提升lilu等插件在MACOS 11系统的表现，用来替代keepsyms=1。</li></ul></li><li><p><strong>DisableRtcChecksum</strong> <code>NO</code> </p><ul><li>越过两条rtc检查(0x58及0x59)。RTC我们会更多地使用<code>RTCMemoryFixup.kext</code>来防止它。</li></ul></li><li><p><strong>ExtendBTFeatureFlags</strong> <code>NO</code> </p><ul><li>代替BT4LEContinuityFixup.kext来实现continuity。</li></ul></li><li><p><strong>ExternalDiskIcons</strong> <code>NO</code> </p><ul><li>修复苹果系统把内部硬盘识别为外置硬盘时（黄色图标的硬盘）开启。</li></ul></li><li><p><strong>IncreasePciBarSize</strong> <code>NO</code> </p><ul><li>解决卡PCI configuration，一般卡pci configuration都是因为自己错误的设置和硬件问题。</li></ul></li><li><p><strong>LapicKernelPanic</strong> <code>NO</code> </p><ul><li>适用于HP笔记本的内核奔溃选项。</li></ul></li><li><p><strong>LegacyCommpage</strong> <code>NO</code> </p><ul><li>老平台主板中使用ssse3需要开启来使用macos10.4-10.6。</li></ul></li><li><p><strong>PanicNoKextDump</strong> <code>YES</code> </p><ul><li>防止kext出错打报告而让我们看不到真正的panic原因，初始排错时最好打开。</li></ul></li><li><p><strong>PowerTimeoutKernelPanic</strong> <code>YES</code> </p><ul><li>一些设备自身的电源管理无法让系统进入睡眠而超时，导致内核奔溃，如果有这个问题请选择YES。</li></ul></li><li><p><strong>ThirdPartyDrives</strong> </p><ul><li>开启Sata类SSD的trim功能，我没有sata类的ssd，我选择NO。自行根据情况选择。</li></ul></li><li><p><strong>XhciPortLimit</strong> <code>YES</code> </p><ul><li>解除15个USB端口限制。</li></ul></li></ul><hr><h3 id="Config—-Kernel—-Scheme"><a href="#Config—-Kernel—-Scheme" class="headerlink" title="Config—-Kernel—-Scheme"></a>Config—-Kernel—-Scheme</h3><ul><li><strong>FuzzyMatch</strong> <code>NO</code> <ul><li>此选项是给10.6以及更早的系统使用，我们不做探讨。</li></ul></li></ul><ul><li><p><strong>KernelArch</strong> <code>NO</code> </p><ul><li>此选项是给10.7以及更早的系统使用，不做探讨，直接填写默认的x86_64。</li></ul></li><li><p><strong>KernelCache</strong> <code>Auto</code> </p><ul><li>选择更加合适的内核缓存方式以提升启动速度。</li></ul></li></ul><hr><h2 id="Config—-Misc"><a href="#Config—-Misc" class="headerlink" title="Config—-Misc"></a>Config—-Misc</h2><p>这里都是一些开机引导类的设置。</p><p><strong>BlessOverride:</strong> 用于覆盖 Windows <code>bootmgfw.efi</code> 的位置以便识别 Windows 引导项, OpenCore 和 Windows 的引导文件在同一硬盘的同一 ESP 分区下使用</p><pre><code class="XML">▼ Misc                  &lt;Dictionary&gt;|__ ▼ BlessOverride     &lt;Array&gt;    |__ Item 0          &lt;String&gt;          \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><h3 id="Config—-Misc—-Boot"><a href="#Config—-Misc—-Boot" class="headerlink" title="Config—-Misc—-Boot"></a>Config—-Misc—-Boot</h3><ul><li><strong>ConsoleAttributes</strong> <code>0</code><ul><li>设置开机选择界面的颜色，默认直接填0。使用方法为填入字体颜色和背景颜色的值的16进制之和。例如蓝色字（0x01)+红色背景（0x40)=0x41。色彩选择如下：</li></ul></li></ul><ul><li>0x00 — 黑</li><li>0x01 — 蓝</li><li>0x02 — 绿</li><li>0x03 — 青</li><li>0x04 — 红</li><li>0x05 — 艳红</li><li>0x06 — 棕</li><li>0x07 — 淡灰</li><li>0x08 — 深灰</li><li>0x09 — 淡蓝</li><li>0x0A — 淡绿</li><li>0x0B — 淡青</li><li>0x0C — 淡红</li><li>0x0D — 淡艳红</li><li>0x0E — 黄</li><li>0x0F — 白</li><li>0x00 — 背景 黑</li><li>0x10 — 背景 蓝</li><li>0x20 — 背景 绿</li><li>0x30 — 背景 青</li><li>0x40 — 背景 红</li><li>0x50 — 背景 艳红</li><li>0x60 — 背景 棕</li><li>0x70 — 背景 淡灰</li></ul><ul><li><p><strong>HibernateMode</strong> <code>None</code></p><ul><li><p>检测休眠模式。与系统内的休眠模式 (hibernatemode 25) 配合, 引导进系统会还原休眠前的状态, 建议关闭</p></li><li><p><code>None</code>: 关闭休眠支持</p></li><li><p><code>Auto</code>: 自动检测 RTC 和 NVRAM 模式</p></li><li><p><code>RTC</code>: RTC 模式</p></li></ul></li><li><p><strong>PickerAttributes</strong> <code>0</code></p><ul><li><p>当你使用OC主题时，你可以通过计算以下数值之和来配合使用OC主题，OC主题至今还在测试阶段。默认填0，你可能使用到的值如下：</p></li><li><p><code>0x0004</code>: 简化主题图标下的文字</p></li><li><p><code>0x0008</code>: 使用老式的图标</p></li></ul></li><li><p><strong>PickerAudioAssist</strong> <code>NO</code></p><ul><li>是否开启开机朗读文字功能，一般选择NO，如果你要开启，请同时阅读章节2.8.5和2.8.7的相关音频设置。</li></ul></li><li><p><strong>PickerMode</strong> </p><ul><li>是否使用OC的开机启动盘选项，如果我们填Builtin就是不使用任何主题；如果我们填External就会调用第三方主题。</li></ul></li></ul><blockquote><p><a href="https://github.com/acidanthera/OcBinaryData">官网推荐主题下载</a><br>  请将下载好的Resources件放入ESP/EFI/OC下，同时，你需要将OpenCanopy.efi放入Drivers文件夹下并加载。</p></blockquote><hr><ul><li><strong>PollAppleHotKeys</strong> <code>YES</code><ul><li>是否开启一些热键功能，包括Cmd+K;Cmd+S。</li></ul></li></ul><ul><li><p><strong>ShowPicker</strong> <code>YES</code></p><ul><li>是否显示开机启动盘选项。</li></ul></li><li><p><strong>TakeoffDelay</strong> <code>0</code></p><ul><li>开机热键延时，如果你按热键来不及按，你可以设置5000到10000之间的值让你有更多时间按热键（毫秒）。</li></ul></li><li><p><strong>Timeout</strong> <code>5</code></p><ul><li>倒计时进入指定硬盘，这里我们按需求填写，我填写5，代表5秒钟进入指定硬盘。</li></ul></li></ul><hr><h3 id="Config—-Misc—-Debug"><a href="#Config—-Misc—-Debug" class="headerlink" title="Config—-Misc—-Debug"></a>Config—-Misc—-Debug</h3><p>是否开启debug模式，这里我们暂时不需要，全部按默认设置。</p><hr><h3 id="Config—-Misc—-Entries"><a href="#Config—-Misc—-Entries" class="headerlink" title="Config—-Misc—-Entries"></a>Config—-Misc—-Entries</h3><p>这里是帮助我们添加一些你希望的引导路径，这个会在之后的进阶教程中讲，这里暂时略过不填写。</p><hr><h3 id="Config—-Misc—-Security"><a href="#Config—-Misc—-Security" class="headerlink" title="Config—-Misc—-Security"></a>Config—-Misc—-Security</h3><ul><li><p><strong>AllowNvramReset</strong> <code>YES</code></p><ul><li>是否在开机引导项中加入重置NVRAM功能的选项。</li></ul></li><li><p><strong>AllowSetDefault</strong> <code>YES</code></p><ul><li>是否在开机引导项中加入重置NVRAM功能的选项。</li></ul></li><li><p><strong>ApECID</strong> <code>0</code></p><ul><li>一般按默认的0填写，如果要开启安全启动的身份认证，请随便填写一串数字，比如手机号。</li></ul></li><li><p><strong>AuthRestart</strong> <code>NO</code></p><ul><li>Filevault相关项，选择NO。</li></ul></li><li><p><strong>BootProtect</strong> <code>Bootstrap</code></p><ul><li>此选项能保证OPENCORE.EFI的永久性而免遭到其他操作系统对开机顺位的破坏。在填写此项后，你同样需要保证<code>RequestBootVarRouting</code>是开启的。</li></ul></li><li><p><strong>DmgLoading</strong> <code>Any</code></p><ul><li>如果你没有开启安全启动，请填写Any；如果使用安全启动，请填写Signed（注意大小写）。</li></ul></li><li><p><strong>EnablePassword</strong> <code>NO</code></p><ul><li>此选项正在开发。</li></ul></li><li><p><strong>ExposeSensitiveData</strong> </p><ul><li>模拟nvram，填3。原生nvram，填写2。</li></ul></li><li><p><strong>HaltLevel</strong> <code>2,147,483,648</code></p><ul><li>按默认设置即可。</li></ul></li><li><p><strong>PasswordHash</strong> </p><ul><li>按默认，如果开启了<code>EnablePassword</code>，则填写密码的hash值。</li></ul></li><li><p><strong>PasswordSalt</strong> </p><ul><li>按默认，如果开启了<code>EnablePassword</code>，则填写密码的salt值。</li></ul></li><li><p><strong>ScanPolicy</strong> <code>0</code></p><ul><li>填0。我们也许会碰到开机的时候默认进入的系统永远是WINDOWS，并无法更改，之后我们在进阶教程中讲述，如何让MAC盘排在第一个，让WIN排在后面。</li></ul></li><li><p><strong>SecureBootModel</strong> <code>Disabled</code></p><ul><li>是否开启安全启动模式，一般我们填写Disabled（注意大小写）来关闭此功能。</li></ul></li><li><p><strong>Vault</strong> <code>Optional</code></p><ul><li>是否开启保险箱功能，我们选择<code>Optional</code>不开启它。</li></ul></li></ul><hr><h3 id="Config—-Misc—-Tools"><a href="#Config—-Misc—-Tools" class="headerlink" title="Config—-Misc—-Tools"></a>Config—-Misc—-Tools</h3><p>用于运行 OC 调试工具, 例如验证 CFG 锁 (VerifyMsrE2)</p><ul><li><strong>Arguments</strong><ul><li>传递的参数</li></ul></li><li><strong>Auxiliary:</strong> <code>NO</code><ul><li><code>NO</code> 默认不隐藏</li></ul></li><li><strong>Name</strong><ul><li>OpenCore 启动项中显示的名称</li></ul></li><li><strong>Enabled</strong><ul><li>启用或禁用</li></ul></li><li><strong>Path</strong><ul><li><code>Tools</code> 文件夹下的文件名</li></ul></li></ul><h2 id="Config—-NVRAM"><a href="#Config—-NVRAM" class="headerlink" title="Config—-NVRAM"></a>Config—-NVRAM</h2><h3 id="Config—-NVRAM—-Add"><a href="#Config—-NVRAM—-Add" class="headerlink" title="Config—-NVRAM—-Add"></a>Config—-NVRAM—-Add</h3><pre><code class="xml">4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14     UIScale                 Data       &lt;02&gt; //这里填写01为普通的UI显示模式，02为开启HIDPI的UI显示模式，我选择02     DefaultBackgroundColor  Data       &lt;00000000&gt; //默认开机背景色为黑色 7C436110-AB2A-4BBB-A880-FE41995C9F82     boot-args               String     Slide=1 darkwake=0 -v //slide=1表示从第一组内存开始连续注入；darkwake=0代表一键唤醒机器并偏好设置中节能选项的小憩功能。如果你要用小憩功能请填8； -v是跑代码，在没装好稳定的黑果前我建议加上，方便定位错误，弄完后再删除-v     csr-active-config       Data       &lt;e7030000&gt; //关闭SIP保护     nvda_drv                Data       &lt;31&gt; //对10.13系统之前的N卡的相关设置，我们不做讨论。     prev-lang:kbd           Data       &lt;7a682d48616e733a323532&gt; //语言设置相关，记得改成这个，这个是中文     7C436110-AB2A-4BBB-A880-FE41995C9F82 //默认就行，如果需要使用RTC屏蔽选项，具体参考《RTC综述》</code></pre><hr><h3 id="Config—-NVRAM-1"><a href="#Config—-NVRAM-1" class="headerlink" title="Config—-NVRAM"></a>Config—-NVRAM</h3><ul><li><strong>Delete</strong> <ul><li>NVRAM的数据不可被覆盖，必须先被删除再添加，我们这里按默认设置不必理会。</li></ul></li></ul><ul><li><p><strong>LegacySchema</strong> </p><ul><li><p>这里是<code>模拟NVRAM</code>的变量设置，大部分默认已经填好，我们只需添加两个变量即可。</p><p>打开7C436110-AB2A-4BBB-A880-FE41995C9F82这一栏，添加两个item如下：</p><pre><code class="bash">item 11     String      efi-boot-device item 12     String      efi-boot-device-data</code></pre></li></ul></li></ul><ul><li><strong>LegacyOverwrite</strong> <code>NO</code><ul><li>对模拟nvram用户来说，将nvram.plist写入硬件，我认为不管是原生nvram还是模拟nvram，都选择NO</li></ul></li></ul><ul><li><strong>WriteFlash</strong> <code>YES</code><ul><li>一般情况下我们需要选择YES来保证<code>启动磁盘</code>功能的正常使用，但开启后可能会在一段时间后导致CMOS被写满，主板无法经过自检。这样的问题请请参照<a href="">RTC综述</a></li></ul></li></ul><hr><h2 id="Config—-PlatformInfo"><a href="#Config—-PlatformInfo" class="headerlink" title="Config—-PlatformInfo"></a>Config—-PlatformInfo</h2><p>这里我们填合适的机型。对于最近一代的主板来说，一般的原则，只有核显的机器我们选Macmini8,1；只有独显的机器我们选择iMac Pro 1,1;有核显和独显的我们选择iMac 19,1。笔记本请按照对应的cpu型号来选择。</p><ul><li><strong>Automatic</strong> <code>YES</code><ul><li>是否自动补全系统信息。这里我选YES，不重要的信息让它自动填。</li></ul></li></ul><ul><li><p><strong>Generic</strong></p><ul><li><p>这里是我们需要填写的三码部分。</p><p>将Opencore包下Utilities/macserial程序放到桌面，在终端下输入以下命令</p><pre><code class="bash">~/desktop/macserial --model iMacPro1,1 //你也可以换成你想要的机型比如iMac 19.1</code></pre><p>输入后你回获得一些序列号以及主板主板序列号，请自己选用一组，填写到MLB以及SystemSerialNumber后重启。</p><p>重启后，请再在终端下输入：</p><pre><code class="bash">ioreg -d2 -c IOPlatformExpertDevice | awk -F\&quot; &#39;/IOPlatformUUID/&#123;print $(NF-1)&#125;&#39;</code></pre><p>得到你的主板UUID，填入Generic的SystemUUID （此操作可以帮助你的win不丢失激活）</p></li><li><p><strong>AdviseWindows</strong> <code>YES</code></p><ul><li>如果你的windows的efi不在showpicker的第一个，必须选择YES。</li></ul></li><li><p><strong>SystemMemoryStatus</strong> <code>Auto</code></p><ul><li>一些机型本身是可以升级内存，但在关于本机选项卡中不显示内存选项时需要开启，一般选择Auto。</li></ul></li><li><p><strong>SpoofVendor</strong> <code>YES</code></p><ul><li>是否把主板名称更改为ACDT，一般我们选择yes。</li></ul></li><li><p><strong>ProcessorType</strong> <code>0</code></p><ul><li>为一些es，qs或者amd的cpu在关于本机中显示核心数。</li></ul></li></ul></li></ul><ul><li><strong>UpdateDataHub</strong> <code>YES</code><ul><li>更新DataHub。</li></ul></li></ul><ul><li><p><strong>UpdateNVRAM</strong> <code>YES</code></p><ul><li>更新NVRAM。</li></ul></li><li><p><strong>UpdateSMBIOS</strong> <code>YES</code></p><ul><li>更新BIOS</li></ul></li><li><p><strong>UpdateSMBIOSMode</strong> <code>Create</code></p><ul><li>用新分配的 EfiReservedMemoryType 替换原有的表, 戴尔笔记本需要使用 <code>Custom</code> 并开启 <code>CustomSMBIOSGuid</code></li></ul></li></ul><hr><h2 id="Config—-UEFI"><a href="#Config—-UEFI" class="headerlink" title="Config—-UEFI"></a>Config—-UEFI</h2><h3 id="Config—-UEFI—-APFS"><a href="#Config—-UEFI—-APFS" class="headerlink" title="Config—-UEFI—-APFS"></a>Config—-UEFI—-APFS</h3><ul><li><p><strong>EnableJumpstart</strong> <code>YES</code></p><ul><li>从APFS容器中加载内置APFS驱动，建议开启YES。此选项仍然依据你的<code>Scanpolicy</code>来做出决定，请确保在<code>Scanpolicy</code>中放开APFS格式。</li></ul></li><li><p><strong>GlobalConnect</strong> <code>NO</code></p><ul><li>一些主板需要选择yes才能完全加载APFS，比如HP笔记本。</li></ul></li><li><p><strong>HideVerbose</strong> <code>YES</code></p><ul><li>是否隐藏啰嗦模式，一般我们需要看日志的时候才开启，所以我们选择隐藏，选择YES。</li></ul></li><li><p><strong>JumpstartHotPlug</strong> <code>YES</code></p><ul><li>是否加载APFS格式的热插设备.</li></ul></li></ul><ul><li><p><strong>MinDate</strong> <code>0</code></p><ul><li>加载最低发行的APFS格式。一些旧的apfs可能会危害电脑，我们填0。如果你想加载旧的发行日期的APFS格式硬盘，请填-1。</li></ul></li><li><p><strong>MinVersion</strong> <code>0</code></p><ul><li>加载最低版本的APFS格式。填0代表从HIGH SIERRA开始加载。填-1代表所有版本，建议填0。</li></ul></li></ul><hr><h3 id="Config—–UEFI—–Audio"><a href="#Config—–UEFI—–Audio" class="headerlink" title="Config—–UEFI—–Audio"></a>Config—–UEFI—–Audio</h3><p>此项的内容是帮助你在开机阶段驱动板载音频，此项对DP等数字音频无效。</p><ul><li><p><strong>AudioCodec</strong> <code>0</code></p><ul><li>：填写音频声卡in节点。可以用PinConfigurator提取。</li></ul></li><li><p><strong>AudioDevice</strong> <code>0</code></p><ul><li>：填写你声卡的路径。这里我们填写章节2.3.1中寻找到的声卡路径。这里我填了<code>PciRoot(0x0)/Pci(0x1f,0x3)</code>，请按你自己的实际情况填写。</li></ul></li><li><p><strong>AudioOut</strong> <code>0</code></p><ul><li>：音频声卡out节点。可以用PinConfigurator提取。</li></ul></li><li><p><strong>AudioSupport</strong> <code>NO</code></p><ul><li>：是否开启黑苹果的开机提示音支持。</li></ul></li><li><p><strong>MinimumVolume</strong> <code>20</code></p><ul><li>：声音音量，范围在0-100之间。</li></ul><p><strong>MinimumVolume</strong> <code>20</code></p><ul><li>：按照默认设置。<blockquote><p>开启UEFI加载阶段的音频你必须下载<a href="https://github.com/acidanthera/OcBinaryData/tree/master/Resources">Audio文件夹</a>,并把Audio文件夹放到ESP/EFI/OC/Resources下。另外你必须注意<code>AppleAudio</code>选项。</p></blockquote></li></ul></li></ul><hr><ul><li><p><strong>ConnectDrivers</strong> <code>YES</code></p><ul><li>是否加载补丁</li></ul></li><li><p><strong>Drivers</strong></p><pre><code class="bash">Drivers        item0     String        .................... MemoryAllocation.efi        .................... OpenRuntime.efi       .................... HFSPlus.efi        .................... OpenCanopy.efi</code></pre></li></ul><h3 id="Config—-UEFI—-Input"><a href="#Config—-UEFI—-Input" class="headerlink" title="Config—-UEFI—-Input"></a>Config—-UEFI—-Input</h3><p>此选项是原生apple开机热键的选项，需要配合我们之前设置的<code>PollAppleHotKeys=yes</code>一起用。下面的设置完全按照默认情况就行了。</p><blockquote><p>如果你是华硕的z87或者z97，你需要打开PointerSupport这个选项。</p></blockquote><hr><h3 id="Config—-UEFI—-Output"><a href="#Config—-UEFI—-Output" class="headerlink" title="Config—-UEFI—-Output"></a>Config—-UEFI—-Output</h3><ul><li><p><strong>ClearScreenOnModeSwitch</strong> <code>NO</code></p><ul><li>消除开机时从图形模式转换到文本时出现残影的问题，如果没有这个问题我们选择NO。</li></ul></li><li><p><strong>ConsoleMode</strong> <code>MAX</code></p><ul><li>主机的输出方式，一般情况下填MAX，或者留空。</li></ul></li><li><p><strong>DirectGopRendering</strong> <code>NO</code></p><ul><li>是否使用内置显卡直接渲染开机画面。</li></ul></li><li><p><strong>IgnoreTextInGraphics</strong> <code>NO</code></p><ul><li>修复在不使用-v跑马模式时候，开机日志导致的苹果logo显示不正确的问题。</li></ul></li><li><p><strong>ProvideConsoleGop</strong> <code>YES</code></p><ul><li>调用显卡GOP。</li></ul></li><li><p><strong>ReconnectOnResChange</strong> <code>NO</code></p><ul><li>一些固件在 GOP 分辨率改变后会重新连接显示器才能输出，一般情况下选择NO。</li></ul></li><li><p><strong>ReplaceTabWithSpace</strong> <code>NO</code></p><ul><li>一些固件在UEFI Shell下TAB功能键不生效，开启这个会用空格键代替。</li></ul></li><li><p><strong>Resolution</strong> </p><ul><li>开机UEFI阶段的分辨率。比如我的显示器是4K、16：9的，就填写3840x2160。根据情况填写或者不填。</li></ul></li><li><p><strong>SanitiseClearScreen</strong> <code>YES</code></p><ul><li>修复4k及以上显示器的输出问题。</li></ul></li><li><p><strong>TextRenderer</strong> <code>BuiltinGraphics</code></p><ul><li>OC开机代码字体渲染方式</li></ul></li><li><p><strong>UgaPassThrough</strong> <code>NO</code></p><ul><li>通过uga来代替那些无法使用gop的主板，一般带uefi的主板以及显卡请选择NO。</li></ul></li></ul><hr><h3 id="Config—-UEFI—-ProtocolOverrides"><a href="#Config—-UEFI—-ProtocolOverrides" class="headerlink" title="Config—-UEFI—-ProtocolOverrides"></a>Config—-UEFI—-ProtocolOverrides</h3><ul><li><p><strong>AppleAudio</strong> <code>NO</code></p><ul><li>如果你想要开启如同白苹果一样的开机音效，请开启它，并且还需要配合UEFI—-Audio的正确设置。</li></ul></li><li><p><strong>AppleBootPolicy</strong> <code>NO</code></p><ul><li>虚拟机的mac需要用的。</li></ul></li><li><p><strong>AppleDebugLog</strong> <code>NO</code></p><ul><li>重新安装苹果错误日志界面。</li></ul></li><li><p><strong>AppleEvent</strong> <code>NO</code></p><ul><li>虚拟机并具有vault的mac需要用的。</li></ul></li><li><p><strong>AppleFramebufferInfo</strong> <code>NO</code></p><ul><li>为虚拟机使用，不是虚拟机选择NO。</li></ul></li><li><p><strong>AppleImageConversion</strong> <code>NO</code></p><ul><li>重建apple图标。</li></ul></li><li><p><strong>AppleImg4Verification</strong> <code>NO</code></p><ul><li>当开启安全启动时必须开启它。</li></ul></li><li><p><strong>AppleKeyMap</strong> <code>NO</code></p><ul><li>重建苹果功能键。</li></ul></li><li><p><strong>AppleRtcRam</strong> <code>NO</code></p><ul><li>重装applertc协议。</li></ul></li><li><p><strong>AppleSecureBoot</strong> <code>NO</code></p><ul><li>苹果安全启动协议。</li></ul></li><li><p><strong>AppleSmcIo</strong> <code>YES</code></p><ul><li>代替之前的VirtualSMC.efi。</li></ul></li><li><p><strong>AppleUserInterfaceTheme</strong> <code>NO</code></p><ul><li>重新安装 Apple User Interface Theme 协议。</li></ul></li><li><p><strong>DataHub</strong> <code>NO</code></p><ul><li>重建Datahub。</li></ul></li><li><p><strong>DeviceProperties</strong> <code>NO</code></p><ul><li>虚拟机或者老款的电脑需要选择YES才能注入device property，我们选NO。如果你发现你注入device property无效，请选择YES。</li></ul></li><li><p><strong>FirmwareVolume</strong> <code>NO</code></p><ul><li>VAULT/虚拟机/老款MAC需要开启才能相关项。</li></ul></li><li><p><strong>HashServices</strong> <code>NO</code></p><ul><li>VAULT相关项。</li></ul></li><li><p><strong>OSInfo</strong> <code>NO</code></p><ul><li>通知主板以及一些程序关于MAC引导的信息，一般情况选择NO。</li></ul></li><li><p><strong>UnicodeCollation</strong> <code>NO</code></p><ul><li>旧的主板需要，我们选NO。</li></ul></li></ul><hr><h3 id="Config—-UEFI—-Quirks"><a href="#Config—-UEFI—-Quirks" class="headerlink" title="Config—-UEFI—-Quirks"></a>Config—-UEFI—-Quirks</h3><ul><li><p><strong>DeduplicateBootOrder</strong> <code>YES</code></p><ul><li>当<code>RequestBootVarRouting</code>选项为开启时，一些其他的操作系统（e.g.windows)可能在某些主板(e.g.ASUS)中会找不到自己的引导而重新创建,最终导致黑果在没有清理NVRAM的情况下是无法进入系统,或者产生多个OpenCore引导项，请选择YES。</li></ul></li><li><p><strong>ExitBootServicesDelay</strong> <code>0</code></p><ul><li>旧主板需要给予主板退出时间（单位为微秒），较新的主板直接填0。旧的主板比如Z87pro，填3000000-5000000。</li></ul></li><li><p><strong>IgnoreInvalidFlexRatio</strong> <code>NO</code></p><ul><li>如果你没有在bios中解锁<code>MSR0x194</code>，一定要选YES。</li></ul></li><li><p><strong>ReleaseUsbOwnership</strong> <code>NO</code></p><ul><li>大部分的主板都有自动释放USB所有权的功能，我们选NO。如果你开机键盘鼠标卡死了，或者USB失灵，试试选Yes。</li></ul></li><li><p><strong>RequestBootVarRouting</strong> <code>YES</code></p><ul><li>增加”启动磁盘” 的可靠性。</li></ul></li><li><p><strong>TscSyncTimeout</strong> <code>0</code></p><ul><li>帮助一些X99 X299的主板开启全核同步功能。此选项旨在代替<code>TSCAdjustReset.kext</code>等类似补丁，推荐的值是500000。但是此选项并不能在睡眠唤醒后生效，所以请填写默认值0，并使用<code>TSCAdjustReset.kext</code>来做全核同步。</li></ul></li><li><p><strong>UnblockFsConnect</strong> <code>NO</code></p><ul><li>惠普笔记本可能会让OC无法扫描到启动项，一般选择NO，如果你是惠普笔记本，请选择YES。</li></ul></li></ul><hr><h3 id="Config—-UEFI—-ReservedMemory-Properties"><a href="#Config—-UEFI—-ReservedMemory-Properties" class="headerlink" title="Config—-UEFI—-ReservedMemory Properties"></a>Config—-UEFI—-ReservedMemory Properties</h3><p>此项为保留内存所用。一些硬件会把硬件EFI写进内存过程中占据必要的UEFI运行空间，所以我们可以通过此项来预留内存来保证UEFI的运行。填写方式可以参考<a href="https://blog.daliansky.net/Slide-value-acquisition-and-calculation.html">小兵的文章</a>。来寻找指定内存的起始位置，以4K为一个节点。一般情况下，此项我们并不需要理会。</p><hr></br><h1 id="OpenCore-完善"><a href="#OpenCore-完善" class="headerlink" title="OpenCore 完善"></a>OpenCore 完善</h1><h2 id="模拟NVRAM"><a href="#模拟NVRAM" class="headerlink" title="模拟NVRAM"></a>模拟NVRAM</h2><p>对OC而言，NVRAM是非常核心的一环，不管是原生还是模拟的。<span style="color:red;">如果你是原生nvram的主板，请不必理会这章节</span>。这章节的主要内容为非原生NVRAM模拟生成NVRAM.plist。</p><ul><li><p>首先打开我们之前下载好的OpenCore，进入目录下的Utilities/LogoutHook，并将LogoutHook放入一个安全的位置。这里我推荐将他放到文档目录下。</p></li><li><p>右键finder，前往目录，填/Users, 再点进入以你名字命名的文件夹，既能看到Documents(文档）目录了，把我们的LogoutHook放在里面。</p></li><li><p>打开Terminal （终端），输入一下命令：</p><pre><code class="bash">sudo defaults write com.apple.loginwindow LogoutHook /Users/你的用户名/Documents/LogoutHook/LogoutHook.command 比如： sudo defaults write com.apple.loginwindow LogoutHook /Users/xjn/Documents/LogoutHook/LogoutHook.command</code></pre></li><li><p>终端会提示要求你输入密码（密码打进去不会显示）。</p></li><li><p>重启，你会在ESP/EFI/下看到nvram.plist，代表已经成功模拟了。</p></li></ul><hr></br><h2 id="建立自己的开机选择系统目录"><a href="#建立自己的开机选择系统目录" class="headerlink" title="建立自己的开机选择系统目录"></a>建立自己的开机选择系统目录</h2><details>  <summary><font color=red>因此部分需求太小众且繁琐，我折叠起来了，点击展开</font></summary>这个教程主要针对的是非原生nvram主板的用户，<span style="color:red;">如果你是原生nvram的用户，直接在偏好设置---启动磁盘中选定你希望设置为默认启动的磁盘即可，不必往下看浪费时间！</span> <p>此步骤可能只适合oc纯净安装的系统，如果你之前使用过clover或者oc mod版本，请参照《精解opencore》中模拟nvram的方法。</p><p>非原生nvram用户必须完成以下几点：</p><ul><li><p>通过3.1的教程建立nvram.plist.</p></li><li><p>确保OpenCore的版本为2019年11月20日之后的。更新OpenCore替换BOOT/BOOTx64.efi以及OC/OpenCore.efi即可。</p></li><li><p>确保config.plist下/Misc/Security/<code>ExposeSensitiveData</code>=3 ;  Booter/Quirks/<code>DisableVariableWrite</code>=YES ; NVRAM/<code>LegacyEnable</code>=YES </p></li><li><p>确保文件夹ESP/EFI/OC/Drivers/下没有<code>VariableRuntimeDxe.efi</code></p></li></ul><p>如果你是华硕的非原生nvram主板，你还需要做（此文件由群友@哞 提供）：</p><ul><li>下载<a href="">LoginHook.command</a>，把它与LogoutHook.command放在一起，并执行:<pre><code class="bash">sudo defaults write com.apple.loginwindow LoginHook /写上你的路径/LoginHook.command</code></pre></li></ul></br><blockquote><p>3.2.1以及3.2.2也是排列启动盘开机进入顺序的，比较麻烦，不推荐。</p></blockquote><hr><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们首先要对Config—Misc—Security—scanpolicy这个值进行修改，默认的是0，代表着扫描所有硬盘，而我们现在只让它扫我们的苹果系统硬盘。</p><p>感谢@xlivans提供的OC扫描策略：</p><blockquote><p>  - <code>2F0303</code> —官方推荐值+允许扫描HFS文件系统+允许扫描USB设备</p></blockquote><blockquote><p>    最终<code>扫描策略数值</code> = <code>3080963</code></p></blockquote><blockquote><p>OC-引导扫描策略</p></blockquote><blockquote><ul><li>设置位置：<code>Misc\Security\ScanPolicy</code></li></ul></blockquote><blockquote><ul><li><strong>定义：</strong></li></ul></blockquote><blockquote><p>  （01）0x00000001 — 限定为文件系统，由以下<code>允许扫描文件系统子项</code>开启</p></blockquote><blockquote><p>  （02）0x00000002 — 限定为设备类型，由以下<code>允许扫描设备类型子项</code>开启</p></blockquote><blockquote><p>  <code>允许扫描文件系统子项</code>：</p></blockquote><blockquote><p>  （03）0x00000100 — 允许扫描APFS文件系统</p></blockquote><blockquote><p>  （04）0x00000200 — 允许扫描HFS文件系统</p></blockquote><blockquote><p>  （05）0x00000400 — 允许扫描EFI系统分区文件系统</p></blockquote><blockquote><p>  <code>允许扫描设备类型子项</code>：</p></blockquote><blockquote><p>  （06）0x00010000 — 允许扫描SATA设备</p></blockquote><blockquote><p>  （07）0x00020000 — 允许扫描SAS和Mac NVMe设备</p></blockquote><blockquote><p>  （08）0x00040000 — 允许扫描SCSI设备</p></blockquote><blockquote><p>  （09）0x00080000 — 允许扫描NVMe设备</p></blockquote><blockquote><p>  （10）0x00100000 — 允许扫描CD / DVD设备</p></blockquote><blockquote><p>  （11）0x00200000 — 允许扫描USB设备</p></blockquote><blockquote><p>  （12）0x00400000 — 允许扫描FireWire设备</p></blockquote><blockquote><p>  （13）0x00800000 — 允许扫描读卡器设备</p></blockquote><blockquote><p>  <code>扫描策略数值</code>=（01）+（02）+1个或数个<code>允许扫描文件系统子项</code>+1个或数个<code>允许扫描设备类型子项</code></p></blockquote><blockquote><p>  例如：希望扫描对象是APFS文件系统的USB设备，<code>扫描策略数值</code>=（01）+（02）+（03）+（11），经16进制加法计算得出，<code>扫描策略数值</code>=<code>0x200103</code>。</p></blockquote><blockquote><p>  <code>注意</code>，使用时需将16进制转换为10进制。示例最终<code>扫描策略数值</code>=<code>2097411</code></p></blockquote><blockquote><ul><li>几种扫描策略</li></ul></blockquote><blockquote><p>  - <code>F0103</code> —官方推荐值：（01）+（02）+（03）+（06）+（07）+（08）+（09）</p></blockquote><p>  </p><blockquote><p>    最终<code>扫描策略数值</code> = <code>983299</code></p></blockquote><p>  </p><blockquote><p>  - <code>0</code>—允许扫描所有已知文件系统+允许扫描所有已知设备类型。</p></blockquote><p>  </p><blockquote><p>  - <code>2F0303</code> —官方推荐值+允许扫描HFS文件系统+允许扫描USB设备</p></blockquote><p>  </p><blockquote><p>    最终<code>扫描策略数值</code> = <code>3080963</code></p></blockquote><p>我们这里让OC只扫描MAC盘。根据说明，（1）+（2）是必须选的；因为我的MAC是APFS，所以系统子项类我选（3）；我的MAC是安装在NVME上的，所以我在设备类型上选择（09），如果你是安装在sata盘上的，你应该选（6）。</p><p>这样我们的公式就是：</p><pre><code class="bash">（1）+（2）+（3）+（9）= 0x00000001+0x00000002+0x00000100+0x00080000</code></pre><p>拿起苹果自带的计算器，按住<code>command+3</code>切换到编程型计算器，并转换到16进制模式:</p><pre><code class="bash">1+2+100+80000=80103</code></pre><p>得到数值后，我们再按一下转换10进制的按键，得出<code>524547</code>这个数值。</p><p>我们把<code>524547</code>填到<code>scanpolicy</code>中，重启，你就会看到第一个选项就是你的MAC盘了。但如果你还安装了WINDOWS什么的，选项中却没有了，别急，我们现在要把WIN的引导添加到mac的后面去。</p><hr><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>现在我们要在开机画面中，将其他的一些系统排在mac后面。此项需要你下载debug版本的Opencore,请在文章开始部分提到的Opencore程序下载界面进行下载，并备份好你目前的EFI。</p><p>首先我们需要把下载好的Opencore-Debug版本里的ESP/EFI/BOOT/BOOTx64.efi 以及ESP/EFI/OpenCore.efi两个文件替换到你正在使用中的EFI里去。修改你正在使用的EFI/OC/Config.plist:</p><pre><code class="xml">Misc     Debug        DisableWatchDog    Boolean    YES        Target             Number     65      Security        ScanPolicy         Number     0 //这里我们要先改为0来寻找windows的地址，之后找到后改回之前算出来的即可</code></pre><p>接着，我们需要寻找你其他系统的UUID，我们打开终端，输入</p><pre><code class="bash">diskutil list</code></pre><p>找到你需要的盘的盘名，比如我的windows在disk0这个位置，而引导WIN的EFI文件夹的盘位是disk0s1。注意，Windows必须为<code>GPT引导模式</code>。</p><pre><code class="bash">/dev/disk1 (internal, physical):   #:                       TYPE NAME                    SIZE       IDENTIFIER   0:      GUID_partition_scheme                        *1.0 TB     disk0   1:                        EFI                         314.6 MB   disk0s1   2:       Microsoft Basic Data BOOTCAMP                999.7 GB   disk0s2</code></pre><p>接着输入：</p><pre><code class="bash">diskutil info disk0s1</code></pre><p>在输出内容里，我们需要的是<code>Disk / Partition UUID</code>，我的是FF555974-AB3F-40B7-8530-AE6462E197CE，把它记下来。</p><p>现在我们通过oc的开机选项直接重启到windows，我们打开<a href="https://www.diskgenius.cn/download.php">DiskGenius</a>，并且到我们mac的EFI盘符下，我们看到有一个日志报告opencore-xxxxx-xxxxx生成，为了好记，我们右键把它改名叫111.txt，并拖到桌面。</p><p>打开刚才的111.txt，我们搜索刚才记录下来的FF555974-AB3F-40B7-8530-AE6462E197CE</p><p>搜到类似这样的路径就是我们需要的：</p><pre><code class="bash">PciRoot(0x0)/Pci(0x1B,0x0)/Pci(0x0,0x0)/NVMe(0x1,CB-27-B3-91-53-38-25-00)/HD(1,GPT,FF555974-AB3F-40B7-8530-AE6462E197CE,0x800,0x96000)/\EFI\BOOT\BOOTX64.EFI</code></pre><p>把之前我们备份好的EFI，全部替换回去。把<code>disablewatchdog</code>，<code>target</code>，<code>scanpolicy</code>都改回原来的。这样我们的EFI又回到正式版本了，而不是DEBUG版本了。</p><p>回到Mac，打开config.plist,我们把win的引导路径添加到misc—-entries，并在此下面添加一个item,输入如图内容：</p><pre><code class="xml">Entries   Arguments     String       Comment       String     Windows 10//你随便取个名字   Enabled       Boolean    YES   Name          String     Windows 10/开机选择界面的名字   Path          String     PciRoot(0x0)/Pci(0x1B,0x0)/Pci(0x0,0x0)/NVMe(0x1,CB-27-B3-91-53-38-25-00)/HD(1,GPT,FF555974-AB3F-40B7-8530-AE6462E197CE,0x800,0x96000)/\EFI\BOOT\BOOTX64.EFI</code></pre><p>保存重启后，你会看到windows10放在了mac的下面。</p><blockquote><p>tips: 你可以<code>showpicker</code>选择no，就不会看到选择界面了，而当你需要时，只需要在开机时候按住option或者esc就可以唤出选择界面了，非常白果的体验哦。</p></blockquote></details><hr><h2 id="提取DSDT"><a href="#提取DSDT" class="headerlink" title="提取DSDT"></a>提取DSDT</h2><p>尽管提取原始DSDT的方法非常多，我认为<code>CLOVER</code>的提取方法是最方便并且靠谱的。我们需要一个空的U盘或者空的ESP分区，我的教程是非常偏向小白的，所以这里提取我也会用到windows，以及Diskgenius这个软件，做最简单的示范。</p><ul><li><p>进入Windows，插入U盘，打开<a href="https://www.diskgenius.cn/download.php">DiskGenius</a>，选中我们的U盘，并选择顶部菜单栏的快速分区</p><ul><li>分区表类型：<code>GUID</code></li><li>不要创建新的<code>ESP</code>分区</li><li>不要创建<code>MSR</code>分区</li><li>分区格式为<code>FAT32</code></li></ul></li><li><p>格式化完成后，放入我从黑果小兵镜像包提取出来的<a href="/tools/EFI.zip">EFI</a>放进去。这是一个clover引导，但并不能引导你的系统，只能提取DSDT。</p></li><li><p>插上U盘，重启，通过U盘引导，看到Clover界面，我们按F4，这样原始的DSDT文件就收集好了。</p></li></ul><ul><li>重新通过OC引导进入系统，我们打开U盘，EFI/Clover/ACPI/Orgin下，有我们的原始ACPI内容，我们只需要DSDT.aml这个就行了，保存到安全的地方。</li></ul><h2 id="加载原生电源管理"><a href="#加载原生电源管理" class="headerlink" title="加载原生电源管理"></a>加载原生电源管理</h2><p>提取DSDT后使用MaciASL打开，搜索你CPU的名字。一般情况下，CPU的名字可能是: <code>PR.CPU0</code>,<code>PR.P000</code>,<code>PR.PR00</code>,<code>SB.CPU0</code>,<code>SB.P000</code>,<code>SB.PR00</code>, <code>SCK0.C000</code>, <code>SCK0.CPU0</code>。请依次搜索直到找到自己的CPU名字，比如我的就是<code>SCK0.C000</code></p><pre><code class="asl">Processor (C000, 0x00, 0x00001810, 0x06)                &#123;                    Name (_HID, &quot;ACPI0007&quot; /* Processor Device */)  // _HID: Hardware ID                    Name (_UID, &quot;SCK0-C000&quot;)  // _UID: Unique ID                    Method (_PXM, 0, NotSerialized)  // _PXM: Device Proximity                    &#123;                        If ((CLOD == 0x00))                        &#123;                            Return (0x00)                        &#125;                        Else                        &#123;                            Local0 = DerefOf (APT0 [0x00])                            Local1 = CNBS /* \CNBS */                            Local1 -= 0x01                            Local0 &gt;&gt;= Local1                            Local0 &amp;= 0x01                            Local1 = 0x00                            Local1 *= 0x02                            If ((Local0 == 0x01))                            &#123;                                Local1 += 0x01                            &#125;                            Return (Local1)                        &#125;                    &#125;</code></pre><p>打开宪武大大的<a href="https://github.com/daliansky/OC-little">OC Little</a>，到<code>05-注入设备/05-1-注入x86/</code>目录下，我们看到宪武大大已经把大部分不同名字的CPU的dsl文件都做好了。我的CPU名字叫<code>SCK0.C000</code>，打开SSDT-PLUG-_SCK0.C000.dsl，左上角另存为（save as), 其中文件格式(file format)必须选择<code>ACPI Machine Language Binary</code>，文件名字随便写吧，我就叫plug-xcpm.aml，记住后缀为aml。</p><p>将plug-xcpm.aml放入EFI/OC/ACPI下，并在config.plist中添加加载此aml文件:</p><pre><code class="xml">ACPI  Add     Item 0       Comment    String       plug-xcpm      Enable     Boolean      YES       Path       String       plug-xcpm.aml</code></pre><p>加载后，重启，并清理一次nvram，我们看到偏好设置–节能中，原生电源管理已经被加载了。</p><h3 id="节能五项"><a href="#节能五项" class="headerlink" title="节能五项"></a>节能五项</h3><p>节能五项是白果台式机中，<code>系统偏好设置</code>—<code>节能</code>中的五个选项。在加载原生电源管理后，一般有4项节能出现，而第五项“断电后重启”这项还需要加载PPMC以及LPCB下的PMCR才能出现。虽然没啥鸟用，但对于强迫者而言，少一个一定很难受吧。如果你是笔记本，不需要看这章，白果笔记本本身没有。如果你没有机械硬盘，也不会出现<code>Put hard disks to sleep when possible</code>。</p><p>直接下载<a href="/tools/SSDT-PM.zip">SSDT-PM.aml</a>载入即可。</p><hr><h2 id="解锁Mac-OS的系统目录"><a href="#解锁Mac-OS的系统目录" class="headerlink" title="解锁Mac OS的系统目录"></a>解锁Mac OS的系统目录</h2><p>bugprogrammer给出了一个一劳永逸的解决方案：</p><p><a href="http://www.bugprogrammer.me/2019/07/13/unlockSystem.html">解锁macOS10.15的系统分区</a></p><p>11系统的解锁略麻烦：<a href="https://www.bugprogrammer.me/2020/07/09/about-BigSur.html#%E5%88%A0%E9%99%A4%E5%BF%AB%E7%85%A7%EF%BC%8C%E9%87%8D%E8%8E%B7%E6%9D%83%E9%99%90">解锁MacOS11的系统区</a></p><hr><h2 id="关于EC控制器"><a href="#关于EC控制器" class="headerlink" title="关于EC控制器"></a>关于EC控制器</h2><p>EC控制器是电脑自带的一个叫embedded controller的部件。在10.15的系统环境中，笔记本电脑必须重命名原来的EC，而一些台式机主板则需要禁用。下面我会分开来讲解如何禁用EC、如何加载USB电源管理支持。</p><hr><h3 id="禁用EC控制器"><a href="#禁用EC控制器" class="headerlink" title="禁用EC控制器"></a>禁用EC控制器</h3><p><a href="#1.0">之前的章节</a>中提供了重命名这种方式去讲EC0更名为EC，其实这种方法是只适合笔记本的，台式机最好还是禁用EC。</p><p>打开之前提取出来的DSDT.aml，搜索<code>PNP0C09</code>，这里我搜到我的EC真实名字叫做<code>H_EC</code>，你的可能叫<code>EC0</code>或者别的什么奇怪的名字。</p><p>这里我可以看到我的<code>H_EC</code>已经是屏蔽掉的，怎么判定，你看下面有一个<code>Return (Zero)</code>，意味着这个部件是不生效的，即禁用。这样的情况我们不需要做任何SSDT去禁用这个真的EC。</p><pre><code class="asl">    Scope (_SB.PCI0.LPCB)    &#123;        Device (H_EC)        &#123;            Name (_HID, EisaId (&quot;PNP0C09&quot;) /* Embedded Controller Device */)  // _HID: Hardware ID            Name (_UID, One)  // _UID: Unique ID            Method (_STA, 0, NotSerialized)  // _STA: Status            &#123;                ^^^GFX0.CLID = 0x03                Return (Zero)            &#125;</code></pre><p>那么什么样的情况是需要我们去屏蔽的呢？我发现基本上华硕的台式机主板都会启用这个EC控制器，下面代码是华硕主板的EC部件，搜索<code>PNP0C09</code>，我们看到这种情况下，这个叫EC0的<code>EC</code>控制器是开启的，注意他没有<code>return (Zero)</code>这个语句，我们需要通过SSDT去屏蔽它。</p><pre><code class="asl">        Device (EC0)        &#123;            Name (_HID, EisaId (&quot;PNP0C09&quot;) /* Embedded Controller Device */)  // _HID: Hardware ID            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings            &#123;                IO (Decode16,                    0x0062,             // Range Minimum                    0x0062,             // Range Maximum                    0x00,               // Alignment                    0x01,               // Length                    )                IO (Decode16,                    0x0066,             // Range Minimum                    0x0066,             // Range Maximum                    0x00,               // Alignment                    0x01,               // Length                    )            &#125;)</code></pre><p>这里我提供了一个禁用EC的补丁，请直接下载，打开后左上角另存为（save as), 其中文件格式(file format)必须选择ACPI Machine Language Binary，文件名字随便写吧，我就叫ssdt-no-EC.aml，记住后缀为aml。将ssdt-no-EC.aml放入EFI/OC/ACPI下，并在config.plist中加载此aml文件。<br>直接下载<a href="/tools/SSDT-no-EC.dsl.zip">SSDT-PM.aml</a>载入即可。</p><p>如果你的EC名字叫H_EC或者别的什么的，你打开这个.dsl文件，替换代码中所有的EC0为H_EC。</p><pre><code class="asl">&#123;    External (_SB.PCI0.LPCB, DeviceObj)    External (_SB_.PCI0.LPCB.H_EC, DeviceObj)    Scope (\_SB.PCI0.LPCB.H_EC)    &#123;        Method (_STA, 0, NotSerialized)  // _STA: Status        &#123;            If (_OSI (&quot;Darwin&quot;))            &#123;                Return (0)            &#125;            Else            &#123;                Return (0x0F)            &#125;        &#125;    &#125; &#125;</code></pre><blockquote><p>当你的电脑没有EC后，你仍然需要仿冒EC来完成全部操作。</p></blockquote><hr><h3 id="重命名EC控制器"><a href="#重命名EC控制器" class="headerlink" title="重命名EC控制器"></a>重命名EC控制器</h3><p>笔记本不能禁用EC，禁用EC后会直接导致笔记本没有电池。那么我们怎么去重命名EC呢？按照上面提到的方法，找到你EC的真实名字，在<a href="#1.0">之前的章节</a>中我提供了假如你的笔记本的EC叫做<code>EC0</code>时候的重命名办法，那如果你的EC叫别的乱七八糟的名字呢？</p><p>EC名，比如你的EC叫做<code>H_EC</code>，我们打开在线的<a href="https://tool.lu/hexstr/">HEX转换器</a>，输入<code>H_EC</code>，并点击下面的16进制转换，就可以看到转换出来的值是<code>485F4543</code>，把这个值替换到<code>Find</code>这个选项卡中就行了。你也会注意到，EC的hex-16进制为<code>45435F5F</code>，刚好是<code>Replace</code>的值。这就是一个非常简单实用的OC重命名。切记！OC万不得已不要用重命名！</p><pre><code class="xml">Comment: H_EC to EC Count:0 Enabled:YES Find:&lt;485F4543&gt; Limit:0 Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;45435F5F&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><hr><h3 id="仿冒EC及USBX供电"><a href="#仿冒EC及USBX供电" class="headerlink" title="仿冒EC及USBX供电"></a>仿冒EC及USBX供电</h3><p>禁用EC后你需要创建仿冒EC来进入系统，同时开启USB的快速供电技术（需设备支持）。你可以比较下面两张图，第二张是功能正确开启的。<br><img src="https://i.loli.net/2020/10/31/qonmCcpUJyrk84g.png" alt="Screen Shot 2020-10-31 at 3.40.07 PM.png"></p><p>这部分内容是仿冒EC，注意不是每一个DSDT的路径都在<code>SB.PCI0.LPCB</code>，请搜索<code>0x001F0000</code>来确定实际位置和名称。比如我的主板是在<code>SB.PC00.LPC0</code>。</p><pre><code class="asl">    Scope (\_SB.PCI0.LPCB)    &#123;        Device (EC)        &#123;            Name (_HID, &quot;ACID0001&quot;)  // _HID: Hardware ID            Method (_STA, 0, NotSerialized)  // _STA: Status            &#123;                If (_OSI (&quot;Darwin&quot;))                &#123;                    Return (0x0F)                &#125;                Else                &#123;                    Return (Zero)                &#125;            &#125;        &#125;    &#125;</code></pre><p><img src="https://i.loli.net/2020/10/31/vhNd2tGwArqlZuk.png" alt="Screenshot-2020-02-05-at-10.47.54-AM.png"></p><hr><h2 id="睡眠即醒的相关问题"><a href="#睡眠即醒的相关问题" class="headerlink" title="睡眠即醒的相关问题"></a>睡眠即醒的相关问题</h2><p>睡眠即醒很大程度上跟USB的定制相关，一般一个好的USB定制就能解决睡眠即醒的问题。当然还有很多无法解决的问题，比如蓝牙不能在HUB下进行内建，等等。甚至有些时候我们都不知道为什么黑果会睡不着，那有没有一个办法让黑果强制睡眠呢？答案是有的。经过我的摸索，有几种方法能达到强制睡眠的效果，只是方法不同而已，但主要围绕的还是0d/6d的数值来做一些工作。这些方法涉及了很多OC领域的一些小技巧，我也顺便展示给大家。</p><blockquote><p>0d/6d补丁是阻止一些部件参与唤醒工作，这其中包括了xhc部件，意味着你无法使用鼠标键盘唤醒，只能用电源键唤醒。但若你有一组除了xhc之外的usb控制器，那把键盘鼠标插在那两个控制器上，可以在使用强制睡眠的情况下用键盘鼠标唤醒电脑。</p></blockquote><hr><h3 id="分辨0D-06"><a href="#分辨0D-06" class="headerlink" title="分辨0D/06"></a>分辨0D/06</h3><p>主板一般有5个部件是直接参与唤醒工作的，这五个部件分别是XHC（USB控制器）、CNVW（CNVI网卡，如果你的主板自带的话）、GLAN（有线网卡）、XDCI（USB相关）、HDEF（音频）。旧的一些主板可能会有不同的命名，比如XHC有叫EH01，HDEF叫做HDAS等，这里不做讨论。而这些设备往往会直接影响睡眠，比如你输入：</p><pre><code class="bash">log show --last 1d | grep &quot;Wake reason&quot;</code></pre><p>我们会看到类似的输出结果</p><pre><code class="bash">2020-10-31 03:35:45.196371+0800 0x74       Default     0x0                  0      0    kernel: (AppleACPIPlatform) AppleACPIPlatformPower Wake reason: XDCI CNVW2020-10-31 03:35:45.196373+0800 0x74       Default     0x0                  0      0    kernel: (AppleACPIPlatform) AppleACPIPlatformPower Wake reason: XDCI CNVW</code></pre><p>那么即是<code>XDCI</code> <code>CNVW</code>导致了睡眠出现了问题。于是，我们用几种方法去屏蔽或者说修改这些部件，来达到电脑正常睡眠的效果。</p><p>我们打开之前提取的SSDT，随便搜索五大部件中的一个，比如说XDCI：<br><img src="https://i.loli.net/2020/10/31/k5jDCx9c3WdJunh.png" alt="截屏2019-11-07下午11.06.02.png"></p><p>主要是看上图中<code>XDCI</code>下的<code>_PRW</code>属性值，可以直接看到Return的值为<code>GPRW (0x6D, 0x04)</code>。其中<code>6D</code>这个数值看主板而定，有些主板叫做<code>0D</code>，而后面<code>04</code>这个值的含义为S4级别的电源管理，即休眠甚至关机情况下的唤醒；有些后面的数值是<code>03</code>，代表着S3级电源管理。这个我打一个大家比较熟悉的例子，<code>GLAN</code>这个网卡部件的<code>PRW</code>值也是<code>0x04</code>，为什么要是<code>04</code>呢？因为这样我们可以使用远程通过网络启动主机功能。</p><h4 id="方法一-OC-全局重命名强制睡眠"><a href="#方法一-OC-全局重命名强制睡眠" class="headerlink" title="方法一: OC 全局重命名强制睡眠"></a>方法一: OC 全局重命名强制睡眠</h4><p>上一步中已经确认了你的主板是0D还是06，打开OC little的060D补丁，选择合适自己主板的补丁集，比如我的是<code>Name-6D更名.plist</code>。将补丁抄入自己的<code>Config.plist</code>后重启生效。</p><blockquote><p>全局重命名会导致其他系统无法通过OC引导开机，不建议使用。</p></blockquote><hr><h4 id="方法二-沿用Clover版本的0D-06补丁-amp-展示TgtBridge在OC下的用法"><a href="#方法二-沿用Clover版本的0D-06补丁-amp-展示TgtBridge在OC下的用法" class="headerlink" title="方法二: 沿用Clover版本的0D/06补丁&amp;展示TgtBridge在OC下的用法"></a>方法二: 沿用Clover版本的0D/06补丁&amp;展示TgtBridge在OC下的用法</h4><p>宪武大大做的clover版本的0d/6d补丁，其实没啥必要讲，只是有留言问了tgtbridge在oc下怎么用，那我就展示一下吧。这个补丁原理是一样的，通过重命名的方式改_prw。</p><p>直接下载宪武大大的<a href="https://github.com/daliansky/P-little/tree/master/%E9%83%A8%E4%BB%B6%E8%A1%A5%E4%B8%81%E5%8C%85/11-1-%E7%9D%A1%E4%BA%86%E5%8D%B3%E9%86%92(0D:6D)%E8%A1%A5%E4%B8%81">clover hotpatch</a>补丁包，打开plist文件。那我们拿出一组数据来讲解怎么把它翻译成oc版本：</p><pre><code class="xml">Comment      String       XHC:_PRW to XPRW Disabled     Boolean      True//此补丁并未生效，这里要改成false才会生效 Find         5F505257         //hex转text的含义即是：_PRW Replace      58505257         //hex转text的含义即是：XPRW TgtBridge    5848435F         //hex转text的含义即是：XHC_</code></pre><p>这组改名是对XHC下的PRW改名为xprw，这样的话，之前prw下的(0x6D, 0x04)即不生效了。而指定xhc的方法即是使用了tgtbridge，因为整张dsdt上有几十上百个_PRW，你必须通过tgtbridge来指定到底是哪一个部件的_PRW。</p><p>那么OC到底怎么使用tgtbridge来特定某一部件下的内容重命名呢？我们先把上面一段clover的补丁转换成oc的版本先吧：</p><pre><code class="xml">Comment           String        XHC:_PRW to XPRWCount             Number                      //需要重点解释 Enabled           Boolean       True          //表示应用此补丁，不应用选False Find              Data          5F505257      //hex转text的含义即是：_PRWLimit             Number        0             //这个按默认即可 不去管他Mask              Data          &lt;&gt;            //这个按默认即可 不去管他OemTableId        Data          &lt;&gt;            //这个按默认即可 不去管他Replace           Data          58505257      //hex转text的含义即是：XPRWReplaceMask       Data          &lt;&gt;            //这个按默认即可 不去管他Skip              Number                      //需要重点解释 TableLength       Number        0             //这个按默认即可 不去管他TableSignature    Data          44534454      //hex转text的含义即是：DSDT，这里按默认即可，代表对dsdt进行修改</code></pre><p>这里就是一个还没全部翻译好的oc版改名xhc的prw。那么如何定位xhc下的_prw呢，主要是填写<code>Count</code>和<code>Skip</code>。其实oc的<code>tgtbridge</code>是通过一个个数过去来定位具体哪一个位置的。比如xhc的prw是整张dsdt里面的第55个，那<code>skip</code>填54，意味着跳过前54个，从第55个开始执行。那执行多少次呢？执行一次<code>count</code>就填1；比如你要同时改第55个和56个，那count就填2。说了这么多，我来实操一下吧：</p><p>打开dsdt，在左下角直接搜索_PRW，就能把整张表的_PRW筛选出来了：<br><img src="https://i.loli.net/2020/10/31/EfxazsJNZLKmgv3.png" alt="截屏2019-11-08上午2.57.43.png"></p><p>我总共数了一下，一共有56个_PRW。我们再在主内容栏上按command+f搜索xhc，直接找到xhc的_PRW，刚好我们看到我的xhc实在整张表的倒数第4个，也就是正数第53个：</p><p><img src="https://i.loli.net/2020/10/31/SzvArXcH4OimtR9.png" alt="截屏2019-11-08上午3.00.36.png"></p><p>那么我们就可以补充完整张表了：</p><pre><code class="xml">Comment          String       XHC:_PRW to XPRW Count            Number       1Enabled          Boolean      True Find             Data         5F505257Limit            Number       0 Mask             Data         &lt;&gt; OemTableId       Data         &lt;&gt; Replace          Data         58505257 ReplaceMask      Data         &lt;&gt; Skip             Number       52 TableLength      Number       0 TableSignature   Data         44534454</code></pre><p>如果你想第53、54、55个都改掉，那count就写3，意味着顺序执行3次。好了，就这样，有问题留言。</p><h4 id="方法三：配合SSDT-重命名的强制睡眠补丁（推荐）"><a href="#方法三：配合SSDT-重命名的强制睡眠补丁（推荐）" class="headerlink" title="方法三：配合SSDT+重命名的强制睡眠补丁（推荐）"></a>方法三：配合SSDT+重命名的强制睡眠补丁（推荐）</h4><p>oc不提倡用户直接全局重命名，如果真的要用重命名，也一定是搭配ssdt去做重命名，所以这个方法也是宪武大大和我最推荐的一种方法。</p><p>打开宪武大大的OC-SSDT包，找到0D/6D文件夹，打开<code>SSDT-GPRW.dsl</code>。</p><pre><code class="asl">// In config ACPI, GPRW to XPRW // Find: 47505257 02 // Replace: 58505257 02 //这里提示你要应用这个补丁，你必须在config中的ACPI-PATCH里面加入如上重命名内容 // DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;ACDT&quot;, &quot;GPRW&quot;, 0) &#123;   External(XPRW, MethodObj) //寻找dsdt表中叫做XPRW的内容，这是要你在config中先把gprw改名成xprw才会生效，这就是为什么这个补丁的重命名必须是这个ssdt和重命名一起用的原因，你第一个重命名不生效，这个ssdt也不会生效。   Method (GPRW, 2, NotSerialized)   &#123;     If (_OSI (&quot;Darwin&quot;)) //为了不破坏dsdt完整性，这里做了系统判断，当你运行windows的时候，此ssdt不生效     &#123;        If ((0x6D == Arg0)) //如果你的dsdt中是6D进行判断        &#123;          Return (Package ()          &#123; 0x6D,            Zero          &#125;)        &#125;        If ((0x0D == Arg0)) //如果你的dsdt中是0D进行判断        &#123;          Return (Package ()          &#123; 0x0D,            Zero           &#125;)         &#125;       &#125;   Return (XPRW (Arg0, Arg1)) //当运行mac系统时，如果你的dsdt中XPRW为6d，或者0d时返回为0，即屏蔽。   &#125;&#125;</code></pre><p>这个ssdt不需要你改任何内容，打开后左上角另存为（save as), 其中文件格式(file format)必须选择ACPI Machine Language Binary，文件名字就叫，记住后缀为aml。记得将ssdt-gprw.aml放入EFI/OC/ACPI下，并在config.plist中加载此aml文件。</p><p>同时，我们需要在ACPI—Patch下增加一条全局重命名来配合此SSDT。</p><pre><code class="xml">Comment: GPRW to XPRW Count:0 Enabled:YES Find:&lt;4750525702&gt; Limit:0 Mask:&lt;&gt; OemTable:&lt;&gt; Replace:&lt;5850525702&gt; ReplaceMask:&lt;&gt; Skip:0 TableLength:0 TableSignature:&lt;&gt;</code></pre><hr><h2 id="OC官方内核补丁集介绍"><a href="#OC官方内核补丁集介绍" class="headerlink" title="OC官方内核补丁集介绍"></a>OC官方内核补丁集介绍</h2><p>这里会长期更新OC官方提供的Kernel Patch。</p><hr><h3 id="华硕等机型开机卡F1"><a href="#华硕等机型开机卡F1" class="headerlink" title="华硕等机型开机卡F1"></a>华硕等机型开机卡F1</h3><p>注意此kp补丁只对10.14.4以上系统版本生效，旧的我懒得提供了，需要留言。更好的解决卡f1的方案请参照《rtc综述》</p><pre><code class="xml">Kernel   Patch      Item 0      Base         String      Comment      String    f1 patch （随便填，好记就行）      Count        Number    1      Enabled      Boolean   Yes      Find         Data      75330fb7      Identifier   String    com.apple.driver.AppleRTC      Limit        Number    0      Mask         Data           MaxKernel    String      MinKernel    String      Replace      Data      eb330fb7     ReplaceMask  Data      Skip         Number    0</code></pre><hr><h3 id="关机卡RTC"><a href="#关机卡RTC" class="headerlink" title="关机卡RTC"></a>关机卡RTC</h3><pre><code class="xml">Kernel     Patch       Item 2        Base         String      __ZN8AppleRTC14updateChecksumEv        Comment      String      Disable RTC ck poweroff（随便填，好记就行）        Count        Number      1        Enabled      Boolean     Yes       Find         Data        Identifier   String      com.apple.driver.AppleRTC        Limit        Number      0        Mask         Data        MaxKernel    String        MinKernel    String        Replace      Data        c3        ReplaceMask  Data        Skip         Number      0</code></pre><hr><h2 id="300系列主板开启原生NVRAM"><a href="#300系列主板开启原生NVRAM" class="headerlink" title="300系列主板开启原生NVRAM"></a>300系列主板开启原生NVRAM</h2><p>打开你的DSDT，搜索<code>001F0000</code>，确定自己的</p><ul><li>lpc部件名字，如图示，我的lpc部件名叫做<code>LPC0</code>, 别的主板可能叫做<code>LPCB</code>，请根据实际情况记录</li><li>lpc的路径，如图左下角红线提示，我的LPC路径在<code>_SB_.PC00.LPC0</code></li></ul><p><img src="https://i.loli.net/2020/11/01/fO69YhztbwBrMsd.png" alt="Screenshot-2020-02-05-at-10.47.54-AM.png"></p><ul><li>下载<a href="/tools/SSDT-EC-USBX.dsl.zip">SSDT-PMC.dsl</a>，根据自己的dsdt编辑相关内容：</li></ul><p><img src="https://i.loli.net/2020/11/01/gCaplW4bBY39KJs.png" alt="Screenshot-2020-02-05-at-10.53.33-AM.png"></p><p>左上角另存为（save as), 其中文件格式(file format)必须选择ACPI Machine Language Binary，文件名字随便写吧，我就叫ssdt-pmc.aml，记住后缀为aml。记得将ssdt-pmc.aml放入EFI/OC/ACPI下，并在config.plist中添加加载此aml文件。</p><ul><li><p>如果你之前模拟过nvram，请执行以下命令删除相关模拟内容：</p></li><li><pre><code class="bash"># 删除文件 LogoutHook.command sudo rm -rf $(sudo defaults read com.apple.loginwindow LogoutHook) # 清空 LogoutHook 的触发设置 sudo defaults delete com.apple.loginwindow LogoutHook</code></pre></li><li><p>删除EFI下的nvram.plist。</p></li><li><p>同时你需要对config.plist进行设置：</p><ul><li>NVRAM—LegacyEnable 选择No</li><li>NVRAM—LegacyOverwrite 选择No</li><li>Booter—Quirks—-DisableVariableWrite 选择no</li><li>你也许要打开NVRAM—WriteFlash 选择YES（请尽可能不要选！）</li></ul></li></ul><hr><h1 id="OpenCore-进阶"><a href="#OpenCore-进阶" class="headerlink" title="OpenCore 进阶"></a>OpenCore 进阶</h1><p>以下内容对你正常使用黑苹果已经无关了，如果你追求更好的黑果表现，可以看下去，但这部分内容也需要你自己有更好的能力与耐心。如果你不具备足够的条件，我不建议你看下去；如果你的失误导致硬件的损坏，我也不会、也没能力负责。</p><hr><h2 id="CPU的变频优化"><a href="#CPU的变频优化" class="headerlink" title="CPU的变频优化"></a>CPU的变频优化</h2><p>此章节对你的要求会相对高一点，并且请你具备如下条件：</p><ul><li>有耐心</li><li>CFG已经解锁（这也许不是必要条件）</li><li>已经打开原生电源管理。</li><li>此章节只适用于4代之后的CPU。</li><li>在调整CPU变频时，出现失误导致CPU温度过高，能有正确的处理能力保证CPU不烧毁，我对极端的后果不负责任。</li><li>此教程对无核显用户不友好，需要自己更多的领悟。</li><li>如果你不同意第五条，请不要看下去。</li></ul><p>在Intel四代之后，苹果引入了新的内核级电源管理方式：<code>XCPM</code>（XNU CPU Power Management），这种新的管理方式可以高效地管理电源及变频。同时，苹果也推出了<code>HWP</code> (HardWare controlled Performance states)，这种技术可以快速根据特定程序的需求，作出变频转换。我们这个章节，本质上就是在加载<code>XCPM</code>的情况下，调整<code>HWP</code>来优化CPU的变频。</p><p>同时我要说的是，我在论坛上看到很多所谓的“变频”，有的甚至加载了50多个档位的变频，其实这种是完全没有意义的。我认为，变频是能在你需要的高频的时候快速进入高频状态，在关闭程序后又能很快回到低档位，换句话说，其实只需要三个档位就高了：睿频档，正常频率，以及低频档。</p><ul><li><p>你需要搞清楚自己的cpu型号，并找到、换成与自己cpu型号最接近或者一样的白苹果型号，并且此型号必须带有<code>HWP</code>。一般新的笔记本机型都具有，台式机的话推荐iMac19.1以及Macmini8.1。可查询<a href="https://blog.daliansky.net/A-command-to-teach-you-how-to-confirm-their-own-models-and-how-to-open-the-HWP.html">此帖</a>选取适合的机型。</p></li><li><p>执行如下命令：</p><pre><code class="bash">cd ~/desktop mkdir cpu cd cpu git clone https://github.com/corpnewt/CPUFriendFriend.git git clone https://github.com/acidanthera/CPUFriend.git cp ~/desktop/cpu/CPUFriend/tools/ResourceConverter.sh ~/desktop/cpu/ CpuFriendFriend/CPUFriendFriend.command</code></pre></li><li><p>你会看到如图的命令行，这里1 of 4代表第一段睿频的设置，以此类推，数值越大睿频越高，下面要求你填写的是最低的频率值，你想要低一点的800MHZ就填08，高一点的1300MHZ就填0D（注意大小写）<img src="https://i.loli.net/2020/11/01/cRhHzeEiAQXLSds.png" alt="Screen-Shot-2019-12-09-at-11.28.30-AM.png"></p></li><li><p>填完前两段后，它会要求你填写EPP值，EPP值越低，性能表现越强。我们是填的前两段的低频率部分，我们可以选择节能型的，比如0x80，如果你想极致性能，可以填0x00。<br><img src="https://i.loli.net/2020/11/01/6p4iKMAeIHPyfBC.png" alt="Screen-Shot-2019-12-09-at-11.32.38-AM.png"></p></li><li><p>直至你填完所有4段变频需求后，便会生成你的变频plist。我们执行以下命令:</p><pre><code class="bash">cp ~/Desktop/cpu/CpuFriendFriend/Results/*.* ~/Desktop/cpu</code></pre></li><li><p>我们会在桌面的CPU文件夹中找到你所需要的<code>ResourceConverter.sh</code>以及Mac-xxxxxxx.plist两个文件</p></li><li><p>执行以下命令生成你最终需要的<code>CPUFriendDataProvider.kext</code>,注意命令行中<code>Mac-AA95B1DDAB278B95.plist</code>，请替换成你自己的文件名，这样我们就可以在桌面的CPU文件夹下拿到<code>CPUFriendDataProvider.kext</code>。</p><pre><code class="bash">cd ~/Desktop/cpu ./ResourceConverter.sh --kext ~/Desktop/cpu/Mac-AA95B1DDAB278B95.plist</code></pre></li><li><p>我们再到CPUFriend的<a href="https://github.com/acidanthera/CPUFriend/releases">release</a>页面下，下载最新的release版本，得到里面的CPUFriend.kext</p></li></ul><ul><li><p>将<code>CPUFriendDataProvider.kext</code>与<code>CPUFriend.kext</code>一起放到oc/kexts下,并在config中加载，注意：<code>CPUFriend.kext</code>应该放在<code>CPUFriendDataProvider.kext</code>的前面。</p></li><li><p>感谢@请叫我官人 的帮助。完成，自行测试。</p></li></ul><h2 id="5700-XT-Redeon-VII显卡的性能优化"><a href="#5700-XT-Redeon-VII显卡的性能优化" class="headerlink" title="5700/XT/Redeon VII显卡的性能优化"></a>5700/XT/Redeon VII显卡的性能优化</h2><p>此教程已经发于pcbeta:<a href="http://bbs.pcbeta.com/viewthread-1836920-1-1.html">点此直达</a></p>]]></content>
      
      
      <categories>
          
          <category> Hackintosh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCore </tag>
            
            <tag> Hackintosh </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
